<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林木深的个人博客</title>
  
  <subtitle>热爱技术，痴迷技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linmushen.com/"/>
  <updated>2019-08-18T14:25:18.588Z</updated>
  <id>http://linmushen.com/</id>
  
  <author>
    <name>林木深</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Matlab学习笔记</title>
    <link href="http://linmushen.com/2019/08/16/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/08/16/Matlab学习笔记/</id>
    <published>2019-08-16T05:16:47.000Z</published>
    <updated>2019-08-18T14:25:18.588Z</updated>
    
    <content type="html"><![CDATA[<p>好好学习Matlab。<br><a id="more"></a></p><p>知识积累：<br>运算：<br>1） .  ：矩阵中相同位置的元素进行.后的运算。</p><p>函数：<br>1）画图<br>x = linspace(起始点，终止点，点的个数)<br>y = sin(x)<br>沿sin(x)曲线生成点的个数（默认是100个）个等间距的点</p><p>2）数据拟合：<br>p = polyfit(x,y,n)；返回n+1阶拟合后函数的系数。<br>配合y = polyval(p,x)；计算对应点y的值。</p><p>3）读取Excel电子表格文件<br>xlsread(filename,sheetx,xlrange)<br>filename：文件名<br>sheetx：第几个表格（sheet1,sheet2…）<br>xlrange:矩阵范围A1：H99（从A行的第一列的元素到H行的第九十九的元素之间的矩阵）</p><p>4）清除临时变量<br>clearvars 临时变量1 临时变量2；</p><p>5）创建一个新的临时图像窗口<br>figure</p><p>6）datetick(变量1，变量2)<br>变量1：要改变的轴<br>变量2：日期转变的形式<br><img src="https://i.imgur.com/DGFnl7c.png" alt></p><p>7）xlabel(txt,name,value)</p><ul><li>txt-轴标签</li><li>name-变量的名称 如 fontsize</li><li>value-变量的值  如 fontsize对应的12</li></ul><p>8）mean(变量（一个向量）)<br>返回变量的均值</p><p>9）sum(变量（一个向量）)<br>将变量累加</p><p>10）subplot(m,n,p)<br>将窗口划分成m*n个区域，并在p区域画图。</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><h2 id="学习目录"><a href="#学习目录" class="headerlink" title="学习目录"></a>学习目录</h2><p>1）了解Matlab基本用法，常用的命令。<br>2）熟悉常见模型的求解算法和套路，如：连续模型、规划模型等。<br>3）将机理建模的过程模拟出来，能够建立和求解没有套路的模型。</p><h2 id="主要题型对应的模型"><a href="#主要题型对应的模型" class="headerlink" title="主要题型对应的模型"></a>主要题型对应的模型</h2><p><img src="https://i.imgur.com/3oIfAhp.png" alt><br><img src="https://i.imgur.com/mQt1xY1.png" alt></p><h1 id="第一篇—实战项目"><a href="#第一篇—实战项目" class="headerlink" title="第一篇—实战项目"></a>第一篇—实战项目</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>已知股票的交易数据：日期、开盘价、最高价、最低价、收盘价、成交量、换手率，用某种方法来评价这只股票的价值和风险。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>作为一个科学计算问题，典型的流程是：1.获取并导入数据；2.数据探索和建模；3.分享结果</p><h2 id="Matlab实现"><a href="#Matlab实现" class="headerlink" title="Matlab实现"></a>Matlab实现</h2><h3 id="第一步—从外部读取数据（获取省略，已下为导入部分）"><a href="#第一步—从外部读取数据（获取省略，已下为导入部分）" class="headerlink" title="第一步—从外部读取数据（获取省略，已下为导入部分）"></a>第一步—从外部读取数据（获取省略，已下为导入部分）</h3><p>1）在左侧窗口下找到需要读取的数据的位置<br><img src="https://i.imgur.com/gB5VTcr.png" alt><br>2）右击该文件，点击导入数据<br>3）出现一个导入引擎<br><img src="https://i.imgur.com/gUGdBnC.png" alt><br>4）点击导入所选内容（大绿色对号），点击之前可以选择导入的形式（默认是列向量的形式），之后Matlab工作区出现这些导入的数据。</p><h3 id="第二步—数据探索和建模"><a href="#第二步—数据探索和建模" class="headerlink" title="第二步—数据探索和建模"></a>第二步—数据探索和建模</h3><p>绘制图形：<br>首先双击变量名，然后选中变量，点击绘图建，选择想要绘制的图形，可视化查看数据。<br><img src="https://i.imgur.com/djqIzuE.jpg" alt><br><img src="https://i.imgur.com/xoddok0.png" alt><br>或者输入 plot(x轴：文件名.变量名,y轴：文件名.变量名)</p><p>创建脚本：<br>还是找到数据所在位置，然后右击导入数据，进入菜单，点击大绿对号下的小箭头，选择生成脚本，然后保存该脚本。<img src="https://i.imgur.com/lUzJTng.png" alt></p><p>知识积累：<br>1）画图<br>x = linspace(起始点，终止点，点的个数)<br>y = sin(x)<br>沿sin(x)曲线生成点的个数（默认是100个）个等间距的点</p><p>2）数据拟合：<br>p = polyfit(x,y,n)；返回n+1阶拟合后函数的系数。<br>配合y = polyval(p,x)；计算对应点y的值。</p><p>3）读取Excel电子表格文件<br>xlsread(filename,sheetx,xlrange)<br>filename：文件名<br>sheetx：第几个表格（sheet1,sheet2…）<br>xlrange:矩阵范围A1：H99（从A行的第一列的元素到H行的第九十九的元素之间的矩阵）</p><p>4）清除临时变量<br>clearvars 临时变量1 临时变量2；</p><p>5）创建一个新的临时图像窗口<br>figure</p><p>6）datetick(变量1，变量2)<br>变量1：要改变的轴<br>变量2：日期转变的形式<br><img src="https://i.imgur.com/DGFnl7c.png" alt></p><p>Matlab程序<br>写在了 C:\Users\树枝990\Matlab\Matlab学习1 下</p><h3 id="第三步—发布并转换成word形式"><a href="#第三步—发布并转换成word形式" class="headerlink" title="第三步—发布并转换成word形式"></a>第三步—发布并转换成word形式</h3><p>1）点击发布下的编辑发布内容<br><img src="https://i.imgur.com/YpTRybG.png" alt></p><p>2）改为word形式<br><img src="https://i.imgur.com/ednd6ng.png" alt><br>发布出来的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc,clear,close all</span><br><span class="line">[~,~,raw] = xlsread(&apos;sz000004.xlsx&apos;,&apos;Sheet1&apos;,&apos;A2:H99&apos;);   %读取sz000004.xls文件中的sheet表格中的A2到H99之间矩阵的所有元素</span><br><span class="line">data = reshape([raw&#123;:&#125;],size(raw));     %将raw&#123;:&#125;重构成原来尺寸的矩阵</span><br><span class="line"></span><br><span class="line">Date = data(:,1);</span><br><span class="line">DataNum = data(:,2);</span><br><span class="line">Popen = data(:,3);</span><br><span class="line">Phigh = data(:,4);</span><br><span class="line">Plow = data(:,5);</span><br><span class="line">Pclose = data(:,6);</span><br><span class="line">Volum = data(:,7);</span><br><span class="line">Turm = data(:,8);</span><br><span class="line"></span><br><span class="line">clearvars data raw;</span><br><span class="line"></span><br><span class="line">plot(DataNum,Pclose,&apos;k&apos;)</span><br><span class="line">datetick(&apos;x&apos;,&apos;dd&apos;);     %修改日期形式</span><br><span class="line">xlabel(&apos;日期&apos;);</span><br><span class="line">ylabel(&apos;收盘价格&apos;);</span><br><span class="line">figure %创建一个临时窗口</span><br><span class="line">bar(Pclose)</span><br><span class="line"></span><br><span class="line">p = polyfit(DataNum,Pclose,1);</span><br><span class="line">P1 = polyval(p,DataNum);    %进行拟合</span><br><span class="line">figure</span><br><span class="line">plot(DataNum,P1,DataNum,Pclose,&apos;*g&apos;)</span><br><span class="line">value = p(1);</span><br><span class="line"></span><br><span class="line">MaxDD = maxdrawdown(Pclose);</span><br><span class="line">risk = MaxDD;</span><br></pre></td></tr></table></figure><h1 id="第二篇—回归方法"><a href="#第二篇—回归方法" class="headerlink" title="第二篇—回归方法"></a>第二篇—回归方法</h1><p>数学建模有很多方法，数学建模常用方法包括：回归、统计、机器学习、深度学习、灰色预测、主成分分析、神经网络、时间序列分析。<br>本章介绍几种回归方法。<br>回归方法分为：一元线性、一元非线性、多元回归、逐步回归、Logistic回归。</p><h2 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h2><h3 id="最小二乘法进行拟合"><a href="#最小二乘法进行拟合" class="headerlink" title="最小二乘法进行拟合"></a>最小二乘法进行拟合</h3><p>公式：y=b1*x+b0<br>确定系数的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Lxx = sum((x-mean(x)).^2); %最小二乘法</span><br><span class="line">Lxy = sum((x-mean(x)).*(y-mean(y)));</span><br><span class="line">b1 = Lxy/Lxx;              %最小二乘法拟合出来的直线的斜率</span><br><span class="line">b0 = mean(y)-b1*mean(x);   %最小二乘法拟合出来的直线的截距</span><br></pre></td></tr></table></figure><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">close all;</span><br><span class="line">x = [23.80,27.60,31.60,32.40,33.70,34.90,43.20,52.80,63.80,73.40];</span><br><span class="line">y = [41.40,51.80,61.70,67.90,68.70,77.50,95.90,137.40,155.00,175.00];</span><br><span class="line"></span><br><span class="line">figure</span><br><span class="line">plot(x,y,&apos;r*&apos;)             %画出x,y的散点图</span><br><span class="line">xlabel(&apos;x(职工工资总额)&apos;,&apos;fontsize&apos;,12)   %为x轴标注，并将字体设置为12号</span><br><span class="line">ylabel(&apos;y(商品零售总额)&apos;,&apos;fontsize&apos;,12)   %为y轴标注，并将字体设置为12号</span><br><span class="line">set(gca,&apos;linewidth&apos;,2)     %为坐标轴设置线宽为2号</span><br><span class="line"></span><br><span class="line">Lxx = sum((x-mean(x)).^2); %最小二乘法</span><br><span class="line">Lxy = sum((x-mean(x)).*(y-mean(y)));</span><br><span class="line">b1 = Lxy/Lxx;              %最小二乘法拟合出来的直线的斜率</span><br><span class="line">b0 = mean(y)-b1*mean(x);   %最小二乘法拟合出来的直线的截距</span><br><span class="line">y1 = b1*x+b0;              %拟合后的直线</span><br><span class="line">hold on</span><br><span class="line">plot(x,y1,&apos;linewidth&apos;,2);</span><br></pre></td></tr></table></figure><p>最小二乘法是将散点拟合到一条直线上，得到的直线方程是y=k<em>x+b<br>其中k的公式为<img src="https://i.imgur.com/dDKeeNE.jpg" alt><br>b的公式为y的平均值-k</em>x的平均值。</p><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://i.imgur.com/nq2Xncm.png" alt></p><h2 id="非线性回归"><a href="#非线性回归" class="headerlink" title="非线性回归"></a>非线性回归</h2><p>变量的关系并不都是线性的，用非线性回归首先要解决的问题是回归方程中参数如何估计。</p><h3 id="对数方法进行拟合"><a href="#对数方法进行拟合" class="headerlink" title="对数方法进行拟合"></a>对数方法进行拟合</h3><p>公式：y=a+b*lnx<br>确定系数a,b的方法：调用 fitnlm(x,y,m1,[0.01;0.01])函数<br>具体代码：见最后，和指数方法的一起列出</p><h3 id="指数方法进行拟合"><a href="#指数方法进行拟合" class="headerlink" title="指数方法进行拟合"></a>指数方法进行拟合</h3><p>公式：y=a*x^b<br>确定系数a,b的方法：调用fitnlm(x,y,m2,[1;1])函数<br>具体代码：见最后</p><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">%输入数据</span><br><span class="line"></span><br><span class="line">x = [1.5,4.5,7.5,10.5,13.5,16.5,19.5,22.5,25.5];</span><br><span class="line">y = [7.0,4.8,3.6,3.1,2.7,2.5,2.4,2.3,2.2];</span><br><span class="line"></span><br><span class="line">%画散点图，标明xy轴，加粗坐标轴</span><br><span class="line"></span><br><span class="line">figure</span><br><span class="line">plot(x,y,&apos;b*&apos;);</span><br><span class="line">xlabel(&apos;x(销售额x/万元)&apos;,&apos;fontsize&apos;,12)</span><br><span class="line">ylabel(&apos;y(流通费率y/%)&apos;,&apos;fontsize&apos;,12)</span><br><span class="line">set(gca,&apos;linewidth&apos;,2)</span><br><span class="line"></span><br><span class="line">%进行拟合（对数方法）</span><br><span class="line"></span><br><span class="line">m1 = @(b,x)b(1) + b(2)*log(x);</span><br><span class="line">nonlinfit1 = fitnlm(x,y,m1,[0.01;0.01]);</span><br><span class="line">b = nonlinfit1.Coefficients.Estimate;</span><br><span class="line">Y1 = b(1,1) + b(2,1)*log(x);</span><br><span class="line">hold on</span><br><span class="line">plot(x,Y1,&apos;--k&apos;,&apos;linewidth&apos;,2)</span><br><span class="line"></span><br><span class="line">%再次进行拟合（指数方法）</span><br><span class="line"></span><br><span class="line">m2 = &apos;y~b1*x^b2&apos;;</span><br><span class="line">nonlinfit2 = fitnlm(x,y,m2,[1,1]);</span><br><span class="line">b1 = nonlinfit2.Coefficients.Estimate(1,1);</span><br><span class="line">b2 = nonlinfit2.Coefficients.Estimate(2,1);</span><br><span class="line">Y2 = b1*x.^b2;</span><br><span class="line">hold on</span><br><span class="line">plot(x,Y2,&apos;r&apos;,&apos;linewidth&apos;,2)</span><br><span class="line"></span><br><span class="line">%为每条线加注释</span><br><span class="line"></span><br><span class="line">legend(&apos;原始数据&apos;,&apos;a+b*lnx&apos;,&apos;a*x^b&apos;)</span><br></pre></td></tr></table></figure><h3 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://i.imgur.com/tJM98Lu.png" alt></p><h2 id="多元回归"><a href="#多元回归" class="headerlink" title="多元回归"></a>多元回归</h2><p>在拟合之前，应先通过数据可视化，判断问题能否应该多元线性拟合。</p><h3 id="regress-函数进行拟合"><a href="#regress-函数进行拟合" class="headerlink" title="regress()函数进行拟合"></a>regress()函数进行拟合</h3><h4 id="regress-函数"><a href="#regress-函数" class="headerlink" title="regress()函数"></a>regress()函数</h4><p>[回归系数字母B，回归系数置信区间左边界bint，回归系数（中值）b，回归系数置信区间右区间rint，统计变量s]=repress(Y,X,0.05)</p><p>回归系数:[1,2,3,4]—四个，分别对应b0,b1,b2,b3,<br>回归系数置信区间:[bint,rint]—四组，分别对应b0,b1,b2,b3<br>统计变量s:相关系数的平方R^2;假设检验统计量F;F对应的概率P;s^2的值。</p><p>最终得到方程y = b0 +b1<em>x1 +b2</em>x2 +b3*x3</p><h4 id="判断模型："><a href="#判断模型：" class="headerlink" title="判断模型："></a>判断模型：</h4><p>1）结果法：回归系数置信区间不包含零点的模型比较好。残差在零点附近比较好。<br>2）R法：R越靠近1，说明相关性越高。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>首先将y转置，再构建一个n+1列的矩阵X（x1,x2…,xn均转置，第一列为ones(n,1)）</p><h4 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">%输入数据</span><br><span class="line"></span><br><span class="line">x1 = [3.5,5.3,5.1,5.8,4.2,6.0,6.8,5.5,3.1,7.2,4.5,4.9,8.0,6.5,6.6,3.7,6.2,7.0,4.0,4.5,5.9,5.6,4.8,3.9];</span><br><span class="line">x2 = [9,20,18,33,31,13,25,30,5,47,25,11,23,35,39,21,7,40,35,23,33,27,34,15];</span><br><span class="line">x3 = [6.1,6.4,7.4,6.7,7.5,5.9,6.0,4.0,5.8,8.3,5.0,6.4,7.6,7.0,5.0,4.4,5.5,7.0,6.0,3.5,4.9,4.3,8.0,5.8];</span><br><span class="line">y = [33.2,40.3,38.7,46.8,41.4,37.5,39.0,40.7,30.1,52.9,38.2,31.8,43.3,44.1,42.5,33.6,34.2,48.0,38.0,35.9,40.4,36.8,45.2,35.1];</span><br><span class="line"></span><br><span class="line">%绘制散点图</span><br><span class="line"></span><br><span class="line">plot(x1,y,&apos;b*&apos;)</span><br><span class="line">hold on</span><br><span class="line">plot(x2,y,&apos;ro&apos;)</span><br><span class="line">hold on</span><br><span class="line">plot(x3,y,&apos;g+&apos;)</span><br><span class="line">hold on</span><br><span class="line"></span><br><span class="line">%进行拟合</span><br><span class="line"></span><br><span class="line">n = 24;</span><br><span class="line">X = [ones(n,1),x1&apos;,x2&apos;,x3&apos;];</span><br><span class="line">Y = y&apos;;</span><br><span class="line">[b,bint,r,rint,s] = regress(Y,X,0.05)</span><br><span class="line"></span><br><span class="line">%写出表达式</span><br><span class="line"></span><br><span class="line">y1 = b(1)+ b(2)*x1 +b(3)*x2 +b(4)*x3</span><br></pre></td></tr></table></figure><h2 id="逐步回归"><a href="#逐步回归" class="headerlink" title="逐步回归"></a>逐步回归</h2><p>调用stepwise(X,Y,0.05,0.1)函数<br>X是由x1，x2…xn组成的，x1，x2…xn的第一个元素组成第一行，第二个组成第二行…<br>然后得到逐步回归窗口点击 Next Step 直至变成灰色，表明逐步回归结束，得到最终的回归模型。</p><h2 id="logistic回归"><a href="#logistic回归" class="headerlink" title="logistic回归"></a>logistic回归</h2><p>搞不懂，大概是输入一组数据，判断是0是1。</p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">[~,~,raw] = xlsread(&apos;Logistic.xlsx&apos;,&apos;sheet1&apos;,&apos;A2:F26&apos;);</span><br><span class="line">data = reshape([raw&#123;:&#125;],size(raw));</span><br><span class="line"></span><br><span class="line">X0 = xlsread(&apos;Logistic.xlsx&apos;,&apos;B2:D21&apos;);</span><br><span class="line">Y0 = xlsread(&apos;Logistic.xlsx&apos;,&apos;E2:E21&apos;);</span><br><span class="line">X1 = xlsread(&apos;Logistic.xlsx&apos;,&apos;B2:D26&apos;);</span><br><span class="line">%logistic函数</span><br><span class="line">GM = fitglm(X0,Y0,&apos;Distribution&apos;,&apos;binomial&apos;);</span><br><span class="line">Y1 = predict(GM,X1);</span><br><span class="line">%模型评估</span><br><span class="line">N0 = 1:size(Y0,1);N1 = 1:size(Y1,1);</span><br><span class="line">hold on</span><br><span class="line">scatter(N1&apos;,Y1,&apos;b&apos;);</span><br><span class="line">plot(N0&apos;,Y0,&apos;-kd&apos;);</span><br><span class="line">xlabel(&apos;数据点编号&apos;);</span><br><span class="line">ylabel(&apos;输出值&apos;);</span><br></pre></td></tr></table></figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1）判断变量个数：一个用一元回归，超过两个用多元回归。<br>2）如果一元，判断是否线性；如果多元，先拟合，再检验效果。</p><h1 id="第三篇—机器学习方法"><a href="#第三篇—机器学习方法" class="headerlink" title="第三篇—机器学习方法"></a>第三篇—机器学习方法</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好好学习Matlab。&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>OPENMV学习笔记</title>
    <link href="http://linmushen.com/2019/07/29/OPENMV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/07/29/OPENMV学习笔记/</id>
    <published>2019-07-29T11:07:59.000Z</published>
    <updated>2019-08-18T15:15:28.590Z</updated>
    
    <content type="html"><![CDATA[<p>本节根据星瞳科技的OPENMV<br><a id="more"></a></p><h1 id="OPENMV图像处理方法"><a href="#OPENMV图像处理方法" class="headerlink" title="OPENMV图像处理方法"></a>OPENMV图像处理方法</h1><h2 id="感光元件"><a href="#感光元件" class="headerlink" title="感光元件"></a>感光元件</h2><p>sensor模块，用于设置感光元件的参数。</p><blockquote><p>初始化：.resert()–初始化感光元件。<br>设置彩色/黑白：.set_pixformat(sensor.RGB565[彩色]/sensor.GARYSCALE[灰度])<br>设置图像大小：.set_framesize([A])</p><blockquote><p>其中A：sensor.QQVGA: 160x120<br>sensor.QQVGA2: 128x160 (用于 lcd 扩展板)<br>sensor.HQVGA: 240x160<br>sensor.QVGA: 320x240<br>sensor.VGA: 640x480 (只用于OpenMV Cam M7 的灰度图处理图像，或者彩图采集图像)<br>sensor.QQCIF: 88x72<br>sensor.QCIF: 176x144<br>sensor.CIF: 352x288</p></blockquote></blockquote><blockquote><p>跳过一些帧：.skip_frames(n=需要跳过的帧数,time=需要跳过的ms数)。<br>获取一张图象：.snapshot()，拍摄一张照片并返回一个image对象。<br>自动增益：.set_auto_gain(True/False)，使用颜色追踪时，需要关闭(False)自动增益。<br>白平衡：.set_auto_whitebat(True/False)，使用颜色追踪时，需要关闭(False)白平衡。<br>设置窗口ROI：.set_windowing(roi)，roi的格式是(x,y)，取中间的x*y区域。ROI为感兴趣区。<br>设置翻转：.set_hmirror(True)—水平方向翻转；.set_vflip(True)—垂直方向翻转。</p></blockquote><h1 id="图像的基本运算"><a href="#图像的基本运算" class="headerlink" title="图像的基本运算"></a>图像的基本运算</h1><h2 id="获取设置像素点-pixel"><a href="#获取设置像素点-pixel" class="headerlink" title="获取设置像素点(pixel)"></a>获取设置像素点(pixel)</h2><ol><li>image.get_pixel(x,y):返回image中(x,y)处的像素值（若为灰度图，返回灰度值；若为彩色图，返回RGB 的元组）。</li><li>image.set_pixel(x,y):设置image中(x,y)处的像素值（若为灰度图，设置灰度值；若为彩色图，设置(R,G,B)的值。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节根据星瞳科技的OPENMV&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>Matlab相关</title>
    <link href="http://linmushen.com/2019/04/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1M/"/>
    <id>http://linmushen.com/2019/04/17/数学建模M/</id>
    <published>2019-04-17T13:59:01.000Z</published>
    <updated>2019-08-18T15:15:28.594Z</updated>
    
    <content type="html"><![CDATA[<p>有一些关于Matlab的知识<br><a id="more"></a></p><h1 id="Matlab知识笔记"><a href="#Matlab知识笔记" class="headerlink" title="Matlab知识笔记"></a>Matlab知识笔记</h1><ul><li>Matlab主要用来处理整个矩阵和数组。</li><li>所有matlab变量都是多维的。</li><li>matlab将数字存储为浮点值</li></ul><h2 id="命令与函数"><a href="#命令与函数" class="headerlink" title="命令与函数"></a>命令与函数</h2><h3 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h3><ol><li>help inv ：显示函数（inv）的帮助信息</li><li>[]  ：创建矩阵</li><li>[]; : 创建一个矩阵但不在命令行中显示出来</li><li>,   ：矩阵行元素分隔符号</li><li>;   ：矩阵列元素分隔符号</li><li>%   : 注释行</li><li>clear ：清理工作空间中的各种变量</li><li>== ：关系运算符：等于</li><li>~= ：关系运算符：不等于</li><li>| ：逻辑或运算</li></ol><h3 id="定义类型"><a href="#定义类型" class="headerlink" title="定义类型"></a>定义类型</h3><ol><li>format short : 定义输出格式为短，显示小数点后四位</li><li>format long : 定义输出格式为长，显示小数点后14（15）位</li><li>format rat：以有理数形式输出<blockquote><p>format只影响输出格式，不影响存储方式 </p></blockquote></li><li>syms x ：定义x为符号变量</li></ol><h3 id="控制流程语句"><a href="#控制流程语句" class="headerlink" title="控制流程语句"></a>控制流程语句</h3><ol><li>if..else if..end : 条件语句，作用与c中类似</li><li>for..end : for循环语句，与c类似</li></ol><h3 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h3><ol><li>n=input(‘…’):输入函数，其中’’之间的是提示字符</li><li>disp(‘….’):显示单引号中字符串</li></ol><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="创建矩阵的函数"><a href="#创建矩阵的函数" class="headerlink" title="创建矩阵的函数"></a>创建矩阵的函数</h3><ol><li>eye(n):创建n阶单位矩阵</li><li>zeros（m,n）：创建m*n阶零矩阵</li><li>zeros(n) :创建n阶方阵</li><li>ones（m,n):创建m*n阶元素全为1的矩阵</li><li>rand（m,n):创建m*n阶元素为从0到1均匀分布的随机数矩阵</li><li>randn(m,n):创建m*n阶均值为0，方差为1的标准正态分布随机矩阵</li><li>round（A）：对矩阵A所有元素进行四舍五入运算</li></ol><h3 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h3><ol><li>inv(A):求矩阵A的逆</li><li>A^-1:用幂运算求矩阵A的逆</li><li>a’ ：a的转置</li><li>inv(a):a的逆矩阵</li><li><ul><li>：执行标准矩阵乘法，计算行与列之间的内积</li></ul></li><li>\ :MATLAB特有的矩阵左除A/B=inv（A)*B</li><li>/ ：matlab特有的矩阵右除B/A=B*inv（A)</li><li>. ：在运算符号前加 . 含义为对应矩阵群运算（元素级运算，即每一个元素之间的运算）<blockquote><ul><li>只有乘除幂运算有相应的群运算。</li><li>C=A.*B：矩阵元素群运算（A,B矩阵中对应元素相乘）</li><li>D=A.^2:矩阵元素群运算（A中每一个元素平方）【a^2，相当于a乘a；a.^2，相当于a的每一个元素平方】</li></ul></blockquote></li><li>：  ：冒号运算符，start:step:end   不写step的值时，默认为1<blockquote><p>可以创建等距向量 ：B=0：50：100    </p><blockquote><p>B = 0，50，100</p></blockquote></blockquote></li></ol><h2 id="行列式与方程组求解"><a href="#行列式与方程组求解" class="headerlink" title="行列式与方程组求解"></a>行列式与方程组求解</h2><ol><li>U=rref(A)  :对矩阵A进行初等行变换，得到的U是A的最简行列式<blockquote><p>rref([A,b]) :就是将A，b的混合矩阵化为行最简</p></blockquote></li><li>[m,n]=size(A)：计算A的行，列，并返回一个二维向量</li><li>det(A):计算矩阵A的行列式</li><li>rank(A):计算矩阵A的秩</li><li>A(i,j) :引出A的第i行第j列的元素</li><li>B（：，i)=b : 把向量b的值赋给矩阵B的第i列（矩阵B的列向量和向量b同型）</li><li>B（：，1：5）：取矩阵的第一列至第五列</li><li>[A,eye(5)] : 创建一个5*10矩阵，前五列为A，后五列为单位矩阵i</li><li>T(1,:)=[] : 把一个空行赋给T的第1行（删除T的第一行）</li><li>factor(D):对符号变量多项式D进行因式分解</li><li>solve(D) :求符号变量多项式方程D=0的解</li></ol><h2 id="工作区变量"><a href="#工作区变量" class="headerlink" title="工作区变量"></a>工作区变量</h2><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>在Matlab中创建或从其他程序导入的变量</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><ol><li>使用： whos</li><li>直接在工作区窗格查看</li></ol><h3 id="保存和还原"><a href="#保存和还原" class="headerlink" title="保存和还原"></a>保存和还原</h3><ol><li>使用save name.mat保存到压缩文件中</li><li>使用load name.mat将mat中数据还原到工作区</li></ol><h2 id="文本和字符"><a href="#文本和字符" class="headerlink" title="文本和字符"></a>文本和字符</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>文本：与其他语言类似：字符串用单引号括起来，如果字符串中有单引号则单引号用两个单引号’’表示。</li><li>把文本赋值给变量，变量类型为数组（数据类型为char）</li><li>同样可以用[]来进行串联 a=’lin’ b=’mu’  A = [a,’-‘,b]<blockquote><p>A: ‘lin-mu’</p></blockquote><h3 id="数值与字符的转化"><a href="#数值与字符的转化" class="headerlink" title="数值与字符的转化"></a>数值与字符的转化</h3></li><li>由于数值不能与字符变量进行串联，所以需要将数值转化成char型</li></ul><ol><li>num2str(c)  c=3.33  <blockquote><p>转化为 ‘3.33’</p></blockquote></li><li>int2str(c) <blockquote><p>转化为 ‘3’</p></blockquote></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>clc: 清空命令窗口<br>clear: 清空工作区间的变量<br>mean()：获得一个序列的均值<br>std（）：获得一个序列的方差<br>magic():魔方矩阵<br>hilb():产生一个希尔伯特矩阵</p><blockquote><p>矩阵各个值为H（ij）= i+j-1分之一</p></blockquote><h1 id="入门学习"><a href="#入门学习" class="headerlink" title="入门学习"></a>入门学习</h1><h2 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h2><h3 id="常规方法"><a href="#常规方法" class="headerlink" title="常规方法"></a>常规方法</h3><p> 使用 ， 或 空格 来分隔各元素</p><blockquote><p>a = [1,2,3,4]<br>b = [1 2 3 4]<br> 使用 ； 来分隔各行</p></blockquote><h3 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h3><p> 使用ones zeros 或 rand函数（具体函数参照上文）</p><blockquote><p>z = zeros(5,1)   %创建一个五行一列的矩阵</p></blockquote><h2 id="矩阵与数组的运算"><a href="#矩阵与数组的运算" class="headerlink" title="矩阵与数组的运算"></a>矩阵与数组的运算</h2><h3 id="使用运算符"><a href="#使用运算符" class="headerlink" title="使用运算符"></a>使用运算符</h3><p> 使用单一的算术运算符或函数来处理矩阵中的所有值</p><blockquote><p>a+10     %对矩阵a中每一个元素加十<br>sin(a)   %对矩阵中每一个元素进行正弦处理<br>a’       %对矩阵a转置</p></blockquote><h3 id="串联"><a href="#串联" class="headerlink" title="串联"></a>串联</h3><ol><li>串联是连接数组以便形成更大数组的过程。（数组的创建也是如此，通过将各个元素串联而构成的）</li><li>[]即为串联符<br>规则：<blockquote><p>A = [a,b]   %将数组a与数组b水平串联，ab必须具有相同的行数<br>B = [a;b]   %将数组a与数组b竖直串联，ab必须具有相同的列数</p></blockquote></li></ol><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>复数包含 实部和虚部<br>虚数单位是-1的平方根</p><h2 id="数组的索引"><a href="#数组的索引" class="headerlink" title="数组的索引"></a>数组的索引</h2><p>前提 ：</p><blockquote><p>A = [1,2,3,4;4,3,2,1;5,6,7,8]</p></blockquote><h3 id="引用单个元素"><a href="#引用单个元素" class="headerlink" title="引用单个元素"></a>引用单个元素</h3><ol><li>A(4,2)     %引用数组中的特定元素，指定行标和列标</li><li>A(8)       %用单一下标，逐个遍历每一<strong>**</strong>列<strong>**</strong>  ；也叫线性索引<h3 id="添加单个元素"><a href="#添加单个元素" class="headerlink" title="添加单个元素"></a>添加单个元素</h3></li></ol><ul><li>A(4,3)=10  %在索引不存在的情况下，在右边进行赋值，数组大小就会扩大，其余部分填0<h3 id="引用多个元素"><a href="#引用多个元素" class="headerlink" title="引用多个元素"></a>引用多个元素</h3>用冒号 </li></ul><ol><li>A(1:3,2)   %指定一个start:end的范围（以原来形式列出前三行第二列的元素）</li><li>A(:,2)     %单独只有冒号，则列出该列所有元素 </li></ol><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>无接收值无参数： clc    （只写函数名）</p><h3 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h3><ol><li>使用单个参数：name(a)</li><li>使用多个参数：name(a,b)<h3 id="接收函数值"><a href="#接收函数值" class="headerlink" title="接收函数值"></a>接收函数值</h3></li><li>接收单个值：A = name(a)</li><li>接收多个值：[A,B] = name(a)</li></ol><h2 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h2><h3 id="线图"><a href="#线图" class="headerlink" title="线图"></a>线图</h3><ol><li>使用plot(x,y)函数绘制<blockquote><p>plot(x,y,‘r–’):第三个参数为线条设定（r–为红色虚线）<strong>注意：要用单引号引起来</strong></p><blockquote><p>线条设定包括线条颜色（r,g…)、样式、标记的字符(+、o、*标记各个数据点）</p></blockquote></blockquote></li><li>在plot(x,y)后使用 xlabel(‘x’)  ylabel(‘y’)  title(‘my title’)标记各个轴和写标题</li><li>默认情况下，matlab每调用一次绘图函数、重置坐标区及其他元素时，都会清除图窗<blockquote><p>若要保留，则使用 hold on。终止用hold off。</p></blockquote></li></ol><h3 id="三维图形"><a href="#三维图形" class="headerlink" title="三维图形"></a>三维图形</h3><ol><li>首先使用meshgrid创建一组点（x,y)<blockquote><p>meshgrid(X,Y): X，Y：为两个行向量，步数默认为1，范围给定（X=1：2   Y=1:3)<br>然后将X复制Y的元素个数次（3次），将Y复制X的元素个数次（2次）</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些关于Matlab的知识&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>语法内容</title>
    <link href="http://linmushen.com/2019/04/03/%E8%AF%AD%E6%B3%95%E5%86%85%E5%AE%B9/"/>
    <id>http://linmushen.com/2019/04/03/语法内容/</id>
    <published>2019-04-03T15:36:32.000Z</published>
    <updated>2019-08-18T15:15:28.598Z</updated>
    
    <content type="html"><![CDATA[<p>为了更方便的记笔记，我搭建了这个博客<br> <a id="more"></a></p><h1 id="习题三十七：复习各种符号"><a href="#习题三十七：复习各种符号" class="headerlink" title="习题三十七：复习各种符号"></a>习题三十七：复习各种符号</h1><ul><li>总注</li></ul><ol><li>True为任意非0或非空的值。0或空为False。</li><li>Traceback，回溯，一种错误信息</li><li>python用异常对象表示异常情况。异常对象未被捕捉或处理，则会用回溯的方式结束程序</li><li>python中对象包含三个基本元素：id（身份标识），type（数据类型），value（值）</li></ol><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h2><ul><li>and </li><li>not</li><li>or</li><li>from </li><li>import</li><li>del</li><li>while</li><li>as</li><li>global</li><li>with</li><li>if/elif/else</li><li>assert</li><li>pass</li><li>yield</li><li>break</li><li>expect</li><li>finally</li><li>print</li><li>class</li><li>exec</li><li>in</li><li>raise</li><li>continue</li><li>is</li><li>return</li><li>def</li><li>for</li><li>lambda</li><li>try</li></ul><hr><h2 id="逻辑关键词-and-or-not"><a href="#逻辑关键词-and-or-not" class="headerlink" title="逻辑关键词(and,or,not)"></a>逻辑关键词(and,or,not)</h2><h3 id="优先级："><a href="#优先级：" class="headerlink" title="优先级："></a>优先级：</h3><blockquote><p>优先级从大到小为：</p><blockquote><p>not&gt;and&gt;or</p></blockquote></blockquote><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值:"></a>返回值:</h3><blockquote><h4 id="and：（x为真返回y，x为假返回x）"><a href="#and：（x为真返回y，x为假返回x）" class="headerlink" title="and：（x为真返回y，x为假返回x）"></a>and：（x为真返回y，x为假返回x）</h4><blockquote><p>and的返回值是决定表达式结果的值。</p><blockquote><p>如x and y：若x为真，则y决定了表达式的结果，返回值为y（与表达式真假无关，只要x为真，就返回y）。若x为假，则返回值为x。</p></blockquote></blockquote></blockquote><blockquote><h4 id="or-not："><a href="#or-not：" class="headerlink" title="or/not："></a>or/not：</h4><blockquote><p>x or y有一个结果真，返回的结果就是真。</p><blockquote><p>print(x or y):x为真输出x，x为假输出y。</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>not 布尔表达式 ：返回与表达式结果相反的值。</p><blockquote><p>print(not 表达式）：只输出False/Ture </p></blockquote></blockquote></blockquote><p>##print语句</p><blockquote><p>print会自动在末尾加\n，如果不需要，直接在最末加‘，’。（如果有字符串，在引号外）</p><p>输出变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line">print num</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print 1</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;lin mu shen &quot;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出字符串加变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=&apos;lin&apos;</span><br><span class="line">print&quot;str=&quot;,str</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>格式化输出数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line">print&apos;num= %d&quot; %num</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>格式化输出字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str=&apos;lin&apos;</span><br><span class="line">print &apos;str= %s&apos; %str    #输出lin</span><br><span class="line">print &apos;str=.1%s&apos; %str   #输出l</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>格式化输出原样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str=&apos;lin&apos;</span><br><span class="line">num=1</span><br><span class="line">print &apos;str=%r,num=%r&apos; %(str,num)   # str=&apos;lin&apos;,num=1</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="模块的引入（import-from…import）"><a href="#模块的引入（import-from…import）" class="headerlink" title="模块的引入（import/from…import）"></a>模块的引入（import/from…import）</h2><h3 id="import语句的使用"><a href="#import语句的使用" class="headerlink" title="import语句的使用"></a>import语句的使用</h3><blockquote><p>导入模块：</p><blockquote><p>import 模块<br>这个声明将整个模块导入</p></blockquote></blockquote><blockquote><p>调用模块中的函数：</p><blockquote><p>模块名.函数名</p></blockquote></blockquote><blockquote><p>无论执行多少次import，模块只会被导入一次。</p></blockquote><h3 id="from…import语句的使用"><a href="#from…import语句的使用" class="headerlink" title="from…import语句的使用"></a>from…import语句的使用</h3><blockquote><p>导入模块中的指定部分：</p><blockquote><p>from 模块名 import 函数名<br>这个声明将模块中的特定函数导入</p></blockquote></blockquote><blockquote><p>调用函数:</p><blockquote><p>函数名()</p></blockquote></blockquote><h3 id="from…import-的使用"><a href="#from…import-的使用" class="headerlink" title="from…import * 的使用"></a>from…import * 的使用</h3><blockquote><p>导入模块中所有内容:</p><blockquote><p>from 模块名 import *</p></blockquote></blockquote><blockquote><p>调用模块中的任意函数：</p><blockquote><p>函数名（）</p></blockquote></blockquote><h3 id="improt…as…"><a href="#improt…as…" class="headerlink" title="improt…as…"></a>improt…as…</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import game_functions as gf</span><br></pre></td></tr></table></figure><p>为导入的模块起一个代号</p><h2 id="del语句"><a href="#del语句" class="headerlink" title="del语句"></a>del语句</h2><ul><li><p>del语句作用在变量上，而不是数据对象上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line">b=a</span><br><span class="line">del a</span><br><span class="line">print b</span><br><span class="line">del a,b     #也可以使用del一次删除多个变量的引用</span><br></pre></td></tr></table></figure></li><li><p>输出结果为1。</p></li><li>del只解除了a对1的引用，并没有删除数据a。</li></ul><h2 id="定义函数（def）"><a href="#定义函数（def）" class="headerlink" title="定义函数（def）"></a>定义函数（def）</h2><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def name(形式参数):</span><br><span class="line">   执行语句</span><br><span class="line">name(实际参数）</span><br></pre></td></tr></table></figure></p><p>值得一提，形式参数是一个局部变量，而实际参数是一个全局变量，调用函数的过程中，实际参数被赋值给形式参数。</p><h2 id="定义一个匿名函数（lambda表达式）"><a href="#定义一个匿名函数（lambda表达式）" class="headerlink" title="定义一个匿名函数（lambda表达式）"></a>定义一个匿名函数（lambda表达式）</h2><p>起到一个函数速写的作用</p><blockquote><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def name(n)</span><br><span class="line">return lambda x: x*n#定义了一个匿名函数</span><br><span class="line">double=name(2)              #把函数值赋给变量</span><br><span class="line">print double(8)#double还需要一个变量</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出：<br>16</p></blockquote><h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p>return将结果与程序控制权一起返回到调用位置。<br>程序运行到第一个return位置即返回（退出函数）（但在try/finally情况下不是，在try遇到return，也会继续执行finally）（也就是说，函数可以有多个return语句）<br>如：返回两个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return x,y</span><br></pre></td></tr></table></figure></p><h2 id="成员运算符（in，not-in）"><a href="#成员运算符（in，not-in）" class="headerlink" title="成员运算符（in，not in）"></a>成员运算符（in，not in）</h2><ol><li>配合if用来查找元素是否在可迭代对象中<blockquote><p>if x in list   如果在，返回真<br>if x  not in list   如果不在，返回真</p></blockquote></li><li>配合for逐个取可迭代对象的元素<blockquote><p>for i in list   i取遍list中每一个元素</p></blockquote></li></ol><h2 id="身份运算符（is-，is-not）"><a href="#身份运算符（is-，is-not）" class="headerlink" title="身份运算符（is ，is not）"></a>身份运算符（is ，is not）</h2><p>is与==一样，都是对对象进行比较判断作用的运算符<br>但对对象比较判断的内容不同<br>is用来比较对象id是否相同。<br>可以用print id（x）来查看x的id</p><h2 id="global语句"><a href="#global语句" class="headerlink" title="global语句"></a>global语句</h2><blockquote><p>用于定义全局变量<br>global用于给定义在函数外的变量赋值，用global表明，这是个全局变量而非局部变量。</p></blockquote><blockquote><p>global语句可以在函数内对定义在函数外的变量赋值<br>赋值产生的变化也同时反映在主块中的变量</p><p>使用：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i=20</span><br><span class="line">def somefau()</span><br><span class="line">  global i</span><br><span class="line">  print i</span><br><span class="line">  i=10</span><br><span class="line">  print&quot;2nd=&quot;,i</span><br></pre></td></tr></table></figure><blockquote><p>输出结果</p><blockquote><p>20</p></blockquote></blockquote><blockquote><blockquote><p>2nd=10<br>通过global实现了在函数内对主块变量的赋值</p></blockquote></blockquote><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while型"><a href="#while型" class="headerlink" title="while型"></a>while型</h3><blockquote><h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句:"></a>while循环语句:</h4><blockquote><p>基本形式：（注：执行语句前要有缩进）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 判断条件：</span><br><span class="line">  执行语句...</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>当判断条件为Ture时，则会无限循环。</p></blockquote></blockquote><blockquote><h4 id="while…else语句："><a href="#while…else语句：" class="headerlink" title="while…else语句："></a>while…else语句：</h4><blockquote><p>基本形式：（注：同样要缩进)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while 判断条件：</span><br><span class="line">  执行语句1...</span><br><span class="line">else：</span><br><span class="line">  执行语句2...</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><ul><li>当判断条件为Ture时，执行1。</li><li>当判断条件为False时，执行2。</li></ul></blockquote></blockquote><blockquote><h4 id="while的简单语句组："><a href="#while的简单语句组：" class="headerlink" title="while的简单语句组："></a>while的简单语句组：</h4><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(判断语句）：执行语句</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>当执行语句只有一行时，可以将执行语句与while写在同一行。</p></blockquote></blockquote><blockquote><h4 id="while的附加命令"><a href="#while的附加命令" class="headerlink" title="while的附加命令:"></a>while的附加命令:</h4><blockquote><h5 id="continue："><a href="#continue：" class="headerlink" title="continue："></a>continue：</h5><blockquote><p>continue用于跳过当次循环</p></blockquote></blockquote><blockquote><blockquote><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = 1</span><br><span class="line">while i&lt;10:</span><br><span class="line">    i += 1</span><br><span class="line">    if i%2 == 0:</span><br><span class="line">        continue</span><br><span class="line">    print i</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><blockquote><blockquote><h5 id="break"><a href="#break" class="headerlink" title="break:"></a>break:</h5><blockquote><p>break用于退出循环</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>使用：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line">while 1:</span><br><span class="line">    i+=1</span><br><span class="line">    if i&gt;10:</span><br><span class="line">         break</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="for型"><a href="#for型" class="headerlink" title="for型"></a>for型</h3><blockquote><h4 id="for…in…"><a href="#for…in…" class="headerlink" title="for…in…"></a>for…in…</h4><p>主要用于遍历列表，字符串。</p><blockquote><h5 id="使用-遍历列表）："><a href="#使用-遍历列表）：" class="headerlink" title="使用(遍历列表）："></a>使用(遍历列表）：</h5></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4,5]</span><br><span class="line">for num in list</span><br><span class="line">    print num</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>输出结果：</p><blockquote><p>1</p></blockquote></blockquote><blockquote><blockquote><p>2</p></blockquote></blockquote><blockquote><blockquote><p>3</p></blockquote></blockquote><blockquote><blockquote><p>4</p></blockquote></blockquote><blockquote><blockquote><p>5</p></blockquote></blockquote></blockquote><blockquote><blockquote><h5 id="使用（遍历字符串）："><a href="#使用（遍历字符串）：" class="headerlink" title="使用（遍历字符串）："></a>使用（遍历字符串）：</h5></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for var in &apos;lin&apos;</span><br><span class="line">    print var</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>输出结果：</p><blockquote><p>l</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>i</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>n</p></blockquote></blockquote></blockquote><blockquote><blockquote><h5 id="通过指针变量来进行遍历："><a href="#通过指针变量来进行遍历：" class="headerlink" title="通过指针变量来进行遍历："></a>通过指针变量来进行遍历：</h5></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4,5]</span><br><span class="line">for i in range(5):</span><br><span class="line">    num = list[i]</span><br><span class="line">    print num,</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>输出结果：</p><blockquote><p>1 2 3 4 5</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><h6 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数:"></a>range()函数:</h6><p>range（start，stop,step）可创建一个整数列表：<br>三个参数</p><blockquote><p>start:计数开始位置，默认是0。如range(3)等价于range（0，3）</p></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>stop:计数结束位置，但不包括stop。如range（0，5）中没有5。</p></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>step:步长（每次加的数），默认是1。如range(0,6,2)为[0,1,3,5]</p></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><h4 id="for…in-else"><a href="#for…in-else" class="headerlink" title="for…in:/else:"></a>for…in:/else:</h4></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(10):</span><br><span class="line">    print i</span><br><span class="line">else:</span><br><span class="line">    print i+100</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>for中语句与之前的没有区别，但else只在for正常循环结束后（不是通过break结束）的情况下被执行。</p></blockquote></blockquote><h2 id="占位语句（pass）"><a href="#占位语句（pass）" class="headerlink" title="占位语句（pass）"></a>占位语句（pass）</h2><ul><li>pass不做任何事情，只用作占位。</li><li>没想好函数内容是，在函数内写入一条pass可以避免报错<blockquote><p>像这样：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def unthink()</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></li></ul><h2 id="条件语句（if…elif…else…"><a href="#条件语句（if…elif…else…" class="headerlink" title="条件语句（if…elif…else…)"></a>条件语句（if…elif…else…)</h2><blockquote><blockquote><p>通过一条或多条语句的执行结果（Ture或False)来决定执行的代码块。</p></blockquote></blockquote><blockquote><blockquote><p>要格外注意缩进的问题，没进入一个新代码块，打两个空格</p></blockquote><blockquote><p>使用：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件1：</span><br><span class="line">    执行语句1</span><br><span class="line">elif 判断条件2：</span><br><span class="line">    执行语句2</span><br><span class="line">···</span><br><span class="line">else:</span><br><span class="line">    执行语句n</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>也有类似于while的简单语句组：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if 判断语句：执行语句</span><br></pre></td></tr></table></figure></blockquote><h2 id="捕捉异常并处理（try-except-else-finally）"><a href="#捕捉异常并处理（try-except-else-finally）" class="headerlink" title="捕捉异常并处理（try/except/else/finally）"></a>捕捉异常并处理（try/except/else/finally）</h2><blockquote><p>检测try中的错误，用except捕获异常并处理。<strong> 然后程序返回到try位置 </strong><br>可以做到异常发生时不结束程序。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法:"></a>语法:</h3><p>三者顺序不能乱，且有else就必须有except</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  语句1    #先执行语句1</span><br><span class="line">  ...</span><br><span class="line">except name:</span><br><span class="line">  语句2    #发生name异常，执行语句2，而后通过整个try</span><br><span class="line">  ...</span><br><span class="line">except name1，数据：</span><br><span class="line">  语句3    #发生name1异常，执行语句3，获得数据。数据可以是（as reason 输出程序检测到的错误类型）</span><br><span class="line">except：</span><br><span class="line">  语句3_1  #没有匹配到的异常，执行语句3_1</span><br><span class="line">else:</span><br><span class="line">  语句4    #语句1没有异常，执行此代码</span><br><span class="line">finally:</span><br><span class="line">  语句5    #无论有无异常发生，都会执行语句5</span><br></pre></td></tr></table></figure><blockquote><p>执行语句1，根据语句1发生的异常类型来选择执行的except下的代码块，没有发生异常则执行else下的代码块。</p></blockquote><h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    num1 = raw_input(&apos;输入一个数字&apos;)</span><br><span class="line">    num1 = int(num1)</span><br><span class="line">except ValueError , as reason:</span><br><span class="line">    print &quot;请输入一个数字&quot;, reason</span><br><span class="line">else:</span><br><span class="line">    print num1</span><br><span class="line">finally:</span><br><span class="line">    print &quot;无论如何都执行我&quot;</span><br></pre></td></tr></table></figure><blockquote><p>输入：5<br>输出：</p><blockquote><p>5</p></blockquote><blockquote><p>无论如何都输出我</p></blockquote></blockquote><blockquote><p>输入：a<br>输出：</p></blockquote><blockquote><blockquote><p>请输入一个数字</p></blockquote></blockquote><blockquote><blockquote><p>无论如何都输出我</p></blockquote></blockquote><blockquote><blockquote><p>_(光标，回到try位置）</p></blockquote></blockquote><h2 id="捕捉异常语句并处理（with-as"><a href="#捕捉异常语句并处理（with-as" class="headerlink" title="捕捉异常语句并处理（with as)"></a>捕捉异常语句并处理（with as)</h2><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with expresion as val:</span><br><span class="line">    语句1</span><br></pre></td></tr></table></figure><blockquote><p>执行过程：先执行expresion中的<em>enter</em>（）方法，这个方法的返回值被赋值给val（若没有as val，则返回值被忽略）。接着执行语句1，语句1若出现异常，执行expresion中的<em>exit</em>()方法，若果没有异常，则在执行完毕后执行<em>exit</em>（）方法。</p></blockquote><h3 id="例如"><a href="#例如" class="headerlink" title="例如:"></a>例如:</h3><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(lin.txt) as obj:</span><br><span class="line">    data=obj.read()</span><br></pre></td></tr></table></figure><p>等价于</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    obj=open(lin.txt)</span><br><span class="line">    data=obj.read()</span><br><span class="line">finally:</span><br><span class="line">    obj.close</span><br></pre></td></tr></table></figure><p>也就是说，无论读取文件是否出现异常，都会执行关闭文件句柄这一个操作</p><h2 id="exec-函数"><a href="#exec-函数" class="headerlink" title="exec()函数"></a>exec()函数</h2><blockquote><p>exec函数能够执行复杂的python代码。</p></blockquote><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k=10</span><br><span class="line">exec(&apos;i=10 j=100 anw=i*j*k print anw&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br>10000<br>exec（’str’,’参数’）<br>也可以在参数位置改变k值<br>也就是说，exec（）函数可以执行字符串形式的python代码）<br>如果上面的字符串在一个.txt文本中，也可以用exec（）函数来执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(name.txt) as obj:</span><br><span class="line">    data=obj.read()</span><br><span class="line">exec(data)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出：<br>1000</p></blockquote><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>yield类似中断，一旦执行到yield就会返回变量当前的值，记住这个位置，然后下一次再继续执行yield后的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yield 变量</span><br></pre></td></tr></table></figure></p><h2 id="raise"><a href="#raise" class="headerlink" title="raise()"></a>raise()</h2><p>可以用来引发异常，可以用来传递异常,但是异常对象必须是error或exception的子类。<br>引发异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise Exception(&quot;抛出一个异常&quot;)</span><br></pre></td></tr></table></figure></p><h2 id="assert断言"><a href="#assert断言" class="headerlink" title="assert断言"></a>assert断言</h2><p>相当于一个 raise-if-not<br>即：assert后的布尔表达式为假时，抛出一个异常。</p><h2 id="assert-布尔表达式"><a href="#assert-布尔表达式" class="headerlink" title="assert 布尔表达式"></a>assert 布尔表达式</h2><p>表达式为假时，抛出异常<br>添加异常参数的语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 布尔表达式，&apos;一个字符串&apos;</span><br></pre></td></tr></table></figure></p><p>表达式为假时，抛出异常，并返回字符串。</p><h1 id="变量的容器们"><a href="#变量的容器们" class="headerlink" title="变量的容器们"></a>变量的容器们</h1><p>本笔记主要用来记录关于，列表，字典，文件等的特性<br><!--more--></p><h2 id="总注"><a href="#总注" class="headerlink" title="总注"></a>总注</h2><ol><li>列表只可以通过数字作为索引。（只能通过数来来获取列表中的元素）</li><li>字典可以通过任何东西找到其中的元素。（字典可以将一个事物和另一个事物关联）<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><strong> 专供有序排列的数据使用 </strong><h3 id="列表的创建"><a href="#列表的创建" class="headerlink" title="列表的创建"></a>列表的创建</h3>list=[‘python’,’lin’,1,2,3]<blockquote><p>也就是说，列表中的元素不需要一定同类型</p></blockquote></li></ol><h3 id="列表的操作包括：索引，切片，加，乘，检查成员"><a href="#列表的操作包括：索引，切片，加，乘，检查成员" class="headerlink" title="列表的操作包括：索引，切片，加，乘，检查成员"></a>列表的操作包括：索引，切片，加，乘，检查成员</h3><blockquote><p>索引（正向读取）—var=list[0]—–var=’python’。<br>索引（逆向读取）—var=list[-1]—-var=3—–(-1就是倒数第一个<br>索引(替换）—var=2。list[2]=var—-list2=[‘python’,’lin’,2,2,3]</p><p>切片—lis=list[0:3]—lis=[‘python’,’lin’,1]（包括头不包括尾）</p><p>加(也可以用list.extend（lis））—–lit=lis+list—-lit=<br>[‘python’,’lin’,1,’python’,’lin’,1,2,3]</p></blockquote><blockquote><p>乘—–lis2=list[2:5] lis3=lis2*2—-lis3=[1,2,3,1,2,3]</p></blockquote><h3 id="通过内置函数和方法，可以实现"><a href="#通过内置函数和方法，可以实现" class="headerlink" title="通过内置函数和方法，可以实现:"></a>通过内置函数和方法，可以实现:</h3><ul><li>比较（cmp(a,b)，</li><li>添加成员(list.append(obj)(obj可以是列表，也可以是成员)，</li><li>计算长度（len（a))，</li><li>返回最值(max(a);min(a)),</li><li>统计某成员出现次数（list.count(obj)),</li><li>反向排序（list.reverse())，</li><li>移除特定成员（list.remove（obj）），</li><li>移除特定位置成员（list.pop(-1)(-1为最后一项，0为第一个，1为第二个…)</li><li>找出特定对象的索引位置（list.index(obj))(找出obj的索引位置）</li><li>将对象插入特定位置（list.insert（index，obj））</li><li>对原列表进行排序（list.sort())</li></ul><h3 id="列表与字符串的转化"><a href="#列表与字符串的转化" class="headerlink" title="列表与字符串的转化"></a>列表与字符串的转化</h3><h4 id="列表-gt-字符串"><a href="#列表-gt-字符串" class="headerlink" title="列表 =&gt; 字符串"></a>列表 =&gt; 字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list=[&apos;lin&apos;,&apos;mu&apos;,&apos;shen&apos;]</span><br><span class="line">print &apos; &apos;.join(list)</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote></blockquote><p>lin mu shen</p><p>用字符串的形式显示并用空格分隔列表中的成员。</p><h4 id="字符串-gt-列表"><a href="#字符串-gt-列表" class="headerlink" title="字符串 =&gt; 列表"></a>字符串 =&gt; 列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var=&apos;lin mu shen&apos;</span><br><span class="line">list=var.split(&apos; &apos;)</span><br><span class="line">print list</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote></blockquote><p>[‘lin’,’mu’,’shen’]</p><p>以空格为每一个成员分隔点创建列表。</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>可以存储任意型变量（值可以是任意型数据，但键只可以是字符串，数字或元组。）<br><strong> 就像一个查询表 </strong></p><h3 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h3><p>键与值用冒号分割。每对键值之间用逗号分割。整个字典用花括号括起来。</p><blockquote><p>dic={‘abd’:1234,’lin’:’mushen’}</p></blockquote><h3 id="访问字典里的值："><a href="#访问字典里的值：" class="headerlink" title="访问字典里的值："></a>访问字典里的值：</h3><p>把相应的键放入[]中</p><blockquote><p>dic[‘abc’]</p></blockquote><h3 id="修改字典："><a href="#修改字典：" class="headerlink" title="修改字典："></a>修改字典：</h3><h4 id="增加："><a href="#增加：" class="headerlink" title="增加："></a>增加：</h4><p>dic[‘python’]=’func’</p><h4 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h4><p>dic[‘python’]=’very fun’</p><h4 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h4><ol><li>删除单一成员：<blockquote><p>del dic[‘python’]</p></blockquote></li><li>清空字典：<blockquote><p>dic.clear()</p></blockquote></li><li>删除字典：<blockquote><p>del dic</p></blockquote><h3 id="字典的特性："><a href="#字典的特性：" class="headerlink" title="字典的特性："></a>字典的特性：</h3></li><li>键不可以重复，一旦重复，后一个覆盖前一个</li><li>键不可以更改。（列表不可以当键）</li><li>字典内容是无序的。<h3 id="有关字典的函数和方法："><a href="#有关字典的函数和方法：" class="headerlink" title="有关字典的函数和方法："></a>有关字典的函数和方法：</h3><h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4></li><li>cmp(dic1,dic2)—–比较两个字典中的元素</li><li>len（dic）—–计算键（元素）的总数</li><li>str(dic)—–用字符串的形式输出字典</li><li>type(value)—-返回变量类型（value=dic时，返回字典）<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4></li><li>dec.clear()—-清空字典中内容</li><li>dic.copy()—–返回一个字典的浅复制（浅复制：只复制一级目录，二级的不复制（例如值是一个列表，则只复制列表名，列表中内容不复制）<blockquote><p>与直接赋值（dic1=dic的区别：dic1只是对dic中的对象进行了引用，如果dic对象发生改变，则dic1也改变，而复制不会）</p></blockquote></li><li>dic.get(key,default=value)—-返回指定键的值，如果键不存在，则返回default的值</li><li>dic.setdefault(key,default=value)—-返回指定键值，若键不存在则将value添加为该键的值</li><li>dic.has_key(key)—–判断键是否在字典中，若在，返回Ture，不在返回False</li><li>dic.items()—–返回列表形式的可遍历的元组数组（将一组键与值当作一个元组，所有元组当作一个列表）</li><li>dic.keys()—–以列表返回一个字典中所有的键。</li><li>dic.values()—以列表返回一个字典中所有的值</li><li>dic.update(dic2)—将dic2的键值更新到dic中</li><li>dic.popitem()—-随机返回并删除字典中的一对键值</li><li>dic.pop(‘key’，value)—-返回并删除指定键对应的值，若键值不存在，返回value。</li><li>dic.fromkeys(seq,value)—-以序列（列表等）中的元素做键，value为所有键的值。</li></ol><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>总注：</p><ol><li>数据类型是不允许改变的</li></ol><h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>True</li><li>False</li><li>None</li><li>strings</li><li>numbers</li><li>floats</li><li>lists</li></ul><h2 id="True-False和None"><a href="#True-False和None" class="headerlink" title="True,False和None"></a>True,False和None</h2><p>都是布尔值</p><h2 id="strings（字符串）"><a href="#strings（字符串）" class="headerlink" title="strings（字符串）"></a>strings（字符串）</h2><ol><li><p>创建字符串,使用单引号或双引号创建字符串,python中单个字符也作为字符串</p><blockquote><p>如：value=’strings’</p></blockquote></li><li><p>访问字符串中断值</p><blockquote><p>如：let=value[1]—-t<br>   lets=value[1:5]—–trin（包括头但不包括尾）</p></blockquote></li><li><p>字符串的更新</p><blockquote><p>如：valuess=value[:4]+lins——strlins(从冒号后面的是更新启始位，相当于添加字符串的0位）</p></blockquote></li></ol><h2 id="numbers（数字）"><a href="#numbers（数字）" class="headerlink" title="numbers（数字）"></a>numbers（数字）</h2><p>该数据类型用于存储数字<br>python支持四种不同的数据类型</p><ol><li>整型（int)—-正数或负数，不带有小数点<blockquote><p>如： var=10  var=-100</p></blockquote></li><li>长整型（long int）—-无限大小的整数，末尾带有大写或小写的L<blockquote><p>如： var=11112222L</p></blockquote></li><li>浮点型（floating point real values）—-由整数部分和小数部分组成，也可以使用科学记数法<blockquote><p>如：flo=15.20 flo=32.3+e18</p></blockquote></li><li>复数：由实部和虚部组成<blockquote><p>如： fus=a+bj fus=complex(a,b)</p></blockquote></li></ol><h2 id="lists-列表）"><a href="#lists-列表）" class="headerlink" title="lists(列表）"></a>lists(列表）</h2><p>列表是较为常见的数据结构<br>列表中每一个元素都有一个特定的索引（每一个元素分配一个数字）</p><h3 id="列表的创建-1"><a href="#列表的创建-1" class="headerlink" title="列表的创建"></a>列表的创建</h3><p>list=[‘python’,’lin’,1,2,3]</p><blockquote><p>也就是说，列表中的元素不需要一定同类型</p></blockquote><h3 id="列表的操作包括：索引，切片，加，乘，检查成员-1"><a href="#列表的操作包括：索引，切片，加，乘，检查成员-1" class="headerlink" title="列表的操作包括：索引，切片，加，乘，检查成员"></a>列表的操作包括：索引，切片，加，乘，检查成员</h3><blockquote><p>索引（正向读取）—var=list[0]—–var=’python’。<br>索引（逆向读取）—var=list[-1]—-var=3—–(-1就是倒数第一个<br>索引(替换）—var=2。list[2]=var—-list2=[‘python’,’lin’,2,2,3]</p><p>切片—lis=list[0:3]—lis=[‘python’,’lin’,1]（包括头不包括尾）</p><p>加(也可以用list.extend（lis））—–lit=lis+list—-lit=<br>[‘python’,’lin’,1,’python’,’lin’,1,2,3]</p></blockquote><blockquote><p>乘—–lis2=list[2:5] lis3=lis2*2—-lis3=[1,2,3,1,2,3]</p></blockquote><h3 id="通过内置函数和方法，可以实现-1"><a href="#通过内置函数和方法，可以实现-1" class="headerlink" title="通过内置函数和方法，可以实现:"></a>通过内置函数和方法，可以实现:</h3><ul><li>比较（cmp(a,b)，</li><li>添加成员(list.append(obj)(obj可以是列表，也可以是成员)，</li><li>计算长度（len（a))，</li><li>返回最值(max(a);min(a)),</li><li>统计某成员出现次数（list.count(obj)),</li><li>反向排序（list.reverse())，</li><li>移除特定成员（list.remove（obj）），</li><li>移除特定位置成员（list.pop(-1)(-1为最后一项，0为第一个，1为第二个…)</li><li>找出特定对象的索引位置（list.index(obj))(找出obj的索引位置）</li><li>将对象插入特定位置（list.insert（index，obj））</li><li>对原列表进行排序（list.sort())</li></ul><h3 id="列表与字符串的转化-1"><a href="#列表与字符串的转化-1" class="headerlink" title="列表与字符串的转化"></a>列表与字符串的转化</h3><h4 id="列表-gt-字符串-1"><a href="#列表-gt-字符串-1" class="headerlink" title="列表 =&gt; 字符串"></a>列表 =&gt; 字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list=[&apos;lin&apos;,&apos;mu&apos;,&apos;shen&apos;]</span><br><span class="line">print &apos; &apos;.join(list)</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote></blockquote><p>lin mu shen</p><p>用字符串的形式显示并用空格分隔列表中的成员。</p><h4 id="字符串-gt-列表-1"><a href="#字符串-gt-列表-1" class="headerlink" title="字符串 =&gt; 列表"></a>字符串 =&gt; 列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var=&apos;lin mu shen&apos;</span><br><span class="line">list=var.split(&apos; &apos;)</span><br><span class="line">print list</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote></blockquote><p>[‘lin’,’mu’,’shen’]</p><p>以空格为每一个成员分隔点创建列表。</p><h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>只需要复制\征服蟒蛇\projects\skeleton中所有内容然后将其粘贴到projecs中的项目文件中。</li><li>将其中所有NAME的文件都改为新项目的名字。</li><li>删除所有.pyc文件</li><li>在原NAME文件下创建新的项目py文件</li><li>根据需要，更改原NAME_tests.py（测试脚本）文件</li></ol><h2 id="作者的建议"><a href="#作者的建议" class="headerlink" title="作者的建议"></a>作者的建议</h2><ol><li>测试脚本要放在tests/目录下，且命名必须符合NAME_tests.py的规则。</li><li>为每一个模块写一个测试。</li><li>测试用例尽可能易懂又易写，但要尽量保持整洁。</li><li>别太把测试当回事。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了更方便的记笔记，我搭建了这个博客&lt;br&gt;
    
    </summary>
    
      <category term="python学习" scheme="http://linmushen.com/categories/python-study/"/>
    
    
  </entry>
  
</feed>
