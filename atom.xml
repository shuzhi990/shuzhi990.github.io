<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林木深的个人博客</title>
  
  <subtitle>热爱技术，痴迷技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linmushen.com/"/>
  <updated>2019-11-26T11:56:05.954Z</updated>
  <id>http://linmushen.com/</id>
  
  <author>
    <name>林木深</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>模拟电子技术</title>
    <link href="http://linmushen.com/2019/11/26/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"/>
    <id>http://linmushen.com/2019/11/26/模拟电子技术/</id>
    <published>2019-11-26T11:51:47.000Z</published>
    <updated>2019-11-26T11:56:05.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="放大电路的频率响应"><a href="#放大电路的频率响应" class="headerlink" title="放大电路的频率响应"></a>放大电路的频率响应</h1><h2 id="频率响应的概念"><a href="#频率响应的概念" class="headerlink" title="频率响应的概念"></a>频率响应的概念</h2><p>当放大电路输入不同频率的正弦波信号时，电路的放大倍数将有所不同，而成为频率的函数。这种关系称为<strong>放大电路的频率响应</strong>。</p><h3 id="幅频特性和相频特性"><a href="#幅频特性和相频特性" class="headerlink" title="幅频特性和相频特性"></a>幅频特性和相频特性</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;放大电路的频率响应&quot;&gt;&lt;a href=&quot;#放大电路的频率响应&quot; class=&quot;headerlink&quot; title=&quot;放大电路的频率响应&quot;&gt;&lt;/a&gt;放大电路的频率响应&lt;/h1&gt;&lt;h2 id=&quot;频率响应的概念&quot;&gt;&lt;a href=&quot;#频率响应的概念&quot; class=&quot;he
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码阅读</title>
    <link href="http://linmushen.com/2019/11/19/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://linmushen.com/2019/11/19/代码阅读/</id>
    <published>2019-11-19T15:18:12.000Z</published>
    <updated>2019-11-25T16:33:13.005Z</updated>
    
    <content type="html"><![CDATA[<p>阅读别人的代码</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//滤波函数</span><br><span class="line">void filter()</span><br><span class="line">&#123;</span><br><span class="line">    int ii,jj;</span><br><span class="line">    int a,b,c,d,e,g,h,f;</span><br><span class="line">    for(ii=58;ii&gt;1;ii--)</span><br><span class="line">    &#123;</span><br><span class="line">        for(jj=1;jj&lt;79;jj++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = img[(ii-1)*80+jj-1];</span><br><span class="line">            b = img[(ii-1)*80+jj];</span><br><span class="line">            c = img[(ii-1)*80+jj+1];  </span><br><span class="line">            d = img[(ii)*80+jj-1];  </span><br><span class="line">            e = img[(ii)*80+jj+1];  </span><br><span class="line">            f = img[(ii+1)*80+jj-1]; </span><br><span class="line">            g = img[(ii+1)*80+jj]; </span><br><span class="line">            h = img[(ii+1)*80+jj+1];</span><br><span class="line">            if(a+b+c+d+e+f+g+h+img[ii*80+jj] &gt;=5)</span><br><span class="line">                img[ii*80+jj] = 1;</span><br><span class="line">            else</span><br><span class="line">                img[ii*80+jj] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//透视变换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perspective_conversion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">// float high=0,distence=0;</span></span><br><span class="line">  <span class="keyword">int</span> ii,jj,iii,jjj;</span><br><span class="line">    <span class="keyword">for</span>(ii=<span class="number">58</span>;ii&gt;<span class="number">1</span>;ii--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(jj=<span class="number">1</span>;jj&lt;<span class="number">79</span>;jj++)</span><br><span class="line">        &#123;</span><br><span class="line">          iii=(ii*<span class="number">40</span>)/<span class="built_in">sqrt</span>(<span class="number">3</span>*high*high+<span class="number">3</span>*jjj*jjj);</span><br><span class="line">          jjj=(<span class="number">30</span>*jjj/high<span class="number">-30</span>*high/distence)/(<span class="number">1.73</span>*(<span class="number">1</span>+jjj/distence));</span><br><span class="line">          img[ii*<span class="number">80</span>+jj]=img[iii*<span class="number">80</span>+jjj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//补中线策略</span></span><br><span class="line"><span class="comment">/***十字中缺补线算法****/</span>               <span class="comment">//方法二，求出中间斜率 只补中线</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crossAddlines</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">  i_=<span class="number">0</span>;l_s_flag=<span class="number">0</span>;l_e_flag=<span class="number">0</span>;r_s_flag=<span class="number">0</span>;r_e_flag=<span class="number">0</span>;lcrossOK=<span class="number">0</span>;rcrossOK=<span class="number">0</span>;LcrossingOK=<span class="number">0</span>;RcrossingOK=<span class="number">0</span>; <span class="comment">//标志量</span></span><br><span class="line">   l_slop=<span class="number">0</span>;r_slop=<span class="number">0</span>;<span class="comment">//斜率   </span></span><br><span class="line"><span class="comment">//准备进十字</span></span><br><span class="line">  <span class="keyword">if</span>(car_situation==cross)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">//十字左线起始`终点寻找</span></span><br><span class="line">    <span class="keyword">for</span>(i_=<span class="number">59</span>;i_&gt;=<span class="number">10</span>;i_--)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(l_s_flag!=<span class="number">0</span>&amp;&amp;LMR[<span class="number">0</span>][i_]==<span class="number">-11</span>&amp;&amp;LMR[<span class="number">0</span>][i_<span class="number">-2</span>]!=<span class="number">-11</span>&amp;&amp;LMR[<span class="number">0</span>][i_<span class="number">-2</span>]&gt;=LMR[<span class="number">0</span>][l_s_flag])</span><br><span class="line">      &#123;</span><br><span class="line">        l_e_flag = i_<span class="number">-2</span>;</span><br><span class="line">        lcrossOK = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(LMR[<span class="number">0</span>][i_]==<span class="number">-11</span>&amp;&amp;i_&gt;=<span class="number">57</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">if</span>(LMR[<span class="number">0</span>][i_]==<span class="number">-11</span>&amp;&amp;LMR[<span class="number">0</span>][i_+<span class="number">2</span>]!=<span class="number">-11</span>&amp;&amp;!l_s_flag)</span><br><span class="line">      &#123;</span><br><span class="line">        l_s_flag = i_+<span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">//十字右线起始`终点寻找</span></span><br><span class="line">    <span class="keyword">for</span>(i_=<span class="number">59</span>;i_&gt;=<span class="number">10</span>;i_--)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(r_s_flag!=<span class="number">0</span>&amp;&amp;LMR[<span class="number">2</span>][i_]==<span class="number">-11</span>&amp;&amp;LMR[<span class="number">2</span>][i_<span class="number">-2</span>]!=<span class="number">-11</span>&amp;&amp;LMR[<span class="number">2</span>][i_<span class="number">-2</span>]&lt;=LMR[<span class="number">2</span>][r_s_flag]) </span><br><span class="line">     &#123;</span><br><span class="line">      r_e_flag = i_<span class="number">-2</span>;</span><br><span class="line">      rcrossOK = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(LMR[<span class="number">2</span>][i_]==<span class="number">-11</span>&amp;&amp;i_&gt;=<span class="number">57</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">if</span>(LMR[<span class="number">2</span>][i_]==<span class="number">-11</span>&amp;&amp;LMR[<span class="number">2</span>][i_+<span class="number">2</span>]!=<span class="number">-11</span>&amp;&amp;!r_s_flag)</span><br><span class="line">      &#123;</span><br><span class="line">        r_s_flag = i_+<span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(LMR[<span class="number">2</span>][i_]==<span class="number">-11</span>) r_lastestEnd= i_;              <span class="comment">//记录最近缺块当前检测临时最大值</span></span><br><span class="line">      <span class="keyword">if</span>(r_lastestEnd-i_&gt;<span class="number">2</span>) <span class="comment">//滤波</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(LMR[<span class="number">2</span>][i_]!=<span class="number">-11</span>) </span><br><span class="line">          &#123;</span><br><span class="line">            r_e_flag = i_++;</span><br><span class="line">            rcrossOK = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(LMR[<span class="number">2</span>][i_]!=<span class="number">-11</span>) </span><br><span class="line">          &#123;</span><br><span class="line">            r_e_flag = i_++;</span><br><span class="line">            rcrossOK = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">         &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">    l_s_flag = l_s_flag&gt;r_s_flag?l_s_flag:r_s_flag;</span><br><span class="line">    l_e_flag = l_e_flag&gt;r_e_flag?l_e_flag:r_e_flag;</span><br><span class="line"><span class="comment">//中线线性处理</span></span><br><span class="line">    <span class="keyword">int</span> trans;</span><br><span class="line">    <span class="keyword">if</span>(lcrossOK&amp;&amp;rcrossOK)</span><br><span class="line">    &#123;</span><br><span class="line">      l_slop = <span class="number">1</span>/(<span class="keyword">float</span>)(((<span class="keyword">float</span>)(l_s_flag-l_e_flag))/((<span class="keyword">float</span>)(LMR[<span class="number">1</span>][l_e_flag]-LMR[<span class="number">1</span>][l_s_flag])));</span><br><span class="line">      trans = l_s_flag;</span><br><span class="line">      <span class="keyword">while</span>(trans--&gt;l_e_flag&amp;&amp;<span class="built_in">abs</span>(l_slop)&lt;=<span class="number">1.2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        LMR[<span class="number">1</span>][trans] = LMRlimit(LMR[<span class="number">1</span>][l_s_flag] + l_slop*(l_s_flag-trans));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在十字内</span></span><br><span class="line">  <span class="keyword">if</span>(car_situation==crossing)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//十字左线起始`终点寻找</span></span><br><span class="line">    <span class="keyword">for</span>(i_=<span class="number">57</span>;i_&gt;=<span class="number">10</span>;i_--)       <span class="comment">//终点</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(!LcrossingOK&amp;&amp;i_&gt;=<span class="number">10</span>&amp;&amp;l_s_flag&amp;&amp;LMR[<span class="number">0</span>][i_<span class="number">-2</span>]!=<span class="number">-11</span>&amp;&amp;LMR[<span class="number">0</span>][i_<span class="number">-3</span>]!=<span class="number">-11</span>&amp;&amp;LMR[<span class="number">0</span>][i_<span class="number">-4</span>]!=<span class="number">-11</span>&amp;&amp;LMR[<span class="number">0</span>][i_<span class="number">-5</span>]!=<span class="number">-11</span>&amp;&amp;LMR[<span class="number">0</span>][i_<span class="number">-5</span>]&gt;=LMR[<span class="number">0</span>][l_s_flag])</span><br><span class="line">      &#123;</span><br><span class="line">         l_e_flag = i_<span class="number">-5</span>;</span><br><span class="line">         LcrossingOK = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span>(LMR[<span class="number">0</span>][i_]==<span class="number">-11</span>&amp;&amp;LMR[<span class="number">0</span>][i_<span class="number">-2</span>]!=<span class="number">-11</span>&amp;&amp;!l_s_flag) <span class="comment">//起点</span></span><br><span class="line">      &#123;</span><br><span class="line">        l_s_flag = i_<span class="number">-2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//十字右线起始`终点寻找    </span></span><br><span class="line">    <span class="keyword">for</span>(i_=<span class="number">57</span>;i_&gt;=<span class="number">10</span>;i_--)<span class="comment">//终点</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(!RcrossingOK&amp;&amp;i_&gt;=<span class="number">10</span>&amp;&amp;r_s_flag&amp;&amp;LMR[<span class="number">2</span>][i_<span class="number">-2</span>]!=<span class="number">-11</span>&amp;&amp;LMR[<span class="number">2</span>][i_<span class="number">-3</span>]!=<span class="number">-11</span>&amp;&amp;LMR[<span class="number">2</span>][i_<span class="number">-4</span>]!=<span class="number">-11</span>&amp;&amp;LMR[<span class="number">2</span>][i_<span class="number">-5</span>]!=<span class="number">-11</span>&amp;&amp;LMR[<span class="number">2</span>][i_<span class="number">-5</span>]&lt;=LMR[<span class="number">2</span>][r_s_flag])</span><br><span class="line">      &#123;</span><br><span class="line">         r_e_flag = i_<span class="number">-5</span>;</span><br><span class="line">         RcrossingOK = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(LMR[<span class="number">2</span>][i_]==<span class="number">-11</span>&amp;&amp;LMR[<span class="number">2</span>][i_<span class="number">-2</span>]!=<span class="number">-11</span>&amp;&amp;!r_s_flag) <span class="comment">//起点</span></span><br><span class="line">      &#123;</span><br><span class="line">        r_s_flag = i_<span class="number">-2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    l_s_flag = l_s_flag&gt;r_s_flag?r_s_flag:l_s_flag;</span><br><span class="line">    l_e_flag = l_e_flag&gt;r_e_flag?r_e_flag:l_e_flag;</span><br><span class="line">    <span class="comment">//中线线性处理</span></span><br><span class="line">    <span class="keyword">int</span> trans;</span><br><span class="line">    <span class="keyword">if</span>(LcrossingOK&amp;&amp;RcrossingOK)</span><br><span class="line">    &#123;</span><br><span class="line">      l_slop = <span class="number">1</span>/(<span class="keyword">float</span>)(((<span class="keyword">float</span>)(l_s_flag-l_e_flag))/((<span class="keyword">float</span>)(LMR[<span class="number">1</span>][l_e_flag]-LMR[<span class="number">1</span>][l_s_flag])));</span><br><span class="line">      trans = l_s_flag;</span><br><span class="line">      <span class="keyword">while</span>(trans++&lt;=<span class="number">57</span>&amp;&amp;<span class="built_in">abs</span>(l_slop)&lt;=<span class="number">1.2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        LMR[<span class="number">1</span>][trans] = LMRlimit(LMR[<span class="number">1</span>][l_s_flag] - l_slop*(trans-l_s_flag));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看这个他妈巨复杂的巡线函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Search0</span><span class="params">()</span><span class="comment">//从底部往上搜线</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> i,j,research=<span class="number">0</span>,k;   <span class="comment">//research逐行搜线时置位，防止重复重新搜线</span></span><br><span class="line">    L_spill=<span class="number">0</span>,R_spill=<span class="number">0</span>,L_R_spill=<span class="number">0</span>;    <span class="comment">//巡线丢失参数</span></span><br><span class="line">  island_count_l=<span class="number">0</span>;island_count_r=<span class="number">0</span>;       <span class="comment">//清环岛检测标志位</span></span><br><span class="line">  interrupt_flag=<span class="number">40</span>;           interrupt_flagrun=<span class="number">0</span>;        <span class="comment">//清断路标志量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> L_OK=<span class="number">0</span>,R_OK=<span class="number">0</span>;           <span class="comment">//边线单次检测完成标志位</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> maxvuale=<span class="number">0</span>,lastmaxvuale=<span class="number">0</span>;</span><br><span class="line">  uint8 *start;</span><br><span class="line">  L_R_spill=<span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  lope = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  cross_count=<span class="number">0</span>;  <span class="comment">//十字检测叠加量</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">60</span>;i++)  <span class="comment">//清空数组</span></span><br><span class="line">  &#123;</span><br><span class="line">    LMR[<span class="number">0</span>][i]=<span class="number">0</span>; </span><br><span class="line">    LMR[<span class="number">1</span>][i]=<span class="number">0</span>; </span><br><span class="line">    LMR[<span class="number">2</span>][i]=<span class="number">0</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  Blackago=<span class="number">0</span>;</span><br><span class="line">  blackline=<span class="number">0</span>;</span><br><span class="line">  whiteline=<span class="number">0</span>;</span><br><span class="line">  whitelist=<span class="number">0</span>;</span><br><span class="line">   whiteago=<span class="number">0</span>;</span><br><span class="line">   white=<span class="number">0</span>;</span><br><span class="line">  white_ago=<span class="number">60</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/***已阅读1****/</span></span><br><span class="line">  <span class="comment">/*****我觉得这一段代码的含义是记录黑点数最多的行*****/</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">59</span>;i&gt;<span class="number">0</span>;i--)     <span class="comment">//从行开始搜索</span></span><br><span class="line">  &#123; </span><br><span class="line">    Black=<span class="number">0</span>;            <span class="comment">//设置黑点数为0</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">80</span>;j&gt;<span class="number">0</span>;j--)   <span class="comment">//从该行的第一个点开始搜</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(img[i*<span class="number">80</span>+j] ==<span class="number">0</span>)       <span class="comment">//如果该点为0</span></span><br><span class="line">      Black++;                  <span class="comment">//黑点数加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Black&gt;Blackago)  <span class="comment">//如果黑点数大于这个BLCAKAGO(上一次保存的黑点数)</span></span><br><span class="line">    &#123;</span><br><span class="line">      Blackago=Black;   <span class="comment">//那么更新上一次保存的黑点数</span></span><br><span class="line">      blackline=i;      <span class="comment">//记录该行行数</span></span><br><span class="line">    &#125;                   <span class="comment">//结束本行的搜索，进入下一行的循环</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/****已阅读2***/</span></span><br><span class="line">  <span class="comment">/******这部分的作用时消除大于54行的影响（不知道有何意义）*****/</span></span><br><span class="line">  <span class="keyword">if</span>(blackline&gt;<span class="number">54</span>)      <span class="comment">//如果黑点最多的行为54~59行则</span></span><br><span class="line">    blackline=<span class="number">54</span>;       <span class="comment">//默认当作54行</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">59</span>;i&gt;blackline;i--) <span class="comment">// 从59行搜到黑点最多的行                 //从第59行开始搜左线</span></span><br><span class="line">  &#123;</span><br><span class="line">    start=&amp;(img[i*<span class="number">80</span>]);         <span class="comment">//行的初始地址   </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i!=<span class="number">59</span>&amp;&amp;(LMR[<span class="number">0</span>][i+<span class="number">1</span>]&gt;<span class="number">2</span>))  <span class="comment">// 第五十九行特殊处理，如果为59行不做；LMR是啥还不知道          </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(LMR[<span class="number">0</span>][i+<span class="number">1</span>]&lt;<span class="number">77</span>)        <span class="comment">//不知道该数组有何意义</span></span><br><span class="line">       <span class="keyword">for</span>(j=LMR[<span class="number">0</span>][i+<span class="number">1</span>]<span class="number">-3</span>;j&lt;(LMR[<span class="number">0</span>][i+<span class="number">1</span>]+<span class="number">3</span>);j++)<span class="comment">//搜LMR[0][I+1]前后三个点</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">if</span>((*(start+j)!=<span class="number">0</span>)&amp;&amp;(*(start+j<span class="number">-1</span>)==<span class="number">0</span>)) <span class="comment">//*(start+j)为img数组的第j个</span></span><br><span class="line">                <span class="comment">//如果img的第j为白而第j-1个为黑（发生跳变）</span></span><br><span class="line"><span class="comment">//11.22晚上读到了这里。           </span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">//LMR[0][i]=j-1;</span></span><br><span class="line">              LMR[<span class="number">0</span>][i]=j; <span class="comment">//找到一个跳变点就认为搜到线了</span></span><br><span class="line">              L_OK = <span class="number">1</span>;    <span class="comment">//检测到左黑线，标志</span></span><br><span class="line">              L_Success++;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**********从中间向两边搜*******/</span></span><br><span class="line">    <span class="comment">//else</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!L_OK)<span class="comment">//只要有一边没有检测到则进入弯道判断区                     </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">40</span>;j&gt;<span class="number">1</span>;j--)  <span class="comment">//从中间往两边搜线</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//if((*(start+j)!=0)&amp;&amp;(*(start+j-1)==0))</span></span><br><span class="line">            <span class="keyword">if</span>((*(start+j)!=<span class="number">0</span>)&amp;&amp;(*(start+j<span class="number">-1</span>)==<span class="number">0</span>)&amp;&amp;(L_OK==<span class="number">0</span>))    <span class="comment">//由黑变白(找左边线)</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">//LMR[0][i]=j-1;</span></span><br><span class="line">              LMR[<span class="number">0</span>][i]=j;</span><br><span class="line">              L_OK = <span class="number">1</span>;        <span class="comment">//检测到左黑线，标志</span></span><br><span class="line">              L_Lose++;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                  <span class="comment">//重复以上方法寻右线</span></span><br><span class="line">   <span class="keyword">if</span>(i!=<span class="number">59</span>&amp;&amp;(LMR[<span class="number">2</span>][i+<span class="number">1</span>]&lt;<span class="number">77</span>)&amp;&amp;LMR[<span class="number">2</span>][i+<span class="number">1</span>]&gt;<span class="number">2</span>) <span class="comment">//上一行同时搜到边线了             (第一次先跳过 i!=59 不满足)</span></span><br><span class="line">    &#123;</span><br><span class="line">          <span class="comment">//防止上一组数组越界，影响当前判断</span></span><br><span class="line">       <span class="keyword">for</span>(j=LMR[<span class="number">2</span>][i+<span class="number">1</span>]<span class="number">-3</span>;j&lt;(LMR[<span class="number">2</span>][i+<span class="number">1</span>]+<span class="number">3</span>);j++)   <span class="comment">//因为上次同时搜到边线了，故这一行的边线从上一行边线的附近搜   (右边线)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>((*(start+j)==<span class="number">0</span>)&amp;&amp;(*(start+j<span class="number">-1</span>)!=<span class="number">0</span>)) <span class="comment">//由白变黑</span></span><br><span class="line">        &#123; </span><br><span class="line">          <span class="comment">////LMR[2][i]=j-1;</span></span><br><span class="line">           LMR[<span class="number">2</span>][i]=j; <span class="comment">//找到一个跳变点就认为搜到线了</span></span><br><span class="line">           R_OK = <span class="number">1</span>;    <span class="comment">//检测到右黑线，标志</span></span><br><span class="line">           R_Success++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="comment">//只要有一边没有检测到则进入弯道判断区             </span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(j=<span class="number">39</span>;j&gt;=<span class="number">0</span>;j--)  <span class="comment">//从中间往两边搜线</span></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">if</span>((*(start+<span class="number">79</span>-j)==<span class="number">0</span>)&amp;&amp;(*(start+<span class="number">79</span>-j<span class="number">-1</span>)!=<span class="number">0</span>))  <span class="comment">//由白变黑  (找右边线)</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">////LMR[2][i]=19-j-1;</span></span><br><span class="line">            LMR[<span class="number">2</span>][i]=<span class="number">79</span>-j;</span><br><span class="line">            R_OK = <span class="number">1</span>;         <span class="comment">//检测到右黑线，标志</span></span><br><span class="line">            R_Lose++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">if</span>(!R_OK) R_spill++;      <span class="comment">//左线溢出参数叠加</span></span><br><span class="line">    <span class="keyword">if</span>(!L_OK) L_spill++;      <span class="comment">//右线溢出参数叠加</span></span><br><span class="line"><span class="comment">/********************************一行搜线完成*****************************************/</span></span><br><span class="line"> <span class="keyword">if</span>(L_OK&amp;&amp;R_OK)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span>(status==<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(i&gt;=<span class="number">20</span>)</span><br><span class="line">   &#123;</span><br><span class="line">   interrupt_flagrun=(<span class="keyword">int</span>)(LMR[<span class="number">2</span>][i]-LMR[<span class="number">0</span>][i]);</span><br><span class="line">   <span class="keyword">if</span>(interrupt_flagrun&lt;interrupt_flag)</span><br><span class="line">   &#123;</span><br><span class="line">   interrupt_flag=interrupt_flagrun;</span><br><span class="line">      whiteline=i;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(status==<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(i&gt;=<span class="number">20</span>)</span><br><span class="line">   &#123;</span><br><span class="line">   interrupt_flagrun=(<span class="keyword">int</span>)(LMR[<span class="number">2</span>][i]-LMR[<span class="number">0</span>][i]);</span><br><span class="line">   <span class="keyword">if</span>(interrupt_flagrun&lt;interrupt_flag)</span><br><span class="line">   &#123;</span><br><span class="line">   interrupt_flag=interrupt_flagrun;</span><br><span class="line">    whiteline=i;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   whitelist++;<span class="comment">//</span></span><br><span class="line">  whiteago=i;</span><br><span class="line">  <span class="keyword">if</span>(white&lt;whiteago)</span><br><span class="line">  &#123;white=whiteago;&#125;</span><br><span class="line">     white_ago=i;</span><br><span class="line">  <span class="keyword">if</span>(white_ago&gt;ac_white)</span><br><span class="line">  &#123;ac_white=white_ago;&#125;</span><br><span class="line">    LMR[<span class="number">1</span>][i]=(<span class="keyword">int</span>)((LMR[<span class="number">2</span>][i]+LMR[<span class="number">0</span>][i])/<span class="number">2</span>);  <span class="comment">//中心线   (取中值) </span></span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span>(!R_OK&amp;&amp;L_OK)  <span class="comment">//右边没有检测到</span></span><br><span class="line">   &#123;</span><br><span class="line">      whiteago=i;</span><br><span class="line">  <span class="keyword">if</span>(white&lt;whiteago)</span><br><span class="line">  &#123;white=whiteago;&#125;</span><br><span class="line">  <span class="keyword">if</span>(i&gt;<span class="number">40</span>)</span><br><span class="line">       island_count_l++;<span class="comment">//</span></span><br><span class="line">     LMR[<span class="number">2</span>][i] = <span class="number">-11</span>;</span><br><span class="line">     LMR[<span class="number">1</span>][i] = Limit(LMR[<span class="number">0</span>][i]+<span class="number">39</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   <span class="keyword">if</span>(R_OK&amp;&amp;!L_OK)<span class="comment">//左边没有检测到</span></span><br><span class="line">   &#123;</span><br><span class="line">      whiteago=i;</span><br><span class="line">  <span class="keyword">if</span>(white&lt;whiteago)</span><br><span class="line">  &#123;white=whiteago;&#125;</span><br><span class="line">  <span class="keyword">if</span>(i&gt;<span class="number">40</span>)</span><br><span class="line">       island_count_r++;<span class="comment">//</span></span><br><span class="line">     LMR[<span class="number">0</span>][i] = <span class="number">-11</span>;</span><br><span class="line">     LMR[<span class="number">1</span>][i] =Limit(LMR[<span class="number">2</span>][i]<span class="number">-39</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   <span class="keyword">if</span>(!L_OK&amp;&amp;!R_OK) <span class="comment">//都没有检测到</span></span><br><span class="line">   &#123; </span><br><span class="line">     <span class="keyword">if</span>(status == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     LMR[<span class="number">1</span>][i]=<span class="number">39</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(status == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     LMR[<span class="number">1</span>][i]=<span class="number">37</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     L_R_spill++;<span class="comment">//</span></span><br><span class="line">     LMR[<span class="number">2</span>][i]=<span class="number">-11</span>;</span><br><span class="line">     LMR[<span class="number">0</span>][i]=<span class="number">-11</span>;</span><br><span class="line">     <span class="keyword">if</span>(i&lt;=<span class="number">55</span>&amp;&amp;i&gt;=<span class="number">30</span>) </span><br><span class="line">     cross_count++;    <span class="comment">//十字检测叠加量</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(ac_white==(white_ago-i))</span><br><span class="line">       &#123; white_line=i;&#125;</span><br><span class="line"> <span class="keyword">if</span>(white&lt;<span class="number">10</span>)</span><br><span class="line">   white=<span class="number">10</span>;</span><br><span class="line">    R_OK=<span class="number">0</span>;L_OK=<span class="number">0</span>;                   <span class="comment">//检测标志位重新置位</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(LMR[<span class="number">1</span>][i]-LMR[<span class="number">1</span>][i+<span class="number">1</span>])&gt;=<span class="number">6</span>&amp;&amp;!research)</span><br><span class="line">    &#123;</span><br><span class="line">      HLine_filter(start);    <span class="comment">//滤噪点，再重新搜本行线，最大重复次数为1</span></span><br><span class="line">      research=<span class="number">1</span>;</span><br><span class="line">      i++;             <span class="comment">//出现噪点重新搜线</span></span><br><span class="line">    &#125;<span class="keyword">else</span> research=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(*(start+<span class="number">39</span>)==<span class="number">0</span>&amp;&amp;*(start+<span class="number">40</span>)==<span class="number">0</span>&amp;&amp;*(start+<span class="number">38</span>)==<span class="number">0</span>&amp;&amp;!maxvuale) &#123;maxvuale=i;&#125;  <span class="comment">//达到拐弯极点，跳出寻线</span></span><br><span class="line">    <span class="keyword">if</span>(maxvuale&gt;<span class="number">55</span>) maxvuale=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LLine_filter(LMR[<span class="number">1</span>]); <span class="comment">//巡线完成，进行中线滤波</span></span><br><span class="line"><span class="comment">/*********************************************************************************/</span> </span><br><span class="line">  <span class="comment">//赛道类型判断</span></span><br><span class="line">    twoso=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">80</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>((img[<span class="number">58</span>*<span class="number">80</span>+i]==<span class="number">0</span>)&amp;&amp;(img[<span class="number">80</span>*<span class="number">59</span>+i]==<span class="number">0</span>)&amp;&amp;(img[<span class="number">80</span>*<span class="number">60</span>+i]==<span class="number">0</span>))twoso++;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//十字</span></span><br><span class="line">   <span class="keyword">if</span>(whitetjj&gt;=<span class="number">43</span>&amp;&amp;L_R_spill&gt;=<span class="number">18</span>&amp;&amp;cross_count&gt;=<span class="number">20</span>)  &#123;car_situation=cross;island_flag_l=<span class="number">0</span>;&#125;</span><br><span class="line">   <span class="keyword">if</span>(car_situation==cross)             <span class="comment">//十字法二</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span>(LMR[<span class="number">0</span>][<span class="number">57</span>]==<span class="number">-11</span>&amp;&amp;LMR[<span class="number">0</span>][<span class="number">58</span>]==<span class="number">-11</span>&amp;&amp;LMR[<span class="number">2</span>][<span class="number">57</span>]==<span class="number">-11</span>&amp;&amp;LMR[<span class="number">2</span>][<span class="number">59</span>]==<span class="number">-11</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        car_situation=crossing;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">if</span>(car_situation==cross)</span><br><span class="line">     &#123;</span><br><span class="line">        crossAddlines();</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(car_situation==crossing)</span><br><span class="line">     &#123;</span><br><span class="line">       crossAddlines();</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     rcrossOK=<span class="number">0</span>;</span><br><span class="line">     lcrossOK=<span class="number">0</span>;</span><br><span class="line">     LcrossingOK=<span class="number">0</span>;</span><br><span class="line">     RcrossingOK=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(LMR[<span class="number">1</span>][<span class="number">55</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">50</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">45</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">40</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">35</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">52</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">48</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">42</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">40</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">32</span>]&lt;<span class="number">39</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      lope = (<span class="keyword">float</span>)((LMR[<span class="number">1</span>][<span class="number">40</span>] - LMR[<span class="number">1</span>][<span class="number">55</span>]))/<span class="number">16.0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">     <span class="keyword">if</span>(LMR[<span class="number">1</span>][<span class="number">55</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">50</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">45</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">40</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">35</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">38</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">52</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">48</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">43</span>]&lt;<span class="number">39</span>||LMR[<span class="number">1</span>][<span class="number">39</span>]&lt;<span class="number">39</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       lope = (<span class="keyword">float</span>)((LMR[<span class="number">1</span>][<span class="number">40</span>] - LMR[<span class="number">1</span>][<span class="number">55</span>]))/<span class="number">16.0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">/********/</span><span class="comment">/////*************************************************************/</span></span><br><span class="line">        <span class="comment">//中线均值计算</span></span><br><span class="line">     qulv1=qulv0;</span><br><span class="line">     qulv0=qulv;</span><br><span class="line">     coun=<span class="number">0</span>;</span><br><span class="line">     qulv=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//    if(car_situation == bend)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line">  <span class="comment">//1中线，曲率计算起始行，结束行</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//   else qulv = 0;</span></span><br><span class="line">   <span class="comment">//if(abs(qulv*coefficient&gt;=13)) qulv=10/coefficient;</span></span><br><span class="line">     <span class="keyword">if</span>(status == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//      if(blackline&lt;20)</span></span><br><span class="line"><span class="comment">//      &#123;</span></span><br><span class="line"><span class="comment">//      for(i=50;i&gt;blackline;i--)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//      coun+=LMR[1][i];</span></span><br><span class="line"><span class="comment">//    &#125; </span></span><br><span class="line"><span class="comment">//     coun/=(50-blackline);</span></span><br><span class="line"><span class="comment">//      &#125;</span></span><br><span class="line"><span class="comment">//        else</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">58</span>;i&gt;blackline;i--)</span><br><span class="line">    &#123;</span><br><span class="line">      coun+=LMR[<span class="number">1</span>][i];</span><br><span class="line">    &#125; </span><br><span class="line">     coun/=(<span class="number">58</span>-blackline);</span><br><span class="line">   <span class="comment">//    &#125;</span></span><br><span class="line">     <span class="keyword">if</span>((island_count_r-island_count_l)&gt;<span class="number">10</span>) </span><br><span class="line">       &#123; </span><br><span class="line">        qulv=(get_qulv(<span class="number">2</span>,<span class="number">57</span>,(<span class="number">38</span>+(blackline+<span class="number">2</span>)/<span class="number">3</span>))+get_qulv(<span class="number">2</span>,(<span class="number">37</span>+(blackline+<span class="number">2</span>)/<span class="number">3</span>),(<span class="number">19</span>+<span class="number">2</span>*(blackline+<span class="number">2</span>)/<span class="number">3</span>))+get_qulv(<span class="number">2</span>,(<span class="number">18</span>+<span class="number">2</span>*(blackline+<span class="number">2</span>)/<span class="number">3</span>),blackline+<span class="number">2</span>))/<span class="number">3</span>;</span><br><span class="line">       <span class="keyword">if</span>(qulv&gt;<span class="number">0</span>)</span><br><span class="line">         qulv=-qulv;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="keyword">if</span>((island_count_l-island_count_r)&gt;<span class="number">10</span>) </span><br><span class="line">     &#123;</span><br><span class="line">        qulv=(get_qulv(<span class="number">0</span>,<span class="number">57</span>,(<span class="number">38</span>+(blackline+<span class="number">2</span>)/<span class="number">3</span>))+get_qulv(<span class="number">0</span>,(<span class="number">37</span>+(blackline+<span class="number">2</span>)/<span class="number">3</span>),(<span class="number">19</span>+<span class="number">2</span>*(blackline+<span class="number">2</span>)/<span class="number">3</span>))+get_qulv(<span class="number">0</span>,(<span class="number">18</span>+<span class="number">2</span>*(blackline+<span class="number">2</span>)/<span class="number">3</span>),blackline+<span class="number">2</span>))/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(qulv&lt;<span class="number">0</span>)</span><br><span class="line">         qulv=-qulv;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(status == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>((white-blackline)&gt;=<span class="number">5</span>)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">for</span>(i=white;i&gt;blackline;i--)</span><br><span class="line">       &#123;</span><br><span class="line">        coun+=LMR[<span class="number">1</span>][i];</span><br><span class="line">       &#125; </span><br><span class="line">         coun/=(white-blackline);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(blackline&lt;<span class="number">30</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=blackline+<span class="number">40</span>;i&gt;blackline+<span class="number">10</span>;i--)</span><br><span class="line">       &#123;</span><br><span class="line">        coun+=LMR[<span class="number">1</span>][i];</span><br><span class="line">       &#125; </span><br><span class="line">         coun/=<span class="number">30</span>;</span><br><span class="line">         <span class="keyword">if</span>((island_count_r-island_count_l)&gt;<span class="number">10</span>) </span><br><span class="line">       &#123; </span><br><span class="line">         qulv=(get_qulv(<span class="number">2</span>,(blackline+<span class="number">30</span>),(blackline+<span class="number">20</span>))+get_qulv(<span class="number">2</span>,(blackline+<span class="number">21</span>),(blackline+<span class="number">10</span>))+get_qulv(<span class="number">2</span>,(blackline+<span class="number">11</span>),blackline))/<span class="number">3</span>;</span><br><span class="line">       <span class="keyword">if</span>(qulv&gt;<span class="number">0</span>)</span><br><span class="line">         qulv=-qulv;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="keyword">if</span>((island_count_l-island_count_r)&gt;<span class="number">10</span>) </span><br><span class="line">     &#123;</span><br><span class="line">         qulv=(get_qulv(<span class="number">0</span>,(blackline+<span class="number">30</span>),(blackline+<span class="number">20</span>))+get_qulv(<span class="number">0</span>,(blackline+<span class="number">21</span>),(blackline+<span class="number">10</span>))+get_qulv(<span class="number">0</span>,(blackline+<span class="number">11</span>),blackline))/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(qulv&lt;<span class="number">0</span>)</span><br><span class="line">         qulv=-qulv;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">55</span>;i&gt;blackline;i--)</span><br><span class="line">       &#123;</span><br><span class="line">        coun+=LMR[<span class="number">1</span>][i];</span><br><span class="line">       &#125; </span><br><span class="line">         coun/=(<span class="number">55</span>-blackline);</span><br><span class="line">        <span class="keyword">if</span>((island_count_r-island_count_l)&gt;<span class="number">10</span>) </span><br><span class="line">       &#123; </span><br><span class="line">        qulv=(get_qulv(<span class="number">2</span>,<span class="number">54</span>,(<span class="number">36</span>+(blackline+<span class="number">2</span>)/<span class="number">3</span>))+get_qulv(<span class="number">2</span>,(<span class="number">37</span>+(blackline+<span class="number">2</span>)/<span class="number">3</span>),(<span class="number">18</span>+<span class="number">2</span>*(blackline+<span class="number">2</span>)/<span class="number">3</span>))+get_qulv(<span class="number">2</span>,(<span class="number">19</span>+<span class="number">2</span>*(blackline+<span class="number">2</span>)/<span class="number">3</span>),blackline+<span class="number">2</span>))/<span class="number">3</span>;</span><br><span class="line">       <span class="keyword">if</span>(qulv&gt;<span class="number">0</span>)</span><br><span class="line">         qulv=-qulv;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="keyword">if</span>((island_count_l-island_count_r)&gt;<span class="number">10</span>) </span><br><span class="line">     &#123;</span><br><span class="line">        qulv=(get_qulv(<span class="number">0</span>,<span class="number">54</span>,(<span class="number">36</span>+(blackline+<span class="number">2</span>)/<span class="number">3</span>))+get_qulv(<span class="number">0</span>,(<span class="number">37</span>+(blackline+<span class="number">2</span>)/<span class="number">3</span>),(<span class="number">18</span>+<span class="number">2</span>*(blackline+<span class="number">2</span>)/<span class="number">3</span>))+get_qulv(<span class="number">0</span>,(<span class="number">19</span>+<span class="number">2</span>*(blackline+<span class="number">2</span>)/<span class="number">3</span>),blackline+<span class="number">2</span>))/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(qulv&lt;<span class="number">0</span>)</span><br><span class="line">         qulv=-qulv;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> qulv=<span class="number">0.6</span>*qulv+<span class="number">0.3</span>*qulv0+<span class="number">0.1</span>*qulv1;</span><br><span class="line">     coun+=qulv*coefficient;</span><br><span class="line">   <span class="keyword">if</span>(((coun&lt;=<span class="number">36</span>)||(coun&gt;=<span class="number">46</span>))) </span><br><span class="line">    &#123;</span><br><span class="line">       car_sit=<span class="number">1</span>;</span><br><span class="line">       car_situation = bend;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">     &#123;</span><br><span class="line">        car_sit=<span class="number">0</span>;</span><br><span class="line">      car_situation = stra;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">if</span>(status == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    derror[<span class="number">1</span>]=derror[<span class="number">0</span>];</span><br><span class="line">     derror[<span class="number">0</span>] =coun<span class="number">-40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(status ==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    derror[<span class="number">1</span>]=derror[<span class="number">0</span>];</span><br><span class="line">     derror[<span class="number">0</span>] =coun<span class="number">-38</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/***************************************************************************/</span></span><br><span class="line">  spillover = L_spill - R_spill ;</span><br><span class="line">  L_Lose=<span class="number">0</span>,L_Success=<span class="number">0</span>;             <span class="comment">//巡线效率评估参数重置  </span></span><br><span class="line">  R_Lose=<span class="number">0</span>,R_Success=<span class="number">0</span>;</span><br><span class="line">  L_spill=<span class="number">0</span>;R_spill=<span class="number">0</span>;           <span class="comment">//溢出参数重置</span></span><br><span class="line">   lastmaxvuale = maxvuale;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读别人的代码&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>玩具</title>
    <link href="http://linmushen.com/2019/10/26/%E7%8E%A9%E5%85%B7/"/>
    <id>http://linmushen.com/2019/10/26/玩具/</id>
    <published>2019-10-26T05:13:12.000Z</published>
    <updated>2019-10-26T14:23:48.117Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下平时写的小玩具。<br><a id="more"></a></p><h1 id="python输出心形字符"><a href="#python输出心形字符" class="headerlink" title="python输出心形字符"></a>python输出心形字符</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>python2中print不是函数，不能设置参数，调用from <strong>future</strong> import print_function来设置参数。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">import time</span><br><span class="line">import sys</span><br><span class="line">from sympy import var,plot_implicit</span><br><span class="line">var(&apos;x y &apos;)</span><br><span class="line"></span><br><span class="line">#plot_implicit((x**2+(-y)**2-1)**3+x**2*(-y)**3)#心形曲线</span><br><span class="line"></span><br><span class="line">l2 = []</span><br><span class="line"></span><br><span class="line">for y in range(15,-15,-1):</span><br><span class="line">        </span><br><span class="line">l3=[]</span><br><span class="line">for x in range(-30,30):</span><br><span class="line">                </span><br><span class="line">l3.append((&apos; WJX I LOVE&apos;[(x-y)%11]if((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3&lt;=0 else&apos; &apos;))</span><br><span class="line"></span><br><span class="line">l2.append(&apos;&apos;.join(l3))</span><br><span class="line"></span><br><span class="line">l1 = &apos;\n&apos;.join(l2)</span><br><span class="line"></span><br><span class="line">for i in l1:</span><br><span class="line">        time.sleep(0.005)</span><br><span class="line">        print (i,end=&apos;&apos;)#取消换行和自动空格</span><br><span class="line"></span><br><span class="line">print (&quot;LMS&amp;&amp;WJX&quot;)</span><br></pre></td></tr></table></figure></code></pre><h1 id="写个小爬虫"><a href="#写个小爬虫" class="headerlink" title="写个小爬虫"></a>写个小爬虫</h1><p>看到一个教程贴里教怎么爬取一个网站的卫星图，但是我觉得直接照着打没意思，不如自己学习写一下。<br>决定早点睡觉，有时间再搞吧。2019/10/26 22:23:42 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下平时写的小玩具。&lt;br&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://linmushen.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>K60学习笔记</title>
    <link href="http://linmushen.com/2019/09/18/K60%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/09/18/K60学习笔记/</id>
    <published>2019-09-18T05:22:43.000Z</published>
    <updated>2019-11-06T07:32:56.888Z</updated>
    
    <content type="html"><![CDATA[<p>好好学习K60单片机<br><a id="more"></a></p><h1 id="C语言基础补充"><a href="#C语言基础补充" class="headerlink" title="C语言基础补充"></a>C语言基础补充</h1><p>今天用一维数组做函数参数时发现自己C语言指针、数组实在是不精，因此好好复习巩固一下！2019/10/19 0:57:34<br>一维数组做函数参数时，编译器将他解析成一个指向其首元素的指针。</p><h2 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h2><ol><li>形式参数为指针。</li><li>形式参数为带有数组大小的数组。</li><li>形式参数为不带数组有大小的数组。</li></ol><p>害，好像没啥复杂的。不写了2019/10/19 17:51:57 </p><h1 id="文件夹规定"><a href="#文件夹规定" class="headerlink" title="文件夹规定"></a>文件夹规定</h1><h2 id="一级文件夹"><a href="#一级文件夹" class="headerlink" title="一级文件夹"></a>一级文件夹</h2><p>App—–用户程序<br>Board—开发板驱动程序<br>Chip—-K60芯片驱动程序<br>Lib—–库代码<br>Prj—–工程文件</p><h2 id="二级文件夹"><a href="#二级文件夹" class="headerlink" title="二级文件夹"></a>二级文件夹</h2><p>Inc—–程序头文件<br>src—–驱动程序<br>IAR—–工程文件</p><h2 id="三级文件夹"><a href="#三级文件夹" class="headerlink" title="三级文件夹"></a>三级文件夹</h2><p>IAR—–与IAR编译器相关的头文件<br>kinetis-与MCU相关的头文件<br>IAR—–IAR驱动程序和编译器相关驱动程序</p><h1 id="正式开篇"><a href="#正式开篇" class="headerlink" title="正式开篇"></a>正式开篇</h1><p>经过几天的准备工作（环境搭建，编译设置）后，今天正式开始学习K60单片机。<br>山外的板子LED0~LED3对应PTB20~PTB23</p><h1 id="关于库"><a href="#关于库" class="headerlink" title="关于库"></a>关于库</h1><p>常用库文件说明：<br>MK60_conf.h—配置文件，包含printf函数，波特率设置，频率设置。<br>MK60_conf.c—断言函数，printf底层接口，默认中断等函数。<br>MK60_it.c—–中断函数库。<br>PORT_cfg.h—-管脚服用配置文件，用于配置默认复用管脚。</p><h2 id="快速复用管脚"><a href="#快速复用管脚" class="headerlink" title="快速复用管脚"></a>快速复用管脚</h2><p>只需在PORT_cfg.h中按照注释里写着的可选范围进行修改这里的宏定义，就能更改默认的复用管脚，不需要修改函数。 </p><h2 id="中断函数的编写"><a href="#中断函数的编写" class="headerlink" title="中断函数的编写"></a>中断函数的编写</h2><p>set_vector_handler(中断号的枚举类型,中断服务函数)<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_vector_handler(PORTD_VECTORn,PORTD_IRQHandler)</span><br><span class="line">//第一个参数是port模块的D端口的中断，第二个参数是编写好的中断服务函数</span><br><span class="line">//第一个参数详见C:\Users\树枝990\Desktop\K60单片机\fire_Kinetis\Chip\inc</span><br></pre></td></tr></table></figure></p><h2 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h2><p>跳过，暂时看不懂。</p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h1 id="K60-UD版的使用"><a href="#K60-UD版的使用" class="headerlink" title="K60 UD版的使用"></a>K60 UD版的使用</h1><h2 id="下载方式"><a href="#下载方式" class="headerlink" title="下载方式"></a>下载方式</h2><ol><li>使用下载器</li><li>使用USB线下载<blockquote><p>详细说明第二种方法：插入USB线的同时按住独立按键，然后按一下复位键，进入USB DOWNLOAD模式，最后将生成的BIN文件拷贝到这个文件夹中。完成时，LED0和LED2闪烁。按复位键即可运行程序。</p></blockquote></li></ol><h1 id="编码器的使用"><a href="#编码器的使用" class="headerlink" title="编码器的使用"></a>编码器的使用</h1><p>使用的是逐飞的mini1024z编码器，具有两相输出（步进脉冲，旋转方向）。<br>理解：应该是通过测量一段时间内的脉冲数来计算速度，通过测量旋转方向相的输出来判断方向。</p><h1 id="模块学习"><a href="#模块学习" class="headerlink" title="模块学习"></a>模块学习</h1><h2 id="中断函数的编写-1"><a href="#中断函数的编写-1" class="headerlink" title="中断函数的编写"></a>中断函数的编写</h2><p>中断里修改的参数，需要用volatile来修饰</p><h3 id="函数列表"><a href="#函数列表" class="headerlink" title="函数列表"></a>函数列表</h3><p>set_vector_handler(HardFault_VECTORn,HardFault_Handler)：设定中断函数入口<br>参数设置：第一个参数 在\CHIP\INC\COMMON.h中查找；第二个参数为编写的中断函数</p><p>enable_irq(X_IRQn):中断使能函数<br>参数设置：为上一个函数的前一部分+_IRQn</p><h2 id="PORT模块（管脚管理模块）"><a href="#PORT模块（管脚管理模块）" class="headerlink" title="PORT模块（管脚管理模块）"></a>PORT模块（管脚管理模块）</h2><p>PORT模块：K60的PORT模块是引脚控制和中断模块，控制每个管脚复用到各个不同的内部模块（GPIO,UART,I2C），配置每一个管脚的各种属性（上拉下拉电阻、无源滤波）。</p><h3 id="PORT库的使用"><a href="#PORT库的使用" class="headerlink" title="PORT库的使用"></a>PORT库的使用</h3><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>下降沿触发：就是说，当端口输入为低电平触发。<br>上拉电阻：当输入不确定信号时，上拉为高电平。</p><h3 id="形参命名列表"><a href="#形参命名列表" class="headerlink" title="形参命名列表"></a>形参命名列表</h3><p>PTXn_e:管脚编号。例:PTB0<br>PTX_e:端口模块。例:PTA<br>PTn_e:管脚位号。例:PT1</p><h3 id="函数列表-1"><a href="#函数列表-1" class="headerlink" title="函数列表"></a>函数列表</h3><p>port_init(PTXn_e,cfg)：PORT初始化（配置复用功能）</p><blockquote><p>例:port_init(PTA8,IRQ_RISING|PF|ALT1|PULLUP);  配置了复用功能ALT1。<br>port_init_NoALT(PTXn_e,cfg)：PORT初始化（不改变复用功能）<br>例:port_init_NoALT(PTA8,IRQ_RISING|PF|PULLUP)</p></blockquote><h3 id="宏定义列表"><a href="#宏定义列表" class="headerlink" title="宏定义列表"></a>宏定义列表</h3><p>PORT_FUNC(X,num,func)：中断函数中的宏定义，简化代码量。（据说可以不用清楚位标志）</p><blockquote><p>x:为端口号（A~E）。<br>num:为管脚位号（1~31）。<br>func:相应的中断处理函数。<br>例:PORT_FUNC(A,6,key)</p><blockquote><p>其中key为中断中需要执行的用户任务。</p></blockquote></blockquote><h3 id="实例使用"><a href="#实例使用" class="headerlink" title="实例使用"></a>实例使用</h3><p>使用独立按键控制两个小灯的亮灭。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">void ledb();</span><br><span class="line">void PORTD_IRQHandler(void);        //PORTD端口中断服务函数</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    led_init(LED0);                         //初始化LED0</span><br><span class="line">    led_init(LED1);                         //初始化LED1</span><br><span class="line">    set_vector_handler(PORTD_VECTORn ,PORTD_IRQHandler);    //设置PORTD的中断复位函数为 PORTD_IRQHandler</span><br><span class="line">    enable_irq (PORTD_IRQn);                                //使能PORTD中断</span><br><span class="line">    port_init(PTD7, ALT1 | IRQ_FALLING | PULLUP );          //初始化 PTD7 管脚，复用功能为GPIO ，下降沿触发中断，上拉电阻</span><br><span class="line">    led(LED0, LED_ON);</span><br><span class="line">    led(LED1, LED_ON);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ledb()</span><br><span class="line">&#123;</span><br><span class="line">    led_turn(LED0);                  //LED0 亮</span><br><span class="line">    led_turn(LED1);                  //LED1翻转</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PORTD_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">    PORT_FUNC(D,7,ledb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意要调整模式为DZ_10 DEBUG模式。<br>还要修改内存地址：linker–&gt;config—&gt;edit—&gt;Vector Table中改为(32<em>1024)<br>linker–&gt;config—&gt;edit—&gt;Memory Regions中第一行改为(32</em>1024)，(512*1024)</p><h2 id="GPIO模块"><a href="#GPIO模块" class="headerlink" title="GPIO模块"></a>GPIO模块</h2><h3 id="形参命名列表-1"><a href="#形参命名列表-1" class="headerlink" title="形参命名列表"></a>形参命名列表</h3><p>PTXn_e：管教编号 例如：PTA0<br>GPIO_CFG：输入输出配置 例如：GPI(输入方向),GPO(输出方向)<br>data：数据</p><h3 id="函数列表-2"><a href="#函数列表-2" class="headerlink" title="函数列表"></a>函数列表</h3><p>gpio_init:初始化GPIO<br>gpio_ddr:设置引脚数据方向<br>gpio_set:设置引脚状态<br>gpio_turn:反转引脚状态<br>gpio_get:获取引脚IO状态</p><h3 id="宏定义列表-1"><a href="#宏定义列表-1" class="headerlink" title="宏定义列表"></a>宏定义列表</h3><p>PTxn_OUT:设置引脚输出电平  例如：PTA0_OUT<br>PTxn_IN:读取引脚输入电平   例如：PTA0_IN<br>PTxn_DDR:设置引脚输入输出方向      例如：PTA0_DDR<br>PTxn_T:反转引脚状态   例如：PTA0_T</p><p><strong>B表示字节</strong><br>PTx_Bn:设置8位引脚<br>例如：<br>PTx_B0：代表对7~0位进行操作。<br>PTx_B1：代表对15~8位进行操作。<br>PTx_B2：代表对23~16位进行操作。<br>PTx_B3：代表对31~24位进行操作。<br>Bn结合gpio基本宏定义进行使用，实现对8位的同时操作</p><ol><li>PTx_Bn_OUT</li><li>PTx_Bn_IN</li><li>PTx_Bn_DDR</li><li>PTx_Bn_T</li></ol><p><strong> W表示字</strong><br>PTx_Wn:PTx_Bn:设置16位引脚<br>例如：<br>PTx_W0：代表对15~0位进行操作。<br>PTx_W1：代表对31~16位进行操作。<br>Wn结合gpio基本宏定义进行使用，实现对16位的同时操作</p><ol><li>PTx_Wn_OUT</li><li>PTx_Wn_IN</li><li>PTx_Wn_DDR</li><li>PTx_Wn_T</li></ol><p>GPIO_SET:设置引脚状态<br>GPIO_TURN:反转引脚状态<br>GPIO_GET:获取引脚IO状态<br>GPIO_DDR:输入输出状态</p><p>NBIT类型：传递参数：NBIT:位数,PTxn:最低位的管脚号,data:电平状态（二进制转为十进制表示）<br>GPIO_SET_NBIT:设置n位引脚状态<br>GPIO_T_NBIT:反转n位引脚状态<br>GPIO_GET_NBIT:获取n位引脚IO状态<br>GPIO_DDR_NBIT:设置n位输入输出状态</p><h3 id="函数的实际使用"><a href="#函数的实际使用" class="headerlink" title="函数的实际使用"></a>函数的实际使用</h3><ol><li>gpio_init(PTXn_e,GPIO_CFG,uint8 data)：初始化GPIO口，设置输入输出方向，输出数据（仅在输出模式下有效）</li><li>gpio_ddr(PTXn_e,GPIO_CFG)：设置引脚数据方向(GPIO_CFG的可选值为GPI,GPO)</li><li>gpio_set(PTXn_e,data)：设置引脚状态 例如：gpio_set(PTA8,1)  PTA8引脚输出1</li><li>gpio_turn(PTXn_e)：翻转IO口电平</li><li>gpio_get(PTXn_e)：读取引脚状态<h3 id="宏定义的实际使用"><a href="#宏定义的实际使用" class="headerlink" title="宏定义的实际使用"></a>宏定义的实际使用</h3>PTxn系列：将x换为A~E,n换为0~31<br>PTxn_OUT：参数为0，1；其中0代表输出高电平，1代表输出低电平。<br>PTxn_IN：读取电平输入。<br>PTxn_DDR：参数为0，1；其中0代表输入，1代表输出。<br>PTxn_T：参数为0，1；其中0代表保存当前电平状态，1代表翻转电平状态。</li></ol><p>PTx_Bn系列：将x换为A~E,n换为0~3。其余一样。<br>PTx_Wn系列：将x换为A~E,n换为0~1。其余一样。</p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><h4 id="gpio-init-和宏定义的使用"><a href="#gpio-init-和宏定义的使用" class="headerlink" title="gpio_init()和宏定义的使用"></a>gpio_init()和宏定义的使用</h4><p>效果：LED0与LED1闪烁。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gpio_init(PTB20,GPO,1);</span><br><span class="line">    gpio_init(PTB21,GPO,1);     //初始化两个led为灭。</span><br><span class="line">    </span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        PTB20_OUT=0;    //20输出低电平</span><br><span class="line">        PTB21_T=1;      //21输出翻转</span><br><span class="line">        </span><br><span class="line">        DELAY_MS(500);  //延时500ms</span><br><span class="line">        </span><br><span class="line">        PTB20_OUT=1;    //20输出高电平</span><br><span class="line">        PTB21_T=1;      //21再次翻转</span><br><span class="line">        </span><br><span class="line">        DELAY_MS(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="port与gpio结合使用"><a href="#port与gpio结合使用" class="headerlink" title="port与gpio结合使用"></a>port与gpio结合使用</h4><p>效果：按下独立按键时led0亮，弹起时熄灭。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//使用GPIO函数设置端口参数，使用port函数设置各种属性</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">   gpio_init(PTB20,GPO,1);      //初始化LED0为灭状态</span><br><span class="line">   gpio_init(PTD7,GPI,1);       //初始化按键端口为输入状态</span><br><span class="line">   port_init_NoALT(PTD7,PULLUP);//设置该端口为上拉电阻</span><br><span class="line">   </span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(PTD7_IN==1)          //案件弹起</span><br><span class="line">        &#123;</span><br><span class="line">          PTB20_OUT=1;          //LED0亮</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          PTB20_OUT=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="gpio-set-的使用"><a href="#gpio-set-的使用" class="headerlink" title="gpio_set()的使用"></a>gpio_set()的使用</h4><p>效果：LED0闪烁<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gpio_init(PTB20,GPO,1);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">       gpio_set(PTB20,0);</span><br><span class="line">       DELAY_MS(500);</span><br><span class="line">       gpio_set(PTB20,1);</span><br><span class="line">       DELAY_MS(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用NBIT进行并行设置"><a href="#使用NBIT进行并行设置" class="headerlink" title="使用NBIT进行并行设置"></a>使用NBIT进行并行设置</h4><p>效果：LED3和LED0一起闪烁，LED4和LED1一起闪烁。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//使用NBIT系列并行设置多个端口</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gpio_init(PTB20,GPO,1);</span><br><span class="line">    gpio_init(PTB21,GPO,1);</span><br><span class="line">    gpio_init(PTB22,GPO,1);</span><br><span class="line">    gpio_init(PTB23,GPO,1);     //初始化LED0~LED3为熄灭状态</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">       GPIO_SET_NBIT(4,PTB20,9);//同时设置由PTB20开始的四位的电平</span><br><span class="line">       DELAY_MS(500);</span><br><span class="line">       GPIO_SET_NBIT(4,PTB20,6);//同时设置为低电平</span><br><span class="line">       DELAY_MS(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="VCAN-LED模块"><a href="#VCAN-LED模块" class="headerlink" title="VCAN_LED模块"></a>VCAN_LED模块</h2><h3 id="形参变量列表"><a href="#形参变量列表" class="headerlink" title="形参变量列表"></a>形参变量列表</h3><ol><li>LEDn:led的号,取值：LED0,LED1,LED2,LED3,LED_MAX。</li><li>LED_status:led状态，取值：LED_ON,LED_OFF<h3 id="函数列表-3"><a href="#函数列表-3" class="headerlink" title="函数列表"></a>函数列表</h3>led_init():初始化LED。<br>led:设置LED状态。<br>led_turn:翻转LED状态。<h3 id="函数原型列表"><a href="#函数原型列表" class="headerlink" title="函数原型列表"></a>函数原型列表</h3>led_init(LED_e);    初始化led<br>led(LED_e,LED_status);    设置led亮灭<br>led_turn(led_e);    翻转led亮灭<h3 id="实际使用-1"><a href="#实际使用-1" class="headerlink" title="实际使用"></a>实际使用</h3>效果：使用LED系列函数实现闪烁 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    led_init(LED0);</span><br><span class="line">    led_init(LED1);     //初始化LED0和LED1</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">       led(LED0,LED_ON);</span><br><span class="line">       led_turn(LED1);</span><br><span class="line">       DELAY_MS(500);</span><br><span class="line">       led(LED0,LED_OFF);</span><br><span class="line">       led_turn(LED1);</span><br><span class="line">       DELAY_MS(500);   //两个led闪烁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="VCAN-KEY模块"><a href="#VCAN-KEY模块" class="headerlink" title="VCAN_KEY模块"></a>VCAN_KEY模块</h2><p>由于没有五轴按键暂时先不学。2019/10/5 16:06:02<br>新买的显示屏到了，上面带有五轴按键，开始学习。2019/10/17 19:09:29 </p><h3 id="形参列表"><a href="#形参列表" class="headerlink" title="形参列表"></a>形参列表</h3><p>KEY_e:按键号:KEY_U(上)，KEY_D(下)，KEY_L(左)，KEY_R(右)，KEY_START(开始)，KEY_STOP(停止)，KEY_A(取消)，KEY_B(选择，液晶屏上的中键)，KEY_MAX<br>KEY_STATUS_e:按键状态:KEY_DOWN(按键按下时对应电平),KEY_UP(按键弹起时对应电平),KEY_HOLD(长按按键)<br>KEY_MSG_t:按键消息结构体:包含上面两个</p><h3 id="函数原型列表-1"><a href="#函数原型列表-1" class="headerlink" title="函数原型列表"></a>函数原型列表</h3><p>key_init(KEY_e)</p><blockquote><p>功能说明：key初始化函数（若为KEY_MAX则初始化所有端口；否则只初始化对应端口）<br>调用例子：KEY_init(KEY_U)</p></blockquote><p>key_get(KEY_e):</p><blockquote><p>功能说明：检测key状态（无消抖）<br>调用例子： if(KEY_get(KEY_U)==KEY_DOWN)</p></blockquote><p>key_check(KEY_e):</p><blockquote><p>功能说明：检测key状态（有消抖）<br>调用例子：： if(KEY_check(KEY_U)==KEY_DOWN)</p></blockquote><p>get_key_msg(KEY_MSG_t):</p><blockquote><p>功能说明：获取按键消息，返回1为有按键消息，0为无按键消息。此函数用于定时按键扫描，需要把 key_IRQHandler函数放入定时中断函数里运行才可正常返回按键消息。<br>调用例子：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(get_key_msg(&amp;keymsg) == 1)   </span><br><span class="line">&#123; </span><br><span class="line">printf(&quot;\n 按下按键 KEY%d,类型为%d（0 为按下，1 为弹起，2 为长按）&quot;,keymsg.key,keymsg.status); //从结构体中获取信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>key_IRQHandler(void):需要定时扫描的中断服务函数（定时为10ms）</p><h3 id="实际使用-2"><a href="#实际使用-2" class="headerlink" title="实际使用"></a>实际使用</h3><h2 id="K60-FTM模块"><a href="#K60-FTM模块" class="headerlink" title="K60_FTM模块"></a>K60_FTM模块</h2><p>PWM库的使用</p><h3 id="形参变量列表-1"><a href="#形参变量列表-1" class="headerlink" title="形参变量列表"></a>形参变量列表</h3><p>FTMn_e:模块名（常用）<br>FTM_CHn_e:通道号（常用）<br>Freq:频率<br>Duty:通道占空比<br>FTM_Input_cfg:FTM输入捕捉配置（输入）<br>FTM_PS_e:分频因子（常用）<br><em>关于各个通道的端口引脚，可以查询app/inc/port_cfg.h文件</em></p><h3 id="函数原型列表-2"><a href="#函数原型列表-2" class="headerlink" title="函数原型列表"></a>函数原型列表</h3><h4 id="pwm系列函数"><a href="#pwm系列函数" class="headerlink" title="pwm系列函数"></a>pwm系列函数</h4><p>ftm_pwm_init(FTMn_e,FTM_CHn_e,uint32 freq,uint32 duty);</p><blockquote><p>功能说明：初始化FTM的PWM，设置频率(freq)和占空比(duty/freq*100%)<br>调用例子：ftm_pwm_init(FTM0,FTM_CH6,200,10);</p></blockquote><p>ftm_pwm_duty(FTMn_e,FTM_CHn_e,uint32 duty);</p><blockquote><p>功能说明：设置通道占空比(duty/freq*100%)<br>调用例子：ftm_pwm_duty(FTM0,FTM_CH6,10);</p></blockquote><p>ftm_pwm_freq(FTMn_e,uint32 freq);</p><blockquote><p>功能说明：设置FTM的频率，设置后需要重新调用ftm_pwm_duty()设置占空比。<br>调用例子：ftm_pwm_freq(FTM0,200);</p></blockquote><h4 id="输入捕捉系列函数"><a href="#输入捕捉系列函数" class="headerlink" title="输入捕捉系列函数"></a>输入捕捉系列函数</h4><p>ftm_input_init(FTMn_e,FTM_CHn_e,FTM_Input_cfg,FTM_PS_e);</p><blockquote><p>功能说明：输入捕捉初始化函数，设置通道，触发模式和分频系数<br>调用例子：ftm_input_init(FTM0,FTM_CH2,FTM_Rising,FTM_PS_2);<br>例子说明：设置FTM0_CH2为上升沿触发捕捉，二分频</p></blockquote><p>ftm_input_get(FTMn_e,FTM_CHn_e);</p><blockquote><p>功能说明：输入捕捉模式下，读取捕捉事件发生时计数器值（根据两次捕捉之间的差值可以判断周期频率）<br>调用例子：uint 16 data = ftm_input_get(FTM0,FTM_CH0)<br>例子说明：获取FTM0_CH0输入捕捉事件触发时的计数值</p></blockquote><p>ftm_input_clean(FTMn_e);</p><blockquote><p>功能说明：清空计数器的值，计数器重新开始计数。</p></blockquote><h4 id="正交解码系列函数"><a href="#正交解码系列函数" class="headerlink" title="正交解码系列函数"></a>正交解码系列函数</h4><p>ftm_quad_init(FTMn_e);</p><blockquote><p>功能说明：初始化FTM的正交解码功能<br>调用例子：ftm_quad_init(FTM1);</p></blockquote><p>ftm_quad_get(FTMn_e);</p><blockquote><p>功能说明：获取FTM正交解码的脉冲数（负数表示反方向）<br>调用例子：int16 count = ftm_quad_get(FTM1);</p></blockquote><p>ftm_quad_clean(FTMn_e);</p><blockquote><p>功能说明：清空FTM正交解码的脉冲数<br>调用例子：ftm_quad_clean(FTM1);</p></blockquote><h3 id="宏定义一个"><a href="#宏定义一个" class="headerlink" title="宏定义一个"></a>宏定义一个</h3><p>FTMn_PRECISON</p><blockquote><p>功能说明：定义占空比精度。100代表精度为1%；1000代表精度为0.1%。<br>调用例子：#define FTM0_PRECISON 100U</p></blockquote><h1 id="液晶屏的使用-（VCAN-LCD库）"><a href="#液晶屏的使用-（VCAN-LCD库）" class="headerlink" title="液晶屏的使用 （VCAN_LCD库）"></a>液晶屏的使用 （VCAN_LCD库）</h1><h2 id="液晶屏的选择配置"><a href="#液晶屏的选择配置" class="headerlink" title="液晶屏的选择配置"></a>液晶屏的选择配置</h2><p>修改在App/inc/MK60_conf.h中的“#define USE_LCD 要选择的型号”，具体型号为上两行中定义的型号。</p><h2 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h2><p>Color:字体颜色<br>bkColor:背景颜色<br>str:字符串地址<br>site:左上角坐标<br>num:数字<br>max_num_bit:最大的位数</p><h2 id="函数列表-4"><a href="#函数列表-4" class="headerlink" title="函数列表"></a>函数列表</h2><p> 首先定义左上角坐标：site = {3,5};<br>LCD_init():初始化LCD<br>LCD_str(Site_t site,uint8 *Str,uint16 Color,uint16 bkColor):显示字符串</p><blockquote><p>LCD_str(site,”字符串”,FCOLOUR,BCOLOUR);<br>LCD_num(Site_t site, uint32 num, uint16 Color, uint16 bkColor):显示数字<br>LCD_num_C(site, 数字, FCOLOUR , BCOLOUR);<br>LCD_num_BC(Site_t site, uint32 num, uint8 max_num_bit, uint16 Color, uint16 bkColor):显示数字（清空多余的位）</p></blockquote><h1 id="程序备份"><a href="#程序备份" class="headerlink" title="程序备份"></a>程序备份</h1><p>新建新的工程文件之前一定要重新设置内存启动位置为32k。</p><h2 id="驱动电机实验"><a href="#驱动电机实验" class="headerlink" title="驱动电机实验"></a>驱动电机实验</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//该程序可以实现电机的前转、后转和停止；还可以控制电机的转速。</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">#define FTM_PRECISON 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MOTOR1_FTM   FTM0</span><br><span class="line">#define MOTOR2_FTM   FTM1</span><br><span class="line"></span><br><span class="line">#define MOTOR1_PWM  FTM_CH6</span><br><span class="line">#define MOTOR2_PWM  FTM_CH0</span><br><span class="line"></span><br><span class="line">#define MOTOR1_PWM_IO  FTM0_CH6</span><br><span class="line">#define MOTOR2_PWM_IO  FTM1_CH0</span><br><span class="line"></span><br><span class="line">//引脚选择</span><br><span class="line">//D6做PWM1，A12做PWM2</span><br><span class="line">//D6（FTM0_CH6   PTD6）和A12（FTM1_CH0      PTA12）</span><br><span class="line"></span><br><span class="line">//三个动作子函数</span><br><span class="line">//前进---D6高电平，A12低电平</span><br><span class="line">//后退---D6低电平，A12高电平</span><br><span class="line">//停止---都输出高电平或低电平</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void go(uint8 gduty);</span><br><span class="line">void back(uint8 bduty);</span><br><span class="line">void stop();</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    uint8 i=20;</span><br><span class="line">    FTM_PWM_init(MOTOR1_FTM, MOTOR1_PWM,10*1000,100);      </span><br><span class="line">    FTM_PWM_init(MOTOR2_FTM, MOTOR2_PWM,10*1000,0);      //初始化两个PWM通道，设置初始PWM值</span><br><span class="line">    </span><br><span class="line">    while(1)</span><br><span class="line">    &#123; </span><br><span class="line">        /***变速部分</span><br><span class="line">        for(i=80;i&gt;=10;i=i-10)</span><br><span class="line">        &#123;</span><br><span class="line">            go(i);</span><br><span class="line">            DELAY_MS(500);</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==10)  </span><br><span class="line">         i=100;</span><br><span class="line">        ***/</span><br><span class="line">        back(i);</span><br><span class="line">        DELAY_MS(3000);</span><br><span class="line">        go(i);</span><br><span class="line">        DELAY_MS(3000);</span><br><span class="line">        stop();</span><br><span class="line">        DELAY_MS(5000);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void go(uint8 gduty)</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,gduty);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void back(uint8 bduty)</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,0);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,bduty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stop()</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,0);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="驱动舵机实验"><a href="#驱动舵机实验" class="headerlink" title="驱动舵机实验"></a>驱动舵机实验</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//该程序实现每按一次独立按键，舵机转一点。</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">//使用A10引脚，设置周期为20ms，其中0~180度对应0.5~2.5ms（即占空比为0.5/20~2.5/20）</span><br><span class="line">//精度设置为1000，0.5ms时即设置为25，2.5ms时即设置为125.</span><br><span class="line">//实现功能：每按一次按键，占空比+1，同时LED0亮一些</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    uint8 i=13; </span><br><span class="line"></span><br><span class="line">    FTM_PWM_init(FTM2,FTM_CH0,100,13);          //初始化FTM1_CH1通道，设置频率为50（周期20ms），占空比为75（舵机归中）</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    gpio_init(PTD7,GPI,1);</span><br><span class="line">    port_init_NoALT(PTD7,PULLUP);</span><br><span class="line">    </span><br><span class="line">    while(1)</span><br><span class="line">    &#123; </span><br><span class="line">        if(PTD7_IN==0)</span><br><span class="line">        &#123;</span><br><span class="line">            i=i+2;</span><br><span class="line">            if(i&gt;=25)</span><br><span class="line">                i=13;</span><br><span class="line">            if(i&lt;=0)</span><br><span class="line">                i=13;</span><br><span class="line">            </span><br><span class="line">            FTM_PWM_Duty(FTM2,FTM_CH0,i);</span><br><span class="line">            DELAY_MS(400);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="Uart通信实验"><a href="#Uart通信实验" class="headerlink" title="Uart通信实验"></a>Uart通信实验</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">//Uart通信实验，按一下按键，上位机显示CET-8</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  gpio_init(PTD7,GPI,1);</span><br><span class="line">  port_init_NoALT(PTD7,PULLUP);</span><br><span class="line">    </span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    if(PTD7_IN==0)</span><br><span class="line">        &#123;</span><br><span class="line">          printf(&quot;\nCET-8&quot;);</span><br><span class="line">          DELAY_MS(500);</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="编码器测速实验"><a href="#编码器测速实验" class="headerlink" title="编码器测速实验"></a>编码器测速实验</h2><p>在上位机软件中显示速度。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">//编码器篇：需要一个引脚判断一定时间内脉冲个数；另一个引脚通过判断高低电平判断方向</span><br><span class="line">//其中PTA8测量方向；PTD8测量脉冲个数，需要有一个中断服务函数</span><br><span class="line"></span><br><span class="line">int16 count();              //计算转数的函数</span><br><span class="line">void PORTD_IRQHandler();   //中断服务函数</span><br><span class="line">void PIT0_IRQHandler();    //定时器的中断服务函数</span><br><span class="line"></span><br><span class="line">volatile uint8 cnt=0;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    port_init(PTA8,ALT1|PULLUP);                         //初始化PTA8端口为GPIO功能，上升沿触发，上拉电阻</span><br><span class="line">    gpio_init(PTA8,GPI,1);                               //设置为输入模式</span><br><span class="line">    </span><br><span class="line">    port_init(PTD8,IRQ_EITHER|ALT1|PULLUP);              //初始化PTA8端口为GPIO功能，跳变沿触发，上拉电阻</span><br><span class="line">    set_vector_handler(PORTD_VECTORn,PORTD_IRQHandler);  //设置中断函数入口</span><br><span class="line">    enable_irq(PORTD_IRQn);                              //使能中断服务函数</span><br><span class="line">    </span><br><span class="line">    pit_init_ms(PIT0,500);                               //定时500ms    </span><br><span class="line">    set_vector_handler(PIT0_VECTORn,PIT0_IRQHandler);    //设置定时器的中断服务函数</span><br><span class="line">    enable_irq(PIT0_IRQn);                               //使能</span><br><span class="line">    </span><br><span class="line">    while(1);</span><br><span class="line">    </span><br><span class="line">             </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int16 count()</span><br><span class="line">&#123;</span><br><span class="line">    cnt++;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PORTD_IRQHandler()</span><br><span class="line">&#123;</span><br><span class="line">    PORT_FUNC(D,8,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PIT0_IRQHandler()</span><br><span class="line">&#123;</span><br><span class="line">    int16 val;</span><br><span class="line">    val = cnt;</span><br><span class="line">    cnt=0;</span><br><span class="line">    printf(&quot;\n脉冲数为%d&quot;,val);</span><br><span class="line">    </span><br><span class="line">    if(PTA8_IN==1)</span><br><span class="line">       printf(&quot;\n正向旋转&quot;);</span><br><span class="line">    else</span><br><span class="line">       printf(&quot;\n反向旋转&quot;);  </span><br><span class="line">    </span><br><span class="line">    PIT_Flag_Clear(PIT0);       //清中断标志位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="电机与编码器测速结合"><a href="#电机与编码器测速结合" class="headerlink" title="电机与编码器测速结合"></a>电机与编码器测速结合</h2><p>驱动电机转动并测速<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">#define FTM_PRECISON 100        //配置PWM精度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MOTOR1_FTM   FTM0</span><br><span class="line">#define MOTOR2_FTM   FTM1</span><br><span class="line"></span><br><span class="line">#define MOTOR1_PWM  FTM_CH6</span><br><span class="line">#define MOTOR2_PWM  FTM_CH0</span><br><span class="line"></span><br><span class="line">#define MOTOR1_PWM_IO  FTM0_CH6</span><br><span class="line">#define MOTOR2_PWM_IO  FTM1_CH0</span><br><span class="line"></span><br><span class="line">//引脚选择</span><br><span class="line">//D6做PWM1，A12做PWM2</span><br><span class="line">//D6（FTM0_CH6   PTD6）和A12（FTM1_CH0      PTA12）</span><br><span class="line">//PTA8测量方向；PTD8测量脉冲个数，需要有一个中断服务函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void go(uint8 gduty);</span><br><span class="line">void back(uint8 bduty);</span><br><span class="line">void stop();</span><br><span class="line"></span><br><span class="line">int16 count();              //计算转数的函数</span><br><span class="line">void PORTD_IRQHandler();   //中断服务函数</span><br><span class="line">void PIT0_IRQHandler();    //定时器的中断服务函数</span><br><span class="line"></span><br><span class="line">volatile uint8 cnt=0;      //全局变量</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    uint8 i=20;</span><br><span class="line">    FTM_PWM_init(MOTOR1_FTM, MOTOR1_PWM,10*1000,50);      </span><br><span class="line">    FTM_PWM_init(MOTOR2_FTM, MOTOR2_PWM,10*1000,0);      //初始化两个PWM通道，设置初始PWM值</span><br><span class="line">    </span><br><span class="line">    port_init(PTA8,ALT1|PULLUP);                         //初始化PTA8端口为GPIO功能，上升沿触发，上拉电阻</span><br><span class="line">    gpio_init(PTA8,GPI,1);                               //设置为输入模式</span><br><span class="line">    </span><br><span class="line">    port_init(PTD8,IRQ_EITHER|ALT1|PULLUP);              //初始化PTA8端口为GPIO功能，跳变沿触发，上拉电阻</span><br><span class="line">    set_vector_handler(PORTD_VECTORn,PORTD_IRQHandler);  //设置中断函数入口</span><br><span class="line">    enable_irq(PORTD_IRQn);                              //使能中断服务函数</span><br><span class="line">    </span><br><span class="line">    pit_init_ms(PIT0,1000);                          //定时1000ms    </span><br><span class="line">    set_vector_handler(PIT0_VECTORn,PIT0_IRQHandler);    //设置定时器的中断服务函数</span><br><span class="line">    enable_irq(PIT0_IRQn);                               //使能</span><br><span class="line">    </span><br><span class="line">    while(1)</span><br><span class="line">    &#123; </span><br><span class="line">     /* 变速部分</span><br><span class="line">        for(i=50;i&gt;=10;i=i-10)</span><br><span class="line">        &#123;</span><br><span class="line">            go(i);</span><br><span class="line">            DELAY_MS(500);</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==10)  </span><br><span class="line">            i=50;</span><br><span class="line">       */ </span><br><span class="line">      </span><br><span class="line">//正转反转和停止</span><br><span class="line">        back(i);</span><br><span class="line">        DELAY_MS(3000);</span><br><span class="line">        go(i);</span><br><span class="line">        DELAY_MS(3000);</span><br><span class="line">        stop();</span><br><span class="line">        DELAY_MS(5000);</span><br><span class="line">      </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void go(uint8 gduty)            //前进函数</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,gduty);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void back(uint8 bduty)          //后退函数</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,0);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,bduty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stop()                     //停止函数</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,0);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int16 count()                   //计数函数（计算每500ms产生脉冲数）</span><br><span class="line">&#123;</span><br><span class="line">    cnt++;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PORTD_IRQHandler()        //每当D8跳变（产生脉冲）调用该中断服务函数         </span><br><span class="line">&#123;</span><br><span class="line">    PORT_FUNC(D,8,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PIT0_IRQHandler()          //定时中断函数，每500ms调用一次</span><br><span class="line">&#123;</span><br><span class="line">    int16 val;</span><br><span class="line">    val = cnt;</span><br><span class="line">    cnt=0;</span><br><span class="line">    printf(&quot;\n脉冲数为%d&quot;,val);</span><br><span class="line">    </span><br><span class="line">    if(PTA8_IN==1)</span><br><span class="line">       printf(&quot;\n反向旋转&quot;);</span><br><span class="line">    else</span><br><span class="line">       printf(&quot;\n正向旋转&quot;);  </span><br><span class="line">    </span><br><span class="line">    PIT_Flag_Clear(PIT0);       //清中断标志位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="按键控制电机、舵机；同时向上位机传输速度"><a href="#按键控制电机、舵机；同时向上位机传输速度" class="headerlink" title="按键控制电机、舵机；同时向上位机传输速度"></a>按键控制电机、舵机；同时向上位机传输速度</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">//按键控制加速，减速，舵机转向;同时向上位机传输速度</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">//引脚一览</span><br><span class="line">//D10,D14,D11,D12,D13;分别对应：上，下，左，右，确定五个按键</span><br><span class="line">//电机驱动：D6做PWM1，A12做PWM2</span><br><span class="line">//编码器部分：PTA8测量方向；PTD8测量脉冲个数，需要有一个中断服务函数</span><br><span class="line">//舵机部分：使用A10引脚</span><br><span class="line"></span><br><span class="line">#define FTM_PRECISON 100        //配置PWM精度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MOTOR1_FTM   FTM0</span><br><span class="line">#define MOTOR2_FTM   FTM1</span><br><span class="line"></span><br><span class="line">#define MOTOR1_PWM  FTM_CH6</span><br><span class="line">#define MOTOR2_PWM  FTM_CH0</span><br><span class="line"></span><br><span class="line">#define MOTOR1_PWM_IO  FTM0_CH6</span><br><span class="line">#define MOTOR2_PWM_IO  FTM1_CH0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void lptmr_handler();   //定时中断函数</span><br><span class="line">void go(uint8 gduty);</span><br><span class="line">void back(uint8 bduty);</span><br><span class="line">void stop();</span><br><span class="line">int16 count();              //计算转数的函数</span><br><span class="line">void PORTD_IRQHandler();   //中断服务函数</span><br><span class="line">void PIT0_IRQHandler();    //定时器的中断服务函数</span><br><span class="line">void left(uint8 ljd);</span><br><span class="line">void right(uint8 rjd);</span><br><span class="line">void choose(uint8 xuan);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">volatile uint8 stas;    //用于确定哪一个按键被按下</span><br><span class="line">volatile uint8 i=20;    //初始速度 20</span><br><span class="line">volatile uint8 cnt=0;   //全局变量</span><br><span class="line">volatile uint8 jd=13;</span><br><span class="line">uint8 keyname[KEY_MAX]=&#123;1,2,3,4,5,6&#125;;     //分别对应上，下，左，右，确定 独立按键按键</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">KEY_MSG_t keymsg;       //调用按键信息结构体</span><br><span class="line"></span><br><span class="line">key_init(KEY_U);</span><br><span class="line">key_init(KEY_D);</span><br><span class="line">key_init(KEY_R);</span><br><span class="line">key_init(KEY_L);</span><br><span class="line">key_init(KEY_A);</span><br><span class="line">key_init(KEY_B);        //初始化所有按键</span><br><span class="line">lptmr_timing_ms(10);    //LPTMR定时10ms</span><br><span class="line">set_vector_handler(LPTMR_VECTORn,lptmr_handler);    //设置中断函数入口</span><br><span class="line">enable_irq(LPTMR_IRQn); //使能中断</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FTM_PWM_init(FTM2,FTM_CH0,100,13);          //初始化FTM1_CH1通道，设置频率为50（周期20ms），占空比为75（舵机归中）</span><br><span class="line"></span><br><span class="line">FTM_PWM_init(MOTOR1_FTM, MOTOR1_PWM,10*1000,50);      </span><br><span class="line">FTM_PWM_init(MOTOR2_FTM, MOTOR2_PWM,10*1000,0);      //初始化两个PWM通道，设置初始PWM值</span><br><span class="line">    </span><br><span class="line">port_init(PTA8,ALT1|PULLUP);                         //初始化PTA8端口为GPIO功能，上升沿触发，上拉电阻</span><br><span class="line">gpio_init(PTA8,GPI,1);                               //设置为输入模式</span><br><span class="line">    </span><br><span class="line">port_init(PTD8,IRQ_EITHER|ALT1|PULLUP);              //初始化PTA8端口为GPIO功能，跳变沿触发，上拉电阻</span><br><span class="line">set_vector_handler(PORTD_VECTORn,PORTD_IRQHandler);  //设置中断函数入口</span><br><span class="line">enable_irq(PORTD_IRQn);                              //使能中断服务函数</span><br><span class="line">    </span><br><span class="line">pit_init_ms(PIT0,1000);                              //定时1000ms    </span><br><span class="line">set_vector_handler(PIT0_VECTORn,PIT0_IRQHandler);    //设置定时器的中断服务函数</span><br><span class="line">enable_irq(PIT0_IRQn);                               //使能</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;   </span><br><span class="line">    go(i);</span><br><span class="line">    if(get_key_msg(&amp;keymsg)==1)</span><br><span class="line">    &#123;</span><br><span class="line">      stas = keyname[keymsg.key];</span><br><span class="line">      choose(stas);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    DELAY_MS(250);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void choose(uint8 xuan)</span><br><span class="line">&#123;</span><br><span class="line">switch (stas)</span><br><span class="line">      &#123; </span><br><span class="line">      case 1: i=i+5;if(i&gt;=80) i=80; go(i);break;</span><br><span class="line">      case 2: i=i-5;if(i&lt;=20) i=20; go(i);break;</span><br><span class="line">      case 3: jd=jd+1;if(jd&gt;=25) jd=25; left(jd);break;</span><br><span class="line">      case 4: jd=jd-1;if(jd&lt;=0) jd=0; right(jd);break;</span><br><span class="line">      case 5: stop();break; </span><br><span class="line">      case 6: go(i);break;</span><br><span class="line">      default: stop();break;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lptmr_handler()    //实现10ms扫描一次按键的功能</span><br><span class="line">&#123;</span><br><span class="line">    LPTMR0_CSR|=LPTMR_CSR_TCF_MASK;     //清中断标志</span><br><span class="line">    key_IRQHandler();                   //案件信息扫描函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void go(uint8 gduty)            //前进函数</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,gduty);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void back(uint8 bduty)          //后退函数</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,0);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,bduty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stop()                     //停止函数</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,0);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int16 count()                   //计数函数（计算每500ms产生脉冲数）</span><br><span class="line">&#123;</span><br><span class="line">    cnt++;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PORTD_IRQHandler()        //每当D8跳变（产生脉冲）调用该中断服务函数         </span><br><span class="line">&#123;</span><br><span class="line">    PORT_FUNC(D,8,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PIT0_IRQHandler()          //定时中断函数，每500ms调用一次</span><br><span class="line">&#123;</span><br><span class="line">    int16 val;</span><br><span class="line">    val = cnt;</span><br><span class="line">    cnt=0;</span><br><span class="line">    printf(&quot;\n脉冲数为%d&quot;,val);</span><br><span class="line">    printf(&quot;理想速度为%d&quot;,i);</span><br><span class="line">    if(PTA8_IN==1)</span><br><span class="line">       printf(&quot;\n反向旋转&quot;);</span><br><span class="line">    else</span><br><span class="line">       printf(&quot;\n正向旋转&quot;);  </span><br><span class="line">    </span><br><span class="line">    PIT_Flag_Clear(PIT0);       //清中断标志位</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void left(uint8 ljd)</span><br><span class="line">&#123;           </span><br><span class="line">     FTM_PWM_Duty(FTM2,FTM_CH0,ljd);</span><br><span class="line">     DELAY_MS(400);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void right(uint8 rjd)</span><br><span class="line">&#123;</span><br><span class="line">     FTM_PWM_Duty(FTM2,FTM_CH0,rjd);</span><br><span class="line">     DELAY_MS(400);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="LCD显示中文字符-FWD版"><a href="#LCD显示中文字符-FWD版" class="headerlink" title="LCD显示中文字符(FWD版)"></a>LCD显示中文字符(FWD版)</h2><p>显示英文字符没有难度，不备份了。<br>CH_str_init();用来写变量名称，直接修改即可。<br>str_data();用来写变量，通过循环将对应数据填入数组即可使用。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line">#include &quot;enter.h&quot;            </span><br><span class="line"></span><br><span class="line">void CH_str_init();                                  //列装需要显示数据的标题</span><br><span class="line">void str_data(int a[]);                           //显示数据部分</span><br><span class="line"></span><br><span class="line">Site_t site = &#123;3,5&#125;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    uint8 i;</span><br><span class="line">    </span><br><span class="line">    int data[6]=&#123;0,1,2,3,4,5&#125;;</span><br><span class="line">    LCD_init();</span><br><span class="line">    ASSERT(enter_init());   //由于英文字库和汉字字库都在FWD里，因此需要判断是否加载了FWD固件</span><br><span class="line"></span><br><span class="line">    CH_str_init();</span><br><span class="line">    </span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    str_data(data);</span><br><span class="line">    DELAY_MS(1500);</span><br><span class="line">    for(i=0;i&lt;=5;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          data[i]=data[i]+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CH_str_init()</span><br><span class="line">&#123;</span><br><span class="line">  site.y = 5;</span><br><span class="line">  LCD_Str_CH(site,&quot;实际速度&quot;,BLACK,RED);                 //8*16显示字符串</span><br><span class="line">  site.y += 20;                                   //纵轴累加20，相当于换行</span><br><span class="line">  </span><br><span class="line">  LCD_Str_CH(site,&quot;理想速度&quot;,BLACK,RED);          //8*16显示字符串</span><br><span class="line">  site.y += 20;                                   //纵轴累加20，相当于换行</span><br><span class="line">  </span><br><span class="line">  LCD_Str_CH(site,&quot;理想角度&quot;,BLACK,RED);;          //8*16显示字符串</span><br><span class="line">  site.y += 20;                                   //纵轴累加20，相当于换行</span><br><span class="line">  </span><br><span class="line">  LCD_Str_CH(site,&quot;实际角度&quot;,BLACK,RED);          //8*16显示字符串</span><br><span class="line">  site.y += 20;                                   //纵轴累加20，相当于换行    LCD_str(site,&quot;First&quot;,FCOLOUR,BCOLOUR);          //8*16显示字符串</span><br><span class="line">  </span><br><span class="line">  LCD_Str_CH(site,&quot;角加速度&quot;,BLACK,RED);         //8*16显示字符串</span><br><span class="line">  site.y += 20;                                   //纵轴累加20，相当于换行</span><br><span class="line">  </span><br><span class="line">  LCD_Str_CH(site,&quot;线加速度&quot;,BLACK,RED);         //8*16显示字符串</span><br><span class="line">  site.y += 20;                                   //纵轴累加20，相当于换行</span><br><span class="line">  </span><br><span class="line">  site.x  = 3+6*12;                                //光标向后移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void str_data(int a[])</span><br><span class="line">&#123;</span><br><span class="line">  site.y = 5;</span><br><span class="line">  LCD_num(site,a[0],BLACK,RED);</span><br><span class="line">  site.y += 20;</span><br><span class="line">  </span><br><span class="line">  LCD_num(site,a[1],BLACK,RED);</span><br><span class="line">  site.y += 20;</span><br><span class="line">  </span><br><span class="line">  LCD_num(site,a[2],BLACK,RED);</span><br><span class="line">  site.y += 20;</span><br><span class="line"></span><br><span class="line">  LCD_num(site,a[3],BLACK,RED);</span><br><span class="line">  site.y += 20;</span><br><span class="line"></span><br><span class="line">  LCD_num(site,a[4],BLACK,RED);</span><br><span class="line">  site.y += 20;</span><br><span class="line"></span><br><span class="line">  LCD_num(site,a[5],BLACK,RED);</span><br><span class="line">  site.y += 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LCD显示中文（字库版）"><a href="#LCD显示中文（字库版）" class="headerlink" title="LCD显示中文（字库版）"></a>LCD显示中文（字库版）</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line">#include &quot;font.h&quot;          </span><br><span class="line"></span><br><span class="line">void CH_str_init();                                  //列装需要显示数据的标题</span><br><span class="line">void str_data(int a[]);                           //显示数据部分</span><br><span class="line"></span><br><span class="line">Site_t site = &#123;3,5&#125;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    uint8 i;</span><br><span class="line">    </span><br><span class="line">    int data[6]=&#123;0,1,2,3,4,5&#125;;</span><br><span class="line">    LCD_init();</span><br><span class="line">    //ASSERT(enter_init());   //由于英文字库和汉字字库都在FWD里，因此需要判断是否加载了FWD固件</span><br><span class="line"></span><br><span class="line">    CH_str_init();</span><br><span class="line">    </span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    str_data(data);</span><br><span class="line">    DELAY_MS(1500);</span><br><span class="line">    for(i=0;i&lt;=5;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          data[i]=data[i]+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CH_str_init()</span><br><span class="line">&#123;</span><br><span class="line">  site.y = 5;</span><br><span class="line">  LCD_str(site,&quot;test1&quot;,BLACK,RED);                 //8*16显示字符串</span><br><span class="line">  site.y += 20;                                   //纵轴累加20，相当于换行</span><br><span class="line">  </span><br><span class="line">  LCD_FSTR_CH(site,w_speed,BLACK,RED);          //8*16显示字符串</span><br><span class="line">  site.y += 20;                                   //纵轴累加20，相当于换行</span><br><span class="line">  </span><br><span class="line">  LCD_FSTR_CH(site,r_speed,BLACK,RED);;          //8*16显示字符串</span><br><span class="line">  site.y += 20;                                   //纵轴累加20，相当于换行</span><br><span class="line">  </span><br><span class="line">  LCD_FSTR_CH(site,w_jd,BLACK,RED);          //8*16显示字符串</span><br><span class="line">  site.y += 20;                                   //纵轴累加20，相当于换行    LCD_str(site,&quot;First&quot;,FCOLOUR,BCOLOUR);          //8*16显示字符串</span><br><span class="line">  </span><br><span class="line">  LCD_FSTR_CH(site,r_jd,BLACK,RED);         //8*16显示字符串</span><br><span class="line">  site.y += 20;                                   //纵轴累加20，相当于换行</span><br><span class="line">  </span><br><span class="line">  LCD_FSTR_CH(site,diection,BLACK,RED);         //8*16显示字符串</span><br><span class="line">  site.y += 20;                                   //纵轴累加20，相当于换行</span><br><span class="line">  </span><br><span class="line">  site.x  = 3+6*12;                                //光标向后移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void str_data(int a[])</span><br><span class="line">&#123;</span><br><span class="line">  site.y = 5;</span><br><span class="line">  LCD_num(site,a[0],BLACK,RED);</span><br><span class="line">  site.y += 20;</span><br><span class="line">  </span><br><span class="line">  LCD_num(site,a[1],BLACK,RED);</span><br><span class="line">  site.y += 20;</span><br><span class="line">  </span><br><span class="line">  LCD_num(site,a[2],BLACK,RED);</span><br><span class="line">  site.y += 20;</span><br><span class="line"></span><br><span class="line">  LCD_num(site,a[3],BLACK,RED);</span><br><span class="line">  site.y += 20;</span><br><span class="line"></span><br><span class="line">  LCD_num(site,a[4],BLACK,RED);</span><br><span class="line">  site.y += 20;</span><br><span class="line"></span><br><span class="line">  LCD_num(site,a[5],BLACK,RED);</span><br><span class="line">  site.y += 20;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="摄像头显示程序"><a href="#摄像头显示程序" class="headerlink" title="摄像头显示程序"></a>摄像头显示程序</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">//11.摄像头LCD显示,上位机显示</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">uint8 imgbuff[CAMERA_SIZE];       //定义存储接收图像的数组</span><br><span class="line">uint8 img[CAMERA_H][CAMERA_W];</span><br><span class="line"></span><br><span class="line">void PORTA_IRQHandler();          //场中断服务函数</span><br><span class="line">void DMA0_IRQHandler();           //DMA数据传输中断服务函数</span><br><span class="line"></span><br><span class="line">void  main(void)</span><br><span class="line">&#123;</span><br><span class="line">    Site_t site=&#123;0, 0&#125;;                  //图像左上角位置坐标</span><br><span class="line">    Size_t imgsize=&#123;CAMERA_W, CAMERA_H&#125;; //图像大小</span><br><span class="line">    Size_t size;                         //显示区域图像大小</span><br><span class="line"></span><br><span class="line">    LCD_init();         </span><br><span class="line">    LCD_str(site,&quot;Cam init ing&quot;,FCOLOUR,BCOLOUR);   //初始化LCD，然后显示提示信息，延时0.5s</span><br><span class="line">    DELAY_MS(500);</span><br><span class="line">    </span><br><span class="line">    size.H = LCD_H;             </span><br><span class="line">    size.W = LCD_W;                     //显示区域长宽等于LCD长宽（LCD_H,LCD_W为宏定义，用于获取LCD长宽）</span><br><span class="line"></span><br><span class="line">    camera_init(imgbuff);               //初始化摄像头，并设定imgbuff为存储图像的数组</span><br><span class="line"></span><br><span class="line">    LCD_str(site,&quot;Cam init OK!&quot;,FCOLOUR,BCOLOUR);   //初始摄像头完毕后，显示提示信息</span><br><span class="line">    DELAY_MS(500);</span><br><span class="line">    </span><br><span class="line">    site.y = 110;</span><br><span class="line">    LCD_str(site,&quot;CET-8&quot;,FCOLOUR,BCOLOUR);</span><br><span class="line">    DELAY_MS(500);                      //在最下方显示队名，延时0.5s</span><br><span class="line">    </span><br><span class="line">    set_vector_handler(PORTA_VECTORn , PORTA_IRQHandler);   //设置 PORTA 的中断服务函数为 PORTA_IRQHandler</span><br><span class="line">    set_vector_handler(DMA0_VECTORn , DMA0_IRQHandler);     //设置 DMA0 的中断服务函数为 PORTA_IRQHandler</span><br><span class="line">    site.y = 0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        camera_get_img();               //摄像头获取图像</span><br><span class="line">        /***LCD显示***/</span><br><span class="line">        LCD_Img_Binary_Z(site, size, imgbuff, imgsize);      //LCD显示图像</span><br><span class="line">        </span><br><span class="line">        /***上位机黑白模式显示***/</span><br><span class="line">        vcan_sendimg(imgbuff, sizeof(imgbuff));             //黑白模式发送图像到上位机</span><br><span class="line">        </span><br><span class="line">        /***上位机灰度模式显示***/</span><br><span class="line">        img_extract(img, imgbuff, CAMERA_SIZE);             //解压为灰度图像，方便发送到上位机显示</span><br><span class="line">        vcan_sendimg(img, sizeof(img));                     //将解压得到的数组及数组大小发送给上位机</span><br><span class="line">        img_extract(img, imgbuff, CAMERA_SIZE);             //解压为灰度图像，方便发送到上位机显</span><br><span class="line">        vcan_sendimg(img, CAMERA_W * CAMERA_H);             //图像发送到上位机</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PORTA_IRQHandler()</span><br><span class="line">&#123;</span><br><span class="line">    uint8  n;    //引脚号</span><br><span class="line">    uint32 flag;</span><br><span class="line"></span><br><span class="line">    while(!PORTA_ISFR);</span><br><span class="line">    flag = PORTA_ISFR;</span><br><span class="line">    PORTA_ISFR  = ~0;                                   //清中断标志位</span><br><span class="line">    n = 29;                                             //场中断</span><br><span class="line">    if(flag &amp; (1 &lt;&lt; n))                                 //PTA29触发中断</span><br><span class="line">      </span><br><span class="line">    &#123;</span><br><span class="line">        camera_vsync();</span><br><span class="line">    &#125;</span><br><span class="line">#if ( CAMERA_USE_HREF == 1 )                            //使用行中断</span><br><span class="line">    n = 28;</span><br><span class="line">    if(flag &amp; (1 &lt;&lt; n))                                 //PTA28触发中断</span><br><span class="line">    &#123;</span><br><span class="line">        camera_href();</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DMA0_IRQHandler()     //DMA数据传输函数</span><br><span class="line">&#123;</span><br><span class="line">    camera_dma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h1 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h1><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><ol><li><img src="https://i.imgur.com/nT373EF.png" alt></li><li>归纳为：s·m = A·[R|t]·M<br>注：s为倍乘因子，m为图像坐标系，M为世界坐标系，[R|t]指线性变换矩阵，A指相机内部参数矩阵。<br>s·m为程序中的二维数组。（像素大小？）<br>A可以将相机坐标系转换为像平面坐标系。（标定参数）<br>[R|t]为线性变换矩阵。<br>M为世界坐标系。(实际大小？)</li><li><img src="https://i.imgur.com/AMVxfEL.png" alt>因为无测距模块，所以世界坐标系中的Z为0。<br>最终得到表达式<br><img src="https://i.imgur.com/z0PTIjW.png" alt></li></ol><h2 id="接收图像"><a href="#接收图像" class="headerlink" title="接收图像"></a>接收图像</h2><p>这步是我遇到的第一个问题，由于山外的上位机无法保存图像，所以我写了一个matlab脚本来实现接收图像。<br>将接收到的十六进制字符保存到记事本，然后运行即可。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">shujuji = textread(&apos;C:\Users\树枝990\Desktop\test2.txt&apos;,&apos;%s&apos;);      %将所有图像数据导入</span><br><span class="line">useful= hex2dec(shujuji);                                         %将这些十六进制数据转为十进制</span><br><span class="line">x = find(useful == 01 );                 %找到所有起始点，结束点的位置</span><br><span class="line">tuxiang = useful(x(3):x(4),1);           %获得一帧图像的数据</span><br><span class="line">tuxiang = tuxiang(2:4801,1);             %只要他的4800个点</span><br><span class="line">tuxiang = reshape(tuxiang,80,60);        %转换成80*60矩阵</span><br><span class="line">tuxiang = tuxiang&apos;;                      %转置一波</span><br><span class="line">imshow(tuxiang)                          %显示图像</span><br></pre></td></tr></table></figure></code></pre><h2 id="Matlab仿真梯形变换"><a href="#Matlab仿真梯形变换" class="headerlink" title="Matlab仿真梯形变换"></a>Matlab仿真梯形变换</h2><p>由于需要确定校正表的值，因此现在Matlab上仿真一波。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line">%数据转化为图像</span><br><span class="line">shujuji = textread(&apos;C:\Users\树枝990\Desktop\test2.txt&apos;,&apos;%s&apos;);      %将所有图像数据导入</span><br><span class="line">useful= hex2dec(shujuji);                                         %将这些十六进制数据转为十进制</span><br><span class="line">x = find(useful == 01 );                 %找到所有起始点，结束点的位置</span><br><span class="line">tuxiang = useful(x(3):x(4),1);           %获得一帧图像的数据</span><br><span class="line">tuxiang = tuxiang(2:4801,1);             %只要他的4800个点</span><br><span class="line">tuxiang = reshape(tuxiang,80,60);        %转换成80*60矩阵</span><br><span class="line">tuxiang = tuxiang&apos;;                      %转置一波</span><br><span class="line">imshow(tuxiang)                          %显示图像</span><br><span class="line"></span><br><span class="line">%图像导入部分</span><br><span class="line">img_origin =tuxiang;                       %导入生成的图像矩阵</span><br><span class="line">img_size = size(img_origin);               %计算图像的尺寸</span><br><span class="line"></span><br><span class="line">%数据设定部分</span><br><span class="line">m1 = 1.5;%1.0477;%理想值1.5</span><br><span class="line">m2 = 0.0464;%0.03464;对扭曲有影响</span><br><span class="line">m3 = -60.1094;%-74.1094;好像和倾斜有一点关系，没有找出具体的关系,好像是放大倍数，这个数越大，图像被放大的越多</span><br><span class="line">m4 =0;      %和图像旋转有关</span><br><span class="line">m5 =-3.25;%-1.8277;这个是影响梯形变换的参数，最重要。</span><br><span class="line">m6 =165.8219;%126.8219;,这个数越小，图像越扁；经过我的缜密分析（瞎试）255这个值比较好</span><br><span class="line">m7 =0;</span><br><span class="line">m8 = 0.0585;%0.0503;     %图像的畸变矩阵，这个值对图像的偏斜有影响，这个值越大，图像越往左偏移；0.00455好一点</span><br><span class="line">u = 137%181.72;%141.7629%290;        %横向的（前面的）  ，最佳290</span><br><span class="line">v = 3.64%3.64;%15.6541%15;        %纵向的（后面的）填入图像的像素，15比较理想</span><br><span class="line">c=0;</span><br><span class="line">%对新图像的存贮矩阵进行预处理</span><br><span class="line"></span><br><span class="line">x=(m1*u+m2*v+m3)/(m7*u+m8*v+1);% 水平方向column,新图像的x</span><br><span class="line">y=(m4*u+m5*v+m6)/(m7*u+m8*v+1); % 行row为垂直方向，新图像的y</span><br><span class="line">x=uint16(x);</span><br><span class="line">y=uint16(y); %强制类型转换，本段为生成新矩阵容纳校正后的图像</span><br><span class="line">img_undist = zeros(y ,x ); % 所有元素初始化为0</span><br><span class="line">new_size = size(img_undist); % 返回m×n全0矩阵的行数或列数</span><br><span class="line">img_undist = uint8( img_undist );   %强制类型转换</span><br><span class="line"></span><br><span class="line">%对整个图像中每一点进行逆透视运算</span><br><span class="line">for i = 20:60%i = 1:(img_size(1)) % 行row为垂直方向，遍历原图像中每一行</span><br><span class="line">    for j = 1:(img_size(2)) % 水平方向column，遍历源图像中每一列</span><br><span class="line">        u=j; % 水平方向column     真实图像（相机坐标横轴）点的位置，横行</span><br><span class="line">        v=i; % 垂直方向     真实图像点（相机坐标纵轴）的位置，纵行</span><br><span class="line">        x=(m1*u+m2*v+m3)/(m7*u+m8*v+1); % 水平方向column，计算透视之后该点的位置，横行</span><br><span class="line">        y=(m4*u+m5*v+m6)/(m7*u+m8*v+1);% 行row为垂直方向，计算透视之后该点的位置，纵行</span><br><span class="line">        %x=int16(x)+new_size(2)/2; %图像不居中，现修正显示,int16()的含义是四舍五入一下</span><br><span class="line">        %x=int16(x)+57;</span><br><span class="line">        x=int16(x)+57;</span><br><span class="line">        y=int16(y);%将其化为整数</span><br><span class="line">        if(y&gt;0 &amp;&amp;x&gt;0 )</span><br><span class="line">            img_undist(y,x)= img_origin(i,j); %对应坐标</span><br><span class="line"></span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h2 id="K60实现"><a href="#K60实现" class="headerlink" title="K60实现"></a>K60实现</h2><p>最终在K60上实现变换。<br>按液晶屏中键进入梯形变换，按独立按键退出。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">uint8 imgbuff[CAMERA_SIZE];     //定义存储接收图像的一维数组</span><br><span class="line">uint8 img[CAMERA_H][CAMERA_W];  //解压得到的图像数据</span><br><span class="line">uint8 img_change[120][154];             //处理后的图像数据</span><br><span class="line">uint8 img_flipud[120][154];</span><br><span class="line">double m[8]=&#123;1.5,0.0464,-60.1094,0,-3.25,165.8219,0,0.0585&#125;;     //矫正表</span><br><span class="line">//double m[8]=&#123;&#125;;</span><br><span class="line">Site_t site=&#123;0, 0&#125;;                  //图像左上角位置坐标</span><br><span class="line">Size_t imgsize=&#123;CAMERA_W, CAMERA_H&#125;; //图像大小</span><br><span class="line">Size_t size;                         //显示区域图像大小</span><br><span class="line">Size_t imgc_size=&#123;154,120&#125;;        //生成的图像大小</span><br><span class="line">Size_t imgf_size=&#123;154,120&#125;;</span><br><span class="line">KEY_MSG_t keymsg;</span><br><span class="line"></span><br><span class="line">uint8 i,j,u,v,x,y,cnt=0;</span><br><span class="line">uint8 biaoz = 0;                     //用来标志现在显示什么</span><br><span class="line"></span><br><span class="line">void PORTA_IRQHandler();          //场中断服务函数</span><br><span class="line">void DMA0_IRQHandler();           //DMA数据传输中断服务函数</span><br><span class="line">void pit_hander();</span><br><span class="line">void change();</span><br><span class="line">void flipud();</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    key_init(KEY_A);    //初始化按键，A为独立按键，退出用</span><br><span class="line">    key_init(KEY_B);    //初始化按键，B为液晶中键，进入用</span><br><span class="line">    </span><br><span class="line">    LCD_init();         //初始化液晶屏幕</span><br><span class="line">    </span><br><span class="line">    size.H = LCD_H;             </span><br><span class="line">    size.W = LCD_W;     //显示区域长宽等于LCD长宽</span><br><span class="line"></span><br><span class="line">    camera_init(imgbuff);      //初始化摄像头</span><br><span class="line">    SCCB_WriteByte (OV7725_CNST, 85);    //调节阈值，晚上75比较好</span><br><span class="line">    </span><br><span class="line">    LCD_str(site,&quot;WIN&quot;,FCOLOUR,BCOLOUR);   //初始摄像头完毕后，显示提示信息</span><br><span class="line">    DELAY_MS(200);</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    set_vector_handler(PORTA_VECTORn , PORTA_IRQHandler);   </span><br><span class="line">    set_vector_handler(DMA0_VECTORn , DMA0_IRQHandler);     //设置中断服务函数</span><br><span class="line">    pit_init_ms(PIT0,10);</span><br><span class="line">    set_vector_handler(PIT0_VECTORn,pit_hander);</span><br><span class="line">    enable_irq(PIT0_IRQn);</span><br><span class="line">    </span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(get_key_msg(&amp;keymsg)==1)</span><br><span class="line">        &#123;</span><br><span class="line">          if((keymsg.status == KEY_DOWN) &amp;&amp; (keymsg.key == KEY_B ))</span><br><span class="line">              biaoz=1;          //进入</span><br><span class="line">          if((keymsg.status == KEY_DOWN) &amp;&amp; (keymsg.key == KEY_A ))</span><br><span class="line">              biaoz=0;          //退出</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">        if(biaoz==0)    //显示原图像</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">        camera_get_img();               //摄像头获取图像</span><br><span class="line">        LCD_Img_Binary_Z(site, size, imgbuff, imgsize);      //LCD显示图像</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        else if(biaoz==1)</span><br><span class="line">        &#123;</span><br><span class="line">         /*</span><br><span class="line">        if(get_key_msg(&amp;keymsg)==1)</span><br><span class="line">            &#123;</span><br><span class="line">                LCD_rectangle(site, size, BLUE);     //初始化背景</span><br><span class="line">            &#125;</span><br><span class="line">*/</span><br><span class="line">        //LCD_str(site,&quot;MUST WIN&quot;,FCOLOUR,BLUE);</span><br><span class="line">        change();</span><br><span class="line">        //vcan_sendimg(img_change, sizeof(img_change));</span><br><span class="line">        //对图像进行变换</span><br><span class="line">        //LCD_Img_gray_Z(site, size, *img_change,imgc_size);      //LCD显示图像</span><br><span class="line">        flipud();</span><br><span class="line">        LCD_Img_gray_Z(site, size, *img_flipud,imgf_size);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pit_hander()</span><br><span class="line">&#123;</span><br><span class="line">    if(PIT_TFLG(PIT0)==1)</span><br><span class="line">    &#123;</span><br><span class="line">        PIT_Flag_Clear(PIT0);</span><br><span class="line">        key_IRQHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PORTA_IRQHandler()</span><br><span class="line">&#123; </span><br><span class="line">    uint8  n;    //引脚号</span><br><span class="line">    uint32 flag;</span><br><span class="line"></span><br><span class="line">    while(!PORTA_ISFR);</span><br><span class="line">    flag = PORTA_ISFR;</span><br><span class="line">    PORTA_ISFR  = ~0;                                   //清中断标志位</span><br><span class="line">    n = 29;                                             //场中断</span><br><span class="line">    if(flag &amp; (1 &lt;&lt; n))                                 //PTA29触发中断</span><br><span class="line">      </span><br><span class="line">    &#123;</span><br><span class="line">        camera_vsync();</span><br><span class="line">    &#125;</span><br><span class="line">#if ( CAMERA_USE_HREF == 1 )                            //使用行中断</span><br><span class="line">    n = 28;</span><br><span class="line">    if(flag &amp; (1 &lt;&lt; n))                                 //PTA28触发中断</span><br><span class="line">    &#123;</span><br><span class="line">        camera_href();</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DMA0_IRQHandler()     //DMA数据传输函数</span><br><span class="line">&#123;</span><br><span class="line">    camera_dma();</span><br><span class="line">&#125;</span><br><span class="line">void change()</span><br><span class="line">&#123;</span><br><span class="line">img_extract(img, imgbuff, CAMERA_SIZE);</span><br><span class="line">for (i = 1;i&lt;=60;i++)             </span><br><span class="line">    for(j = 1;j&lt;=80;j++)</span><br><span class="line">&#123;</span><br><span class="line">        u=j; </span><br><span class="line">        v=i;</span><br><span class="line">        x=(m[0]*u+m[1]*v+m[2])/(m[6]*u+m[7]*v+1); // 水平方向column，计算透视之后该点的位置，横行</span><br><span class="line">        y=(m[3]*u+m[4]*v+m[5])/(m[6]*u+m[7]*v+1);// 行row为垂直方向，计算透视之后该点的位置，纵行</span><br><span class="line">        x=x+57;</span><br><span class="line">        if(y&gt;0 &amp;&amp;x&gt;0 )</span><br><span class="line">           img_change[y][x]= img[i][j]; //对应坐标</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void flipud()</span><br><span class="line">&#123;</span><br><span class="line">    for (i=0; i&lt;119; i++)  </span><br><span class="line">      for (j=0; j&lt;153; j++)  </span><br><span class="line">        img_flipud[i][j]=img_change[119-i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="读代码所得"><a href="#读代码所得" class="headerlink" title="读代码所得"></a>读代码所得</h1><p>最近学习PID算法，资料繁琐难懂，因此通过读代码来学习。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;PID.h&quot;</span><br><span class="line"></span><br><span class="line">PID S_D5_PID, MOTOR_PID;//定义舵机和电机的PID参数结构体</span><br><span class="line">int32 S_D5[10][4] = &#123;&#123;37, 0, 15, 16&#125;,&#123; 20, 1, 0, 19&#125;, &#123;24, 2, 15, 28&#125;, &#123;24, 3, 22, 14&#125;, &#123;20, 4, 25, 14&#125;, &#123;24, 5, 24, 13&#125;, &#123;26, 6, 18 , 13&#125;, &#123;25, 7, 27, 14&#125;, &#123;29,8,35,13&#125;&#125;;//舵机PID</span><br><span class="line">                                  //&#123; 20, 1, 0, 19&#125;, &#123;24, 2, 15, 28&#125;, &#123;22, 3, 24, 14&#125;, &#123;23, 4, 29, 15&#125;, &#123;25, 5, 21, 14&#125;, &#123;26, 6, 18, 14&#125;,&#125;,&#123;28, 7, 32, 14&#125; &#123;27,8,35,12&#125;;</span><br><span class="line">/* PID 的 I 项没有使用，只用 PD6此处 I 仅作为速度模式的标号，对PID无影响 */</span><br><span class="line"></span><br><span class="line">//位置式PID参数初始化</span><br><span class="line">//float   MOTOR[3] = &#123;4, 0.7, 0&#125;;</span><br><span class="line">float   MOTOR[3] = &#123;5, 0.4, 0&#125;;//电机PID</span><br><span class="line">void PlacePID_Init(PID *sptr)</span><br><span class="line">&#123;</span><br><span class="line">sptr-&gt;SumError = 0;</span><br><span class="line">sptr-&gt;LastError = 0;//Error[-1]</span><br><span class="line">sptr-&gt;PrevError = 0;//Error[-2]</span><br><span class="line">&#125;</span><br><span class="line">//增量式PID参数初始化</span><br><span class="line">void IncPID_Init(PID *sptr)</span><br><span class="line">&#123;</span><br><span class="line">sptr-&gt;SumError = 0;     //sptr是一个指针，指向PID参数结构体；</span><br><span class="line">        //SumError是结构体的一个成员，本句将该成员赋值为0</span><br><span class="line">//-&gt;用来访问该成员</span><br><span class="line">        sptr-&gt;LastError = 0;//Error[-1]</span><br><span class="line">sptr-&gt;PrevError = 0;//Error[-2]</span><br><span class="line">sptr-&gt;LastSpeed = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//位置式PID舵机控制</span><br><span class="line">int32 PlacePID_Control(PID *sprt, int32 NowPiont, int32 SetPoint)</span><br><span class="line">&#123;</span><br><span class="line">//定义为寄存器变量，只能用于整型和字符型变量，提高运算速度</span><br><span class="line">int32 iError,//当前误差</span><br><span class="line">  Actual;//最后得出的实际输出值</span><br><span class="line">floatKp;//动态P</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iError = SetPoint - NowPiont;//计算当前误差</span><br><span class="line">Kp = 1.0 * (iError*iError) / S_D5[Set][KT] + S_D5[Set][KP];//P值与差值成二次函数关系</span><br><span class="line"></span><br><span class="line">Actual = Kp * iError + S_D5[Set][KD] * (iError - sprt-&gt;LastError);//只用PD</span><br><span class="line"></span><br><span class="line">sprt-&gt;LastError = iError;//更新上次误差</span><br><span class="line"></span><br><span class="line">        /*if (Actual)</span><br><span class="line">        &#123;</span><br><span class="line">            Actual = Actual * 90 / 100;</span><br><span class="line">        &#125; */</span><br><span class="line"></span><br><span class="line">return Actual + S_D5_MID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int32 PID_Cascade(PID *sptr, int32 ActualSpeed, int32 SetSpeed)</span><br><span class="line">&#123;</span><br><span class="line">//当前误差，定义为寄存器变量，只能用于整型和字符型变量，提高运算速度</span><br><span class="line">register int32 iError,    //当前误差</span><br><span class="line">Increase;//最后得出的实际增量</span><br><span class="line"></span><br><span class="line">iError = SetSpeed - ActualSpeed;//计算当前误差</span><br><span class="line"></span><br><span class="line">Increase = - MOTOR[KP] * (ActualSpeed - sptr-&gt;LastSpeed)//加速度</span><br><span class="line">   + MOTOR[KI] * iError</span><br><span class="line">   + MOTOR[KD] * (iError - 2 * sptr-&gt;LastError + sptr-&gt;PrevError);</span><br><span class="line"></span><br><span class="line">sptr-&gt;PrevError = sptr-&gt;LastError;//更新前次误差</span><br><span class="line">sptr-&gt;LastError = iError;  //更新上次误差</span><br><span class="line">sptr-&gt;LastSpeed = ActualSpeed;//更新上次速度</span><br><span class="line"></span><br><span class="line">if (iError &lt; -100)</span><br><span class="line">&#123;</span><br><span class="line">Increase -= 400;</span><br><span class="line">&#125;</span><br><span class="line">else if (iError &lt; -80)</span><br><span class="line">&#123;</span><br><span class="line">Increase -= 300;</span><br><span class="line">&#125;</span><br><span class="line">else if (iError &lt; -50)</span><br><span class="line">&#123;</span><br><span class="line">Increase -= 250;</span><br><span class="line">&#125;</span><br><span class="line">else if (iError &lt; -30)</span><br><span class="line">&#123;</span><br><span class="line">Increase -= 200;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">/*        if (iError &lt; -100)</span><br><span class="line">&#123;</span><br><span class="line">Increase -= 200;</span><br><span class="line">&#125;</span><br><span class="line">else if (iError &lt; -80)</span><br><span class="line">&#123;</span><br><span class="line">Increase -= 150;</span><br><span class="line">&#125;</span><br><span class="line">else if (iError &lt; -50)</span><br><span class="line">&#123;</span><br><span class="line">Increase -= 125;</span><br><span class="line">&#125;</span><br><span class="line">        else if (iError &lt; -30)</span><br><span class="line">        &#123;</span><br><span class="line">                Increase -= 100;</span><br><span class="line">        &#125;*/</span><br><span class="line"></span><br><span class="line">return Increase;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//增量式PID电机控制</span><br><span class="line">int32 PID_Realize(PID *sptr, int32 ActualSpeed, int32 SetSpeed)</span><br><span class="line">&#123;</span><br><span class="line">//当前误差，定义为寄存器变量，只能用于整型和字符型变量，提高运算速度</span><br><span class="line">register int32 iError,    //当前误差</span><br><span class="line">Increase;//最后得出的实际增量</span><br><span class="line"></span><br><span class="line">iError = SetSpeed - ActualSpeed;//计算当前误差</span><br><span class="line"></span><br><span class="line">Increase = MOTOR[KP] * (iError - sptr-&gt;LastError)</span><br><span class="line"> + MOTOR[KI] * iError</span><br><span class="line"> + MOTOR[KD] * (iError - 2 * sptr-&gt;LastError + sptr-&gt;PrevError);</span><br><span class="line"></span><br><span class="line">sptr-&gt;PrevError = sptr-&gt;LastError;//更新前次误差</span><br><span class="line">sptr-&gt;LastError = iError;  //更新上次误差</span><br><span class="line"></span><br><span class="line">if (iError &lt; -70)</span><br><span class="line">&#123;</span><br><span class="line">BangBang_Flag = 1;</span><br><span class="line">Increase -= 80;</span><br><span class="line">&#125;</span><br><span class="line">else if (iError &lt; -50)</span><br><span class="line">&#123;</span><br><span class="line">BangBang_Flag = 1;</span><br><span class="line">Increase -= 50;</span><br><span class="line">&#125;</span><br><span class="line">else if (iError &lt; -30)</span><br><span class="line">&#123;</span><br><span class="line">BangBang_Flag = 1;</span><br><span class="line">Increase -= 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ((iError &gt; 50) &amp;&amp; (BangBang_Flag == 1))</span><br><span class="line">&#123;</span><br><span class="line">BangBang_Flag = 0;</span><br><span class="line">Increase +=  170;</span><br><span class="line">&#125;</span><br><span class="line">else if (iError &gt; 50)</span><br><span class="line">&#123;</span><br><span class="line">Increase += 120;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return Increase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><p>山外论坛的每日一题，学习学习，提升编程能力</p><h2 id="11-6日"><a href="#11-6日" class="headerlink" title="11.6日"></a>11.6日</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(i=0;i&lt;100;i++)与for(i=100;i&gt;0;i--)哪个更有效率</span><br><span class="line">A.for(i=0;i&lt;100;i++)</span><br><span class="line">B.for(i=100;i&gt;0;i--)</span><br></pre></td></tr></table></figure></code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>汇编指令，只有与0比较大小，不能直接与100比较大小。<br>i&lt;100等效与100-i&gt;0，与i&gt;0相比多了一步减法,因此B更有效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好好学习K60单片机&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>破解论文2</title>
    <link href="http://linmushen.com/2019/09/10/%E7%A0%B4%E8%A7%A3%E8%AE%BA%E6%96%872/"/>
    <id>http://linmushen.com/2019/09/10/破解论文2/</id>
    <published>2019-09-10T14:46:37.000Z</published>
    <updated>2019-09-12T11:08:52.593Z</updated>
    
    <content type="html"><![CDATA[<p>按照模型分类的优秀论文。<br><a id="more"></a></p><h1 id="大量数据、灰色关联、优化、聚类、神经网络"><a href="#大量数据、灰色关联、优化、聚类、神经网络" class="headerlink" title="大量数据、灰色关联、优化、聚类、神经网络"></a>大量数据、灰色关联、优化、聚类、神经网络</h1><h2 id="原文位置"><a href="#原文位置" class="headerlink" title="原文位置"></a>原文位置</h2><p>C:/Users/树枝990/Desktop/数学建模/数学建模论文/30个常用模型对应的建模比赛获奖论文（中文）/灰色关联分析/[2017年国赛高教杯奖B题]华中科技大学-基于聚类分析的双目标优化定价模型</p><h2 id="大量数据"><a href="#大量数据" class="headerlink" title="大量数据"></a>大量数据</h2><p>此题有近两千组数据。</p><h3 id="定性分析"><a href="#定性分析" class="headerlink" title="定性分析"></a>定性分析</h3><p>根据题中经纬度数据、定价数据绘制三维立体图。<br>将三组数据进行拟合三维拟合图，将经纬度用坐标表示出来，将定价用颜色深浅表示出来。</p><h3 id="定量分析"><a href="#定量分析" class="headerlink" title="定量分析"></a>定量分析</h3><p>首先要剔除异常数据，利用拉依达准则。<br>对数据进行离散化处理：将范围分为相同大小的单元格。计算每个单元格的平均影响因子数据(任务数量、会员数量、平均完成能力)。<br>熵权法确定会员的得分。</p><blockquote><p>熵权法教程<br><a href="https://blog.csdn.net/qq_32942549/article/details/80019005" target="_blank" rel="noopener">https://blog.csdn.net/qq_32942549/article/details/80019005</a><br>计算表格里会员的平均得分。<br>进行K-means聚类分析，得到各聚类的中心位置，计算每个点距中心的距离(影响因子)<br>K-means教程<br><a href="https://www.cnblogs.com/niniya/p/8784947.html" target="_blank" rel="noopener">https://www.cnblogs.com/niniya/p/8784947.html</a></p></blockquote><h2 id="灰色关联"><a href="#灰色关联" class="headerlink" title="灰色关联"></a>灰色关联</h2><p>先分为两种情况(完成/未完成)<br>计算两种情况下影响因子的相关系数(影响程度)，计算两种情况下同一因子之间的差值，从而得到对未完成影响最大的因子(即未完成原因)。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照模型分类的优秀论文。&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>链接收藏</title>
    <link href="http://linmushen.com/2019/09/06/%E9%93%BE%E6%8E%A5%E6%94%B6%E8%97%8F/"/>
    <id>http://linmushen.com/2019/09/06/链接收藏/</id>
    <published>2019-09-06T15:46:52.000Z</published>
    <updated>2019-09-28T07:16:56.072Z</updated>
    
    <content type="html"><![CDATA[<p>几个链接，防止以后找不到<br><a id="more"></a></p><h1 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h1><p>关于论文侧重点的说明<br>&lt; <a href="https://www.zhihu.com/question/65256909/answer/365283612" target="_blank" rel="noopener">https://www.zhihu.com/question/65256909/answer/365283612</a><br>建模概述<br>&lt; <a href="https://zhuanlan.zhihu.com/p/32918281" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32918281</a></p><p>论文模板<br><a href="https://wenku.baidu.com/view/a3bd8763783e0912a2162a9e.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/a3bd8763783e0912a2162a9e.html</a></p><p>matlab文档查询</p><blockquote><p><a href="https://ww2.mathworks.cn/help/matlab/index.html" target="_blank" rel="noopener">https://ww2.mathworks.cn/help/matlab/index.html</a></p></blockquote><p>matlab统计概率分布</p><blockquote><p><a href="https://www.cnblogs.com/djcsch2001/archive/2012/02/05/2339193.html" target="_blank" rel="noopener">https://www.cnblogs.com/djcsch2001/archive/2012/02/05/2339193.html</a></p></blockquote><p>学校图书馆地址</p><blockquote><p><a href="http://lib.hrbust.edu.cn/" target="_blank" rel="noopener">http://lib.hrbust.edu.cn/</a></p></blockquote><p>数学建模的一般步骤</p><blockquote><p><a href="https://wenku.baidu.com/view/dc1712795acfa1c7aa00cc65.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/dc1712795acfa1c7aa00cc65.html</a></p></blockquote><p>数学建模算法大全</p><blockquote><p><a href="https://blog.csdn.net/weixin_43107805/article/details/89069182?utm_source=app" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43107805/article/details/89069182?utm_source=app</a><br><a href="https://blog.csdn.net/dyq1995/article/details/84426634" target="_blank" rel="noopener">https://blog.csdn.net/dyq1995/article/details/84426634</a></p></blockquote><p>数学建模模型资料</p><blockquote><p><a href="https://blog.csdn.net/qq_41149269/article/details/95755089" target="_blank" rel="noopener">https://blog.csdn.net/qq_41149269/article/details/95755089</a></p></blockquote><p>数学建模模型应用视频</p><blockquote><p><a href="https://www.bilibili.com/video/av39876234?from=search&amp;seid=12304942382843021294" target="_blank" rel="noopener">https://www.bilibili.com/video/av39876234?from=search&amp;seid=12304942382843021294</a></p></blockquote><h1 id="恩智浦"><a href="#恩智浦" class="headerlink" title="恩智浦"></a>恩智浦</h1><p>智能车基地论坛</p><blockquote><p><a href="http://www.daimxa.cn/forum.php" target="_blank" rel="noopener">http://www.daimxa.cn/forum.php</a></p></blockquote><p>山外论坛</p><blockquote><p><a href="http://www.vcan123.com/forum.php" target="_blank" rel="noopener">http://www.vcan123.com/forum.php</a></p></blockquote><p>智能车制作</p><blockquote><p><a href="http://www.znczz.com/" target="_blank" rel="noopener">http://www.znczz.com/</a></p></blockquote><p>pid学习链接</p><blockquote><p><a href="http://www.vcan123.com/forum.php?mod=viewthread&amp;tid=7726" target="_blank" rel="noopener">http://www.vcan123.com/forum.php?mod=viewthread&amp;tid=7726</a></p></blockquote><p>一个不错的资源贴</p><blockquote><p><a href="http://www.znczz.com/forum.php?mod=viewthread&amp;tid=79721&amp;extra=page%3D1" target="_blank" rel="noopener">http://www.znczz.com/forum.php?mod=viewthread&amp;tid=79721&amp;extra=page%3D1</a></p></blockquote><p>有关电子电路</p><blockquote><p><a href="http://www.vcan123.com/forum.php?mod=viewthread&amp;tid=6241" target="_blank" rel="noopener">http://www.vcan123.com/forum.php?mod=viewthread&amp;tid=6241</a></p></blockquote><p>很好的一个介绍贴</p><blockquote><p><a href="https://blog.csdn.net/lczdk/article/details/53891920" target="_blank" rel="noopener">https://blog.csdn.net/lczdk/article/details/53891920</a></p></blockquote><p>山外鹰眼相关的帖子</p><blockquote><p><a href="https://blog.csdn.net/weixin_30735391/article/details/97529786" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30735391/article/details/97529786</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个链接，防止以后找不到&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>c语言学习笔记</title>
    <link href="http://linmushen.com/2019/09/06/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/09/06/c语言学习笔记/</id>
    <published>2019-09-06T08:14:10.000Z</published>
    <updated>2019-11-26T01:36:47.113Z</updated>
    
    <content type="html"><![CDATA[<p>系统学习C语言，准备国二。<br><a id="more"></a></p><h1 id="乱记"><a href="#乱记" class="headerlink" title="乱记"></a>乱记</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=3,b=2,c=1,d,f;</span><br><span class="line">cout&lt;&lt;(f=a&gt;b&gt;c)&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>输出结果为0。<br>f= a&gt;b&gt;c  —&gt;  a&gt;b为真，a&gt;b这一串变为1，但1&gt;c为假，所以输出为0。</p><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=1,b=0,c=123;</span><br><span class="line">cout&lt;&lt;(a&amp;&amp;b&amp;&amp;c++)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&apos;\n&apos;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">while(1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>输出结果为0、123。<br>原因是b为0，该表达式被短路，下一句(c++)不再被执行，因此c=123。</p><h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h2><p>？：称为条件运算符，就是表示?前的表达式的值是否为真，是的话取冒号前的值，否则取冒号后的值。<br>z = x&gt;y?x:y 含义是如果x&gt;y为真，那么把x的值赋给Z，否则把Y的值赋给Z。</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="优先级记忆口诀"><a href="#优先级记忆口诀" class="headerlink" title="优先级记忆口诀"></a>优先级记忆口诀</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">括号成员第一;        //括号运算符[]() 成员运算符.  -&gt;</span><br><span class="line"></span><br><span class="line">全体单目第二;        //所有的单目运算符比如++、 --、 +(正)、 -(负) 、指针运算*、&amp;乘除余三,加减四;   //这个&quot;余&quot;是指取余运算即%</span><br><span class="line"></span><br><span class="line">移位五，关系六;    //移位运算符：&lt;&lt; &gt;&gt; ，关系：&gt; &lt; &gt;= &lt;= 等</span><br><span class="line"></span><br><span class="line">等于(与)不等排第七;    //即== 和!=</span><br><span class="line"></span><br><span class="line">位与异或和位或;    //这几个都是位运算: 位与(&amp;)异或(^)位或(|)    </span><br><span class="line"></span><br><span class="line">&quot;三分天下&quot;八九十;  </span><br><span class="line"></span><br><span class="line">逻辑或跟与;            //逻辑运算符:|| 和 &amp;&amp;</span><br><span class="line"></span><br><span class="line">十二和十一;            //注意顺序:优先级(||)  底于 优先级(&amp;&amp;) </span><br><span class="line"></span><br><span class="line">条件高于赋值,        //三目运算符优先级排到13 位只比赋值运算符和&quot;,&quot;高</span><br><span class="line"></span><br><span class="line">逗号运算级最低!    //逗号运算符优先级最低</span><br></pre></td></tr></table></figure></code></pre><p>贴一个非常好的关于优先级的帖子：<a href="https://blog.csdn.net/u013630349/article/details/47444939" target="_blank" rel="noopener">https://blog.csdn.net/u013630349/article/details/47444939</a></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h3><ol><li>基本类型—字符型(char)、整型(int)、逻辑型(bool)、浮点型(float(单精度)\double(双精度))</li><li>引申类型—枚举类型、数组、指针、引用</li><li>构造类型—结构体类型、共用体类型、类</li></ol><h3 id="数据的字节数"><a href="#数据的字节数" class="headerlink" title="数据的字节数"></a>数据的字节数</h3><p>short — 2 (字节)<br>int      — 4<br>long  — 4</p><p>char  — 1</p><p>float — 4；小数点后6~7位<br>double— 8；小数点后15~16位</p><p>bool  — 1</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>包括：符号常量名、变量名、函数名、类型名。<br>命名规则：以<strong>字母、下划线开头</strong>，后跟字母、数字或下划线的字符序列。<br>注：大小写有区别、不能是系统中的关键字。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>在程序运行过程中，其值不能被改变的量。</p><h3 id="整型常量"><a href="#整型常量" class="headerlink" title="整型常量"></a>整型常量</h3><p>指不带小数点的常量。<br>十进制：以0~9开头的数字。<br>八进制：以0开头后面跟八进制数字。<br>十六进制：以0x或0X开头后面跟十六进制数字。</p><h3 id="实型常量-浮点型常量"><a href="#实型常量-浮点型常量" class="headerlink" title="实型常量(浮点型常量)"></a>实型常量(浮点型常量)</h3><p>指带小数点的常量。<br>默认为double型，在数字后加f表示float型。</p><ol><li>小数形式表示。1.23、2.23</li><li><p>指数形式表示(当实数型超百万后，自动以指数形式输出)<br>e、E表示以10为底的指数。e、E的两边分别为实型常量和指数部分,其中指数部分必须是整数。1.23e2、1.23e+2。<br>通过下面的语句可以将指数形式表示的数据转化为小数形式表示。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iomanip&gt;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;setiosflags(ios::fixed);</span><br></pre></td></tr></table></figure></li></ol><h3 id="字符型常量"><a href="#字符型常量" class="headerlink" title="字符型常量"></a>字符型常量</h3><p>指用<strong>单引号</strong>括起来的一个字符或一个转义字符。<br>字符常量在内存中以一;<br>字节的ASCII值的形式进行存储。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//转义字符</span><br><span class="line">\a---响铃</span><br><span class="line">\n---换行(下一行行首)</span><br><span class="line">\r---回车(本行行首)</span><br><span class="line">\b---退格</span><br><span class="line">\t---横向跳到下一个制表位</span><br><span class="line">\0---字符串结束标志</span><br><span class="line">\\---输出字符&apos;\&apos;</span><br><span class="line">\&apos;---输出字符&apos;</span><br><span class="line">\&quot;---输出字符&quot;</span><br><span class="line">\ddd---输出八进制代表的字符(\101代表A)</span><br><span class="line">\xhh---输出十六进制代表的字符(\x41代表A)</span><br></pre></td></tr></table></figure></code></pre><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>指用<strong>双引号</strong>括起来的若干字符。<br>注：</p><ol><li>字符串常量在内存中顺序存放，以’\0’(一个字节)作为结束标志，因此字符串至少占一个字节的内存。</li><li>“”称为空字符，为’\0’。</li></ol><h3 id="布尔常量"><a href="#布尔常量" class="headerlink" title="布尔常量"></a>布尔常量</h3><p>只有真(true)与假(false)。输出时分别用1和0表示。</p><h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><p>类似变量的常量。<br>声明方式有：</p><ol><li><p>用预处理命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define 符号常量 值常量</span><br><span class="line">//如：</span><br><span class="line">#define PI 3.1415926//结尾不带分号;</span><br></pre></td></tr></table></figure></li><li><p>用常量定义符号</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const 类型声明 符号常量 = 值常量；</span><br><span class="line">//如：</span><br><span class="line">const double PI = 3.1415926;</span><br></pre></td></tr></table></figure></li></ol><p>二者区别：</p><ol><li>define是在预处理时执行完毕的，而const是在执行语句时执行的。</li><li>define赋值无类型，因此<strong>不占内存</strong>，而cinst有类型，因此占内存。</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在程序运行过程中可以被多次赋值的量。<br>值得注意的是，不论赋值还是初始化，都在编译时根据变量的类型为变量分配存储空间，运行时再进行赋值。</p><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//一般语句形式</span><br><span class="line">数据类型 变量名1，变量名2,···,变量名n;</span><br></pre></td></tr></table></figure></code></pre><p>注：</p><ol><li>变量名不能是关键字。</li><li>先定义后使用。</li><li>只定义没赋值时，变量的值是不确定的。</li><li>变量可被多次赋值，得到的是最后一次的值。</li></ol><h3 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h3><p>变量赋值是把相应类型的数据送到变量所指定的存储空间的操作。<br>通过’=’来实现</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//一般形式为</span><br><span class="line">变量名 = 其值;</span><br></pre></td></tr></table></figure></code></pre><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>在定义变量的同时给变量赋值。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//一般形式为</span><br><span class="line">数据类型 变量名 = 表达式；</span><br><span class="line">数据类型 变量名 (表达式)；</span><br></pre></td></tr></table></figure></code></pre><h2 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h2><p>C将除了控制语句和输入输出对象以外几乎所有的基本操作都当作运算符处理，有运算符连接起来的式子称为表达式，表达式要在同一行上书写。<br>运算符包括：</p><blockquote><ol><li>算术运算符</li><li>赋值运算符</li><li>逗号运算符</li></ol></blockquote><p>着重关注：</p><ol><li>操作数的个数(目数)</li><li><p>优先级：</p><blockquote><p>优先级的数字越小，优先级越高。</p></blockquote></li><li><p>结合性：</p><blockquote><p>右结合性：自右向左进行计算。<br>左结合性：自左向右进行计算。</p></blockquote></li></ol><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>右结合性(一般为单目)<br> 名字    含义        优先级</p><ol><li><ul><li>取负        2</li></ul></li><li><ul><li>取正        2</li></ul></li><li>++    自增1    2</li><li>–    自减1    2<br>左结合性(一般为双目)</li><li><ul><li>乘        3</li></ul></li><li>/    除        3</li><li>%    取余        3</li><li><ul><li>加        3</li></ul></li><li><ul><li>减        3</li></ul></li></ol><h3 id="关于除法、取余"><a href="#关于除法、取余" class="headerlink" title="关于除法、取余"></a>关于除法、取余</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;5/2=&quot;&lt;&lt;5/2&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;2/5=&quot;&lt;&lt;2/5&lt;&lt;endl;//整数相除时，结果为整数</span><br><span class="line">cout&lt;&lt;&quot;5.0/2=&quot;&lt;&lt;5.0/2&lt;&lt;endl;//两数之中有一个是实型数时，结果为double型。</span><br><span class="line">cout&lt;&lt;&quot;5%2=&quot;&lt;&lt;5%2&lt;&lt;endl;//取余两边必须是整型数</span><br><span class="line">cout&lt;&lt;&quot;-5%2=&quot;&lt;&lt;-5%2&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;5%-2=&quot;&lt;&lt;5%-2&lt;&lt;endl;//余数的符号同被除数</span><br><span class="line">while(1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>输出</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5/2=2</span><br><span class="line">2/5=0</span><br><span class="line">5.0/2=2.5</span><br><span class="line">5%2=1</span><br><span class="line">-5%2=-1</span><br><span class="line">5%-2=1</span><br></pre></td></tr></table></figure></code></pre><h3 id="关于自增、自减"><a href="#关于自增、自减" class="headerlink" title="关于自增、自减"></a>关于自增、自减</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int k=0,i=1,j=1;</span><br><span class="line">k=++i;</span><br><span class="line">cout&lt;&lt;&quot;k=++i=&quot;&lt;&lt;k&lt;&lt;endl;//先加，再输出；相当于：i=i+1;k=i;</span><br><span class="line">k=0;</span><br><span class="line">k=j++;</span><br><span class="line">cout&lt;&lt;&quot;k=j++=&quot;&lt;&lt;k&lt;&lt;endl;//先输出，再加；相当于：k=j;j=j+1;</span><br><span class="line">while(1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>输出</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k=++i=2</span><br><span class="line">k=j++=1</span><br></pre></td></tr></table></figure></code></pre><p>2019/9/9 20:12:46 暂停，明天继续 P23<br>明天隔的有点久，2019/9/27 9:51:25 才开始继续弄。</p><h3 id="复合运算符"><a href="#复合运算符" class="headerlink" title="复合运算符"></a>复合运算符</h3><p>在赋值运算符前加上其他的运算符构成符合运算符。如：+=、-=、*=、/=。<br>各个符合运算符的含义：</p><ol><li>a+=b—-&gt;  a=a+b</li><li>a-=b—-&gt;  a=a-b</li><li><p>a<em>=b+1–&gt;  a=a</em>(b+1)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">a+=a-=a*2;</span><br></pre></td></tr></table></figure></li></ol><p>最终a=-10。</p><p>C的计算不是将式子列出来然后带入a=5进行计算，而是每一步计算出一个a值。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a-=a*2---&gt;a=a-a*2;//得到a=-5</span><br><span class="line">a+=a-----&gt;a=a+a;  //得到a=-10</span><br></pre></td></tr></table></figure></p><h3 id="逗号运算符和逗号表达式"><a href="#逗号运算符和逗号表达式" class="headerlink" title="逗号运算符和逗号表达式"></a>逗号运算符和逗号表达式</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int sorce,number=10;</span><br><span class="line">cout&lt;&lt;&quot;现有&quot;&lt;&lt;number&lt;&lt;&quot;门课未修&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;输入分数：&quot;;</span><br><span class="line">cin&gt;&gt;sorce;</span><br><span class="line">if(sorce&gt;=60)</span><br><span class="line">&#123;</span><br><span class="line">number--,cout&lt;&lt;&quot;及格&quot;&lt;&lt;&quot;还剩&quot;&lt;&lt;number&lt;&lt;&quot;门课未修&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;该门课程未通过&quot;&lt;&lt;&quot;还剩&quot;&lt;&lt;number&lt;&lt;&quot;门课未修&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>C语言中的逗号运算符可以将多个表达式合并成为一个表达式。<br>如：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表达式1,表达式2,表达式3；//等价于</span><br><span class="line">表达式1;</span><br><span class="line">表达式2;</span><br><span class="line">表达式3;</span><br></pre></td></tr></table></figure></p><h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><ol><li>逗号运算符具有左结合性，并为最低优先级。</li><li>从左至右执行每一个表达式，最后一个表达式的值是整个逗号表达式的值,逗号表达式的值不影响单个表达式的值。</li><li>逗号表达式可以用于for()循环<blockquote><p>例如：for(i=0,j=0;i&lt;5;i++,j++)</p></blockquote></li></ol><h4 id="易错误区"><a href="#易错误区" class="headerlink" title="易错误区"></a>易错误区</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a,b</span><br><span class="line">x = (a=2,a++;b=a+1);//x=4,a++将值赋给了a，a=3，b=a+1，x=b=4</span><br><span class="line">y = (a=2,a+1,b=a+1);//x=3,a+1将值赋给了逗号表达式，a=2，y=b=a+1,y=3</span><br></pre></td></tr></table></figure></code></pre><h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><p>sizeof运算符用于计算数据类型(int,char等)、变量、数组或数组元素所占内存的字节数。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a,b[5];</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;&quot;整型数占内存字节数=&quot;&lt;&lt;sizeof(int)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;整型变量占内存字节数=&quot;&lt;&lt;sizeof(a)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;数组占内存字节数=&quot;&lt;&lt;sizeof(b)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;一个数组元素占内存字节数=&quot;&lt;&lt;sizeof(b[0])&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;数组元素的个数=&quot;&lt;&lt;sizeof(b)/sizeof(b[0])&lt;&lt;endl;//计算数组元素个数的方法。</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><p>C中数据转换可以分为自动转换、强制转换和复制转换。</p><h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><p>在进行运算时，不同类型的数据会西安自动转换成同一类型的数据，然后进行运算。<br>主要规则：</p><ol><li>低精度与高精度进行运算时，低精度转换为高精度的。</li><li>char\short型与不同类型的数据进行运算时，首先转换成int型。</li><li>float型与其他类型数据运算时，首先转换成double型。</li></ol><p>例程：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i=2;</span><br><span class="line">float f=3.14f;</span><br><span class="line">double d = 3.14;</span><br><span class="line">char c=&apos;A&apos;;</span><br><span class="line"> </span><br><span class="line">cout&lt;&lt;&quot;整型与字符型运算的结果=&quot;&lt;&lt;i+c&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;整型与单精度型运算的结果=&quot;&lt;&lt;i+f&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;整型与双精度型运算的结果=&quot;&lt;&lt;i+d&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;整型与单精度、双精度运算的结果=&quot;&lt;&lt;i+d+f&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;整型与单精度、双精度、字符型运算的结果=&quot;&lt;&lt;i+d+f+c&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">整型与字符型运算的结果=67</span><br><span class="line">整型与单精度型运算的结果=5.14</span><br><span class="line">整型与双精度型运算的结果=5.14</span><br><span class="line">整型与单精度、双精度运算的结果=8.28</span><br><span class="line">整型与单精度、双精度、字符型运算的结果=73.28</span><br></pre></td></tr></table></figure></p><p>只要由实型数据(带有小数的)数据参与，结果为双精度。</p><h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>可以将一个表达式的值强制转换为另一种类型。<br>格式如下：</p><ol><li>(类型名)表达式</li><li>类型名(表达式)<br><strong>值得注意的是，强制转换得到的是一个临时的值，表达式本身的值和类型并不改变。</strong><br>例程 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double a=1.5,b=2.5;</span><br><span class="line">c=(int)a%(int)b;//转换为int后，直接舍弃小数，1.5--&gt;1;  2.5--&gt;2</span><br><span class="line">//最终得c=1，而a，b的值并不改变</span><br></pre></td></tr></table></figure></li></ol><h3 id="赋值转换"><a href="#赋值转换" class="headerlink" title="赋值转换"></a>赋值转换</h3><p>复制转换是指等式两边类型不一致时的转换。<br>规则：<br>变量 = 表达式</p><ol><li>表达式类型转换为变量的类型。</li><li>将表达式的值转换为左侧变量类型后赋值给变量。</li><li>表达式的值超出变量类型范围则出错。</li><li>表达式本身的值和类型不变。<br>例程 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a,c=2;</span><br><span class="line">double b=3.14;</span><br><span class="line">a=b;//a=3，b还是3.14</span><br><span class="line">b=c;//b=2.0，c还是2</span><br><span class="line">a=&apos;A&apos;;//a=65(A的asc码)</span><br></pre></td></tr></table></figure></li></ol><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int num=5;//学号5</span><br><span class="line">int english,math,computer,sum;//各学科分数和总分</span><br><span class="line">double ping;//平均分</span><br><span class="line">cout&lt;&lt;&quot;输入英语分数&quot;;</span><br><span class="line">cin&gt;&gt;english;</span><br><span class="line">cout&lt;&lt;&quot;输入数学分数&quot;;</span><br><span class="line">cin&gt;&gt;math;</span><br><span class="line">cout&lt;&lt;&quot;输入计算机分数&quot;;</span><br><span class="line">cin&gt;&gt;computer;</span><br><span class="line">sum = english+math+computer;</span><br><span class="line">ping = sum/3.0;</span><br><span class="line">ping = int(ping*100)/100.0;//保留小数点后两位</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;num&lt;&lt;&quot;号学生总分为&quot;&lt;&lt;sum&lt;&lt;&quot;平均分为&quot;&lt;&lt;ping&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现小写转大写</span></span><br><span class="line"><span class="comment">//大写比小写的asc码大32</span></span><br><span class="line"><span class="comment">//strlen要包含头文件string.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((s[i]&gt;=<span class="string">'a'</span>) &amp;&amp; (s[i]&lt;=<span class="string">'z'</span>)) </span><br><span class="line">&#123;s[i]=s[i] - <span class="string">'a'</span>+ <span class="string">'A'</span>;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">80</span>] = <span class="string">"abdsaFDSAFdsafASFDSafghHFDHTjte"</span>;</span><br><span class="line">fun(s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求素数的算法"><a href="#求素数的算法" class="headerlink" title="求素数的算法"></a>求素数的算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编写程序实现以下功能：计算并输出100以内最大的10个素数之和，100由主函数传给fun()函数，在fun()函数中实现查找和求和并返回主函数。</span><br><span class="line">输入信息格式要求：无</span><br><span class="line">输出信息格式要求：cout&lt;&lt;&quot;100以内最大的十个素数之和为：&quot;&lt;&lt;fun(100)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, n = <span class="number">0</span>, j, yes;</span><br><span class="line">    <span class="keyword">while</span> ((high &gt;= <span class="number">2</span>) &amp;&amp; (n &lt; <span class="number">10</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        yes = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= high / <span class="number">2</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (high % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                yes = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (yes)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += high;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        high--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"100以内最大的十个素数之和为："</span> &lt;&lt; fun(<span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数求和"><a href="#函数求和" class="headerlink" title="函数求和"></a>函数求和</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数fun的功能是：计算并输出k以内最大的10个能被13或17整除的自然数之和。k的值由主函数传入，若k的值为500，则函数值为4622。</span><br><span class="line">输入格式信息要求:无</span><br><span class="line">输出格式信息要求:cout&lt;&lt;fun(500)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>, mc = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">2</span> &lt;= k) &amp;&amp; (mc &lt; <span class="number">10</span>))</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ((k % <span class="number">13</span> == <span class="number">0</span>) || (k % <span class="number">17</span> == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            m = m + k;</span><br><span class="line">            mc++;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> m ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fun(<span class="number">500</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用循环求N位数的每一位"><a href="#用循环求N位数的每一位" class="headerlink" title="用循环求N位数的每一位"></a>用循环求N位数的每一位</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> m, s = <span class="number">0</span>, n;</span><br><span class="line">   m = <span class="number">252</span>;</span><br><span class="line">   <span class="keyword">while</span> ( m != <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     n = m % <span class="number">10</span>;</span><br><span class="line">     s += n;</span><br><span class="line">     m = m / <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt;<span class="string">"s="</span>&lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系统学习C语言，准备国二。&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://linmushen.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>模型模板</title>
    <link href="http://linmushen.com/2019/09/06/%E6%A8%A1%E5%9E%8B%E6%A8%A1%E6%9D%BF/"/>
    <id>http://linmushen.com/2019/09/06/模型模板/</id>
    <published>2019-09-06T06:54:24.000Z</published>
    <updated>2019-09-08T13:06:47.147Z</updated>
    
    <content type="html"><![CDATA[<p>方便比赛，做几个模板<br><a id="more"></a></p><h1 id="层次分析"><a href="#层次分析" class="headerlink" title="层次分析"></a>层次分析</h1><ol><li>选取指标</li><li>指标量化<br><img src="https://i.imgur.com/HlRPCXX.png" alt></li><li>计算权重(这一步既可以用来说明指标正确(都不为0，或不为可以忽略的数)也可以用来评价哪一个好)</li><li><h1 id="灰色预测"><a href="#灰色预测" class="headerlink" title="灰色预测"></a>灰色预测</h1><h2 id="GM-1-1"><a href="#GM-1-1" class="headerlink" title="GM(1,1)"></a>GM(1,1)</h2><p>需要输入需要预测的数据到data。<br>GM(1,1)只有一个自变量，因此他的预测自变量被默认为连续的、符合1，2，3，4….的。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line">%导入数据，并将数据转化为行向量,数据一定要用行向量</span><br><span class="line">[~,~,raw] = xlsread(&apos;表格名称&apos;,&apos;Sheet1&apos;); </span><br><span class="line">data = reshape([raw&#123;:&#125;],size(raw)); </span><br><span class="line">   n = size(data,2);%输出数据的列数</span><br><span class="line"></span><br><span class="line">%对数据进行处理</span><br><span class="line">   x1 = data&apos;;        </span><br><span class="line">   x2 = cumsum(data)&apos;;%进行累加</span><br><span class="line"></span><br><span class="line">   %求微分方程的系数</span><br><span class="line">   B = [-0.5*(x1(1:n-1)+x2(2:n)),ones(n-1,1)];</span><br><span class="line">   Y = data(2:n)&apos;;</span><br><span class="line">   u = B\Y;</span><br><span class="line"></span><br><span class="line">%构建微分方程</span><br><span class="line">   syms x(t)</span><br><span class="line">   x = dsolve(diff(x)+u(1)*x==u(2),x(0) == data(1));   %求得微分方程符号解</span><br><span class="line">   xt = vpa(x,n-1)   %以小数形式显示出来</span><br><span class="line"></span><br><span class="line">%检验部分</span><br><span class="line">   yuce = subs(xt,t,[0:n-1]);     %将已知值对应的序号带入，用来测试</span><br><span class="line">   yuce =double(yuce);          %转化为数值类型，便于进行差分（预测值）</span><br><span class="line">   yuce = [data(1),diff(yuce)]  %进行差分运算（得到预测值）</span><br><span class="line">   cancha = data-yuce; %计算残差</span><br><span class="line">   xiangduiwucha = abs(cancha./data)   %计算相对误差</span><br><span class="line"></span><br><span class="line">   %预测得值部分</span><br><span class="line">   yuce1 = subs(xt,t,[0:19]);</span><br><span class="line">   yuce1 =double(yuce1);</span><br><span class="line">   yuce1 = [data(1),diff(yuce1)]</span><br></pre></td></tr></table></figure></li></ol><h2 id="GM-1-N"><a href="#GM-1-N" class="headerlink" title="GM(1,N)"></a>GM(1,N)</h2><p>需要输入因变量数据、自变量1的数据、自变量2的数据。<br>需要输入预测值对应情况的自变量1的值、自变量2的值。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">%本例为GM(1,N)灰色预测模型</span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line">%导入数据，并将数据转化为行向量,数据一定要用行向量</span><br><span class="line">data = [];     %因变量，最终要进行预测的量</span><br><span class="line">x0 =[];   %自变量1</span><br><span class="line">x2 =[];   %自变量2</span><br><span class="line"></span><br><span class="line">n = size(data,2);  %计算因变量长度</span><br><span class="line"></span><br><span class="line">%检测数据是否可以进行灰色预测（可以省略）</span><br><span class="line">jibi = data(1:n-1)./data(2:n);    %计算需要预测的数据的级比</span><br><span class="line">%a = exp(-2/(n+1))</span><br><span class="line">%b = exp(2/(n+1))     %计算检验值</span><br><span class="line"></span><br><span class="line">%对数据进行处理部分</span><br><span class="line">data1 = cumsum(data);  </span><br><span class="line">x11 = cumsum(x0);</span><br><span class="line">x21 = cumsum(x2);        %进行三次累加，得到累加数据集</span><br><span class="line">for i = 1:4</span><br><span class="line">    data2(i) = (data1(i)+data1(i+1))/2;</span><br><span class="line">end          %生成一个临近数据集</span><br><span class="line">B = [-data2(1:n-1)&apos; x11(2:n)&apos; x21(2:n)&apos;]; %构造数据矩阵</span><br><span class="line">Y = data(2:n);</span><br><span class="line"></span><br><span class="line">u = B\Y&apos;;%微分方程的系数</span><br><span class="line"></span><br><span class="line">%构建微分方程部分</span><br><span class="line">syms x(t)</span><br><span class="line">x1 = dsolve(&apos;Dx1+a*x1 == b2*x2+b3*x3&apos;,&apos;x1(0)==x10&apos;);   %求得微分方程形式</span><br><span class="line">x1 = subs(x1,&#123;&apos;a&apos;,&apos;b2&apos;,&apos;b3&apos;,&apos;x10&apos;&#125;,&#123;u(1),u(2),u(3),data(1,1)&#125;);</span><br><span class="line">x1_s1 = vpa(x1,9)</span><br><span class="line">x1_s2 = vpa(simplify(x1),9)</span><br><span class="line">x1_s3 = vpa(expand(x1),9)       %时间响应方程</span><br><span class="line"></span><br><span class="line">%做带有预测数据的数据集</span><br><span class="line">x20 = [x0,预测情况对应的x1];</span><br><span class="line">x30 = [x2,预测情况对应的x2];%输入需要预测值的情况，比如x1 = 500,x2 = 400,写在对应位置</span><br><span class="line">x22 = cumsum(x20);</span><br><span class="line">x32 = cumsum(x30);%再创建一遍新累加数列</span><br><span class="line"></span><br><span class="line">%进行求解</span><br><span class="line">x1 = subs(x1,&#123;&apos;t&apos;,&apos;x2&apos;,&apos;x3&apos;&#125;,&#123;[0:n],x22,x32&#125;)</span><br><span class="line">x1 = double(x1)     %求出的是预测值的之间的差值，需要还原一步</span><br><span class="line">x10hat = [x1(1),diff(x1)]       %进行还原</span><br><span class="line"></span><br><span class="line">% 检验部分</span><br><span class="line">cancha = x0(1,:) - x10hat(1:end-1);    %计算残差</span><br><span class="line">disp(&quot;残差为&quot;)</span><br><span class="line">disp(cancha)</span><br><span class="line">xiangduiwucha = abs(cancha./x0(1,:));   %计算相对误差</span><br><span class="line">disp(&quot;相对误差为&quot;)</span><br><span class="line">disp(xiangduiwucha)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xhat = x10hat(end);      %给出最终预测结果</span><br><span class="line">disp(&quot;预测结果为&quot;)</span><br><span class="line">disp(xhat)</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;方便比赛，做几个模板&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>习题练习</title>
    <link href="http://linmushen.com/2019/08/31/%E4%B9%A0%E9%A2%98%E7%BB%83%E4%B9%A0/"/>
    <id>http://linmushen.com/2019/08/31/习题练习/</id>
    <published>2019-08-31T06:15:14.000Z</published>
    <updated>2019-09-06T06:53:25.797Z</updated>
    
    <content type="html"><![CDATA[<p>在大致学习了几类数学建模的模型和算法后，我决定开始做题试一试。<br>本节笔记例题均来自司守奎的算法与应用。<br><a id="more"></a></p><h1 id="第一章—线性规划"><a href="#第一章—线性规划" class="headerlink" title="第一章—线性规划"></a>第一章—线性规划</h1><p>线性规划问题是在一组线性约束条件限制下，求一线性目标函数最大或最小值的问题</p><h2 id="例题代码实现"><a href="#例题代码实现" class="headerlink" title="例题代码实现"></a>例题代码实现</h2><h3 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1.1"></a>例题1.1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">%习题1</span><br><span class="line"></span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">A1 = [1,-2,1;4,-1,-2];  %创建系数矩阵1(小于部分的系数)</span><br><span class="line">A2 = [-2,0,1];          %创建系数矩阵2(等于部分的系数)</span><br><span class="line">B1 = [11;-3];            %创建常数矩阵1</span><br><span class="line">B2 = [1];               %创建常数矩阵2</span><br><span class="line">f = [-3,1,1];           %目标函数系数矩阵</span><br><span class="line"></span><br><span class="line">%求解线性规划</span><br><span class="line">%[x,fval] = linprog(f,A,b,Aeq,Beq,lb,ub);</span><br><span class="line">%x为决策变量取值，fval为最优解；</span><br><span class="line">%f为目标函数的系数矩阵，A，b为不等式约束条件的系数矩阵、常数项矩阵；</span><br><span class="line">%Aeq,Beq为等式约束条件；</span><br><span class="line">%后面两个数为决策变量上下域</span><br><span class="line"></span><br><span class="line">[x,fval] = linprog(f,A1,B1,A2,B2,0);</span><br><span class="line"></span><br><span class="line">%由于Matlab算法解得的是最小值，所以需要进行一步转换</span><br><span class="line"></span><br><span class="line">fval = - fval;</span><br><span class="line">disp(&quot;当x为&quot;)</span><br><span class="line">disp(x)</span><br><span class="line">disp(&quot;时，取得最优解&quot;)</span><br><span class="line">disp(&quot;   &quot;)</span><br><span class="line">disp(&quot;最优解为&quot;)</span><br><span class="line">disp(fval)</span><br></pre></td></tr></table></figure><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当x为</span><br><span class="line">    4.0000</span><br><span class="line">    1.0000</span><br><span class="line">    9.0000</span><br><span class="line"></span><br><span class="line">时，取得最优解</span><br><span class="line">   </span><br><span class="line">最优解为</span><br><span class="line">    2.0000</span><br></pre></td></tr></table></figure></p><h3 id="例题1-2"><a href="#例题1-2" class="headerlink" title="例题1.2"></a>例题1.2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%习题2，转化为线性规划的问题</span><br><span class="line">%核心思想是将xi的绝对值进行转化---ui=(xi+|xi|)/2;vi=(xi-|xi|)/2</span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">f = 1:4;</span><br><span class="line">f = [f,f];      %目标函数系数矩阵，翻倍</span><br><span class="line">A1 = [1,-1,-1,1;1,-1,1,-3;1,-1,-2,3];</span><br><span class="line">%xi = ui-vi;因此vi的系数要取相反值</span><br><span class="line">A1 = [A1,-A1];   %等式部分的系数矩阵</span><br><span class="line">%常数项矩阵不变</span><br><span class="line">B = [0;1;-1/2]; %等使部分的常数项矩阵</span><br><span class="line">%分别求u，v的解，并将两个矩阵合并,其中xi，vi均大于0。</span><br><span class="line">[uv,fval] = linprog(f,[],[],A1,B,zeros(8,1))</span><br><span class="line">%依据xi = ui-vi来求得x。</span><br><span class="line">x = uv(1:4)-uv(5:8)</span><br></pre></td></tr></table></figure><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x =</span><br><span class="line"></span><br><span class="line">    0.2500         0         0   -0.2500</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fval =</span><br><span class="line"></span><br><span class="line">    1.2500</span><br></pre></td></tr></table></figure></p><h3 id="例题1-3"><a href="#例题1-3" class="headerlink" title="例题1.3"></a>例题1.3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%习题3</span><br><span class="line">%主要时系数比较难算，而且“设备有效台时”，“满负荷时的设备费用”等名词需要查阅确定其含义</span><br><span class="line"></span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">A1 = [5 0 0 0 0 10 0 0 0;0 7 0 0 0 0 9 0 12;0 0 6 0 0 0 0 8 0;0 0 0 4 0 0 0 0 11;0 0 0 0 7 0 0 0 0];</span><br><span class="line">A2 = [1 1 -1 -1 -1 0 0 0 0;0 0 0 0 0 1 1 -1 0];</span><br><span class="line">B1 = [6000;10000;4000;7000;4000];</span><br><span class="line">B2 = [0;0];</span><br><span class="line">F = [-0.75 -0.7753 0.375 0.4448 0.35 0.5 0.2889 -1.15 2.675];</span><br><span class="line">C = zeros(9,1);</span><br><span class="line">[x,fval] = linprog(F,A1,B1,A2,B2,C);</span><br><span class="line">x</span><br><span class="line">fval =-fval</span><br></pre></td></tr></table></figure><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x =</span><br><span class="line"></span><br><span class="line">   1.0e+03 *</span><br><span class="line"></span><br><span class="line">   1.2000    0.7857    0    1.4143    0.5714    0    0.5000    0.5000    0</span><br><span class="line"></span><br><span class="line">fval =</span><br><span class="line"></span><br><span class="line">   1.1106e+03</span><br></pre></td></tr></table></figure></p><p>2019/8/31 17:24:59 </p><h3 id="例题1-4"><a href="#例题1-4" class="headerlink" title="例题1.4"></a>例题1.4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">A1 = [</span><br><span class="line">    0 0 0 26.67 0 0 43.33 0 0 25.22 0 0 32.5 0 0;</span><br><span class="line">    0 0 0 0 26.67 0 0 43.33 0 0 25.22 0 0 32.5 0;</span><br><span class="line">    0 0 0 0 0 26.67 0 0 43.33 0 0 25.22 0 0 32.5;   %货舱对其体积的限制</span><br><span class="line">    0 0 0 1 0 0 1 0 0 1 0 0 1 0 0;</span><br><span class="line">    0 0 0 0 1 0 0 1 0 0 1 0 0 1 0;</span><br><span class="line">    0 0 0 0 0 1 0 0 1 0 0 1 0 0 1;      %货舱对其重量的限制</span><br><span class="line">    0 0 0 1 1 1 0 0 0 0 0 0 0 0 0;</span><br><span class="line">    0 0 0 0 0 0 1 1 1 0 0 0 0 0 0;</span><br><span class="line">    0 0 0 0 0 0 0 0 0 1 1 1 0 0 0;</span><br><span class="line">    0 0 0 0 0 0 0 0 0 0 0 0 1 1 1];%货物的重量约束</span><br><span class="line"></span><br><span class="line">B1 = [6800;8700;5300;</span><br><span class="line">    10;16;8;</span><br><span class="line">    18;15;23;12];</span><br><span class="line"></span><br><span class="line">A2 = [</span><br><span class="line">    -1 0 0 1 0 0 1 0 0 1 0 0 1 0 0;</span><br><span class="line">    0 -1 0 0 1 0 0 1 0 0 1 0 0 1 0;</span><br><span class="line">    0 0 -1 0 0 1 0 0 1 0 0 1 0 0 1;     %在i货舱的货物质量之和等于i货舱货物质量</span><br><span class="line">    8 -5 0 0 0 0 0 0 0 0 0 0 0 0 0;</span><br><span class="line">    4 0 -5 0 0 0 0 0 0 0 0 0 0 0 0;</span><br><span class="line">    0 4 -8 0 0 0 0 0 0 0 0 0 0 0 0];    %平衡条件</span><br><span class="line"></span><br><span class="line">B2 = [0;0;0;0;0;0];</span><br><span class="line"></span><br><span class="line">C = zeros(15,1);    %确保每一个数大于0</span><br><span class="line">%f = [0 0 0 172.22 172.22 172.22 253.33 253.33 253.33 152.17 152.17 152.17 237.5 237.5 237.5];</span><br><span class="line">f = [0 0 0 3100 3100 3100 3800 3800 3800 3500 3500 3500 2850 2850 2850];</span><br><span class="line">f = -f;</span><br><span class="line">[x,fval] = linprog(f,A1,B1,A2,B2,C);</span><br><span class="line">fval = -fval;</span><br><span class="line">disp(&quot;最大利润为&quot;)</span><br><span class="line">disp(fval)</span><br><span class="line">disp(&quot;货物1的质量&quot;);</span><br><span class="line">disp(x(4)+x(5)+x(6))</span><br><span class="line">disp(&quot;货物2的质量&quot;);</span><br><span class="line">disp(x(7)+x(8)+x(9))</span><br><span class="line">disp(&quot;货物3的质量&quot;);</span><br><span class="line">disp(x(10)+x(11)+x(12))</span><br><span class="line">disp(&quot;货物4的质量&quot;);</span><br><span class="line">disp(x(13)+x(14)+x(15))</span><br><span class="line">disp(&quot;货舱1的质量&quot;)</span><br><span class="line">disp(x(1))</span><br><span class="line">disp(&quot;货舱2的质量&quot;)</span><br><span class="line">disp(x(2))</span><br><span class="line">disp(&quot;货舱3的质量&quot;)</span><br><span class="line">disp(x(3))</span><br></pre></td></tr></table></figure><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">最大利润为</span><br><span class="line">   123500</span><br><span class="line"></span><br><span class="line">货物1的质量</span><br><span class="line">     0</span><br><span class="line"></span><br><span class="line">货物2的质量</span><br><span class="line">   15.0000</span><br><span class="line"></span><br><span class="line">货物3的质量</span><br><span class="line">   19.0000</span><br><span class="line"></span><br><span class="line">货物4的质量</span><br><span class="line">     0</span><br><span class="line"></span><br><span class="line">货舱1的质量</span><br><span class="line">    10</span><br><span class="line"></span><br><span class="line">货舱2的质量</span><br><span class="line">    16</span><br><span class="line"></span><br><span class="line">货舱3的质量</span><br><span class="line">     8</span><br></pre></td></tr></table></figure></p><p>不知道为啥，解出了一个比书上更优的解</p><h1 id="第二章—整数规划"><a href="#第二章—整数规划" class="headerlink" title="第二章—整数规划"></a>第二章—整数规划</h1><p>数学规划中的变量(全部或部分)限制为整数时，成为(纯或混合)整数规划。(求解得到的答案也要是整数的)</p><h2 id="0-1型整数规划"><a href="#0-1型整数规划" class="headerlink" title="0-1型整数规划"></a>0-1型整数规划</h2><p>主要难在判断有哪些0-1变量。<br>有多少种情况就要有多少个判断变量。</p><h3 id="习题2-1"><a href="#习题2-1" class="headerlink" title="习题2.1"></a>习题2.1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">f = [1 1 1 1 1 1];</span><br><span class="line">A = [</span><br><span class="line">    1 1 1 0 0 0;</span><br><span class="line">    0 1 0 1 0 0;</span><br><span class="line">    0 0 1 0 1 0;</span><br><span class="line">    0 0 0 1 0 1;</span><br><span class="line">    0 0 0 0 1 1;</span><br><span class="line">    1 0 0 0 0 0;</span><br><span class="line">    0 1 0 1 0 1];</span><br><span class="line">A1 = -A;</span><br><span class="line">B1 = [-1;-1;-1;-1;-1;-1;-1];</span><br><span class="line">C =zeros(1,6);</span><br><span class="line">D = ones(1,6);</span><br><span class="line">[x,fval] = linprog(f,A1,B1,[],[],C);</span><br><span class="line">disp(&quot;最少可修建&quot;)</span><br><span class="line">disp(fval)</span><br><span class="line">disp(&quot;座小学&quot;)</span><br><span class="line">disp(&quot;他们分别是&quot;)</span><br><span class="line">disp(x&apos;)</span><br></pre></td></tr></table></figure><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最少可修建</span><br><span class="line">     3</span><br><span class="line"></span><br><span class="line">座小学</span><br><span class="line">他们分别是B1,B4,B5</span><br></pre></td></tr></table></figure></p><p>可能是我这道题很简单，所以我觉得本质还是线性规划，只是限定了一下区间。</p><h3 id="习题2-2"><a href="#习题2-2" class="headerlink" title="习题2.2"></a>习题2.2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">%习题2.2</span><br><span class="line">%0-1规划</span><br><span class="line">%比较好算，没什么可注释的</span><br><span class="line">A1 = [</span><br><span class="line">    1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0;</span><br><span class="line">    0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0;</span><br><span class="line">    0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0;</span><br><span class="line">    0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1;</span><br><span class="line">    ];</span><br><span class="line">A1 = -A1;</span><br><span class="line">A2 = [</span><br><span class="line">    1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;</span><br><span class="line">    0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;    </span><br><span class="line">    0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0;</span><br><span class="line">    0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0;</span><br><span class="line">    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0;</span><br><span class="line">    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1;</span><br><span class="line">    ];</span><br><span class="line">B1 = [1;1;1;1];</span><br><span class="line">B2 = [1;1;1;1;1;1];</span><br><span class="line">C = zeros(24,1);</span><br><span class="line">D = ones(24,1);</span><br><span class="line">f = [4 2 3 4 6 4 5 5 7 6 7 6 7 8 8 6 7 9 8 6 7 10 8 6];</span><br><span class="line">f = -f</span><br><span class="line">[x,fval] = linprog(f,A1,B1,A2,B2,C,D);</span><br><span class="line">disp(&quot;最大利润为&quot;)</span><br><span class="line">fval = -fval</span><br><span class="line">disp(&quot;分配矩阵为&quot;)</span><br><span class="line">x&apos;</span><br></pre></td></tr></table></figure><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">最大利润为</span><br><span class="line"></span><br><span class="line">fval =</span><br><span class="line"></span><br><span class="line">    44</span><br><span class="line"></span><br><span class="line">分配矩阵为</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line">     0     0     0     1</span><br><span class="line">   1     0     0     0  </span><br><span class="line">  0     0 1     0</span><br><span class="line">     0     0     1     0</span><br><span class="line">     0     1     0     0</span><br><span class="line">     0     1     0     0</span><br></pre></td></tr></table></figure></p><h3 id="习题2-3"><a href="#习题2-3" class="headerlink" title="习题2.3"></a>习题2.3</h3><p>第一问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">f = [</span><br><span class="line">8.4 9.3 8.4 8.1 8.4 9.4 9.5 8.4 8.4 9.0</span><br><span class="line">8.4 8.4 8.1 8.7 9.0 8.7 8.4 8.8 8.4 8.1</span><br><span class="line">9.1 8.4 8.4 9.0 8.3 8.5 8.3 8.7 8.4 8.2</span><br><span class="line">8.7 8.9 9.5 8.4 9.4 8.4 8.4 8.2 9.3 9.1</span><br><span class="line">];  %系数矩阵</span><br><span class="line">A1 = [</span><br><span class="line">1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1</span><br><span class="line">];</span><br><span class="line">B1  = [</span><br><span class="line">6;6;6;6;3;3;3;3;3;3;3;3;3;3</span><br><span class="line">];</span><br><span class="line">A2 = [</span><br><span class="line">1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0;</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; %2</span><br><span class="line">0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 ; %3</span><br><span class="line">0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 ;%4</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;%5</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;%6</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;%7</span><br><span class="line">0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0;%8</span><br><span class="line">0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0;%9</span><br><span class="line">0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 %10</span><br><span class="line">];</span><br><span class="line">A3 =[</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; %1</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; %2</span><br><span class="line">0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 ; %3</span><br><span class="line">0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 ;%4</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;%5</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;%6</span><br><span class="line">0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0;%7</span><br><span class="line">0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0;%8</span><br><span class="line">0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0;%9</span><br><span class="line">0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 %10</span><br><span class="line">];</span><br><span class="line">a1 = [</span><br><span class="line">0 1 0 0 1 1 1 0 0 0 0 1 0 0 1 1 1 0 0 0 0 1 0 0 1 1 1 0 0 0 0 1 0 0 1 1 1 0 0 0];</span><br><span class="line">b1 = [16];</span><br><span class="line">A4 = [A1;A2];</span><br><span class="line">A5 = [A1;A3];</span><br><span class="line">[x,fval]=linprog(-f,A4,B1,a1 ,b1,zeros(40,1),ones(40,1));</span><br><span class="line">a = -fval</span><br><span class="line">%[x,fval] = linprog(-f,A5,B1,a1,b1,zeros(40,1),ones(40,1));</span><br><span class="line">%b = -fval</span><br></pre></td></tr></table></figure></p><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最优解为：212.0000</span><br></pre></td></tr></table></figure></p><p>第二问：</p><h1 id="第三章—非线性规划"><a href="#第三章—非线性规划" class="headerlink" title="第三章—非线性规划"></a>第三章—非线性规划</h1><p>目标函数或约束条件中包含非线性函数的规划问题叫非线性规划问题。</p><h1 id="第四章—预测方法"><a href="#第四章—预测方法" class="headerlink" title="第四章—预测方法"></a>第四章—预测方法</h1><h2 id="插值法"><a href="#插值法" class="headerlink" title="插值法"></a>插值法</h2><h3 id="习题4-1"><a href="#习题4-1" class="headerlink" title="习题4.1"></a>习题4.1</h3><p>本题通过插值法求出步长0.1下对应的每一个速度点，进而得出图像</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">% 第一段时间部分</span><br><span class="line">y1 = [9.68 9.48 9.31 9.13 8.98 8.81 8.69 8.52 8.39 8.22];   %第一个时间段水位的高度</span><br><span class="line">xce = [0:0.1:8.22]; %需要预测的时间段</span><br><span class="line">x1 = [0 0.92 1.84 2.95 3.87 4.98 5.9 7.01 7.93 8.97];   %已知的时刻</span><br><span class="line"></span><br><span class="line">%p1 = pchip(x1,y1,xce);</span><br><span class="line">y1 = y1*pi/4*302.76;    %每时刻对应水的体积</span><br><span class="line">v = gradient(y1&apos;,x1&apos;)   %每时刻对应的水流速度</span><br><span class="line">v1 = pchip(x1,v,xce);   %将所有时刻的速度计算出来</span><br><span class="line">figure(1)</span><br><span class="line">plot(xce,-v1,&apos;r&apos;)</span><br><span class="line"></span><br><span class="line">%第二段时间部分</span><br><span class="line">x2 = [10.95 12.03 12.95 13.88 14.98 15.9 16.83 17.93 19.04 19.96 20.84 ];   %第二段时间中的时刻</span><br><span class="line">y2 = [10.82 10.5 10.21 9.94 9.65 9.41 9.18 8.92 8.66 8.43 8.22];</span><br><span class="line">xce2 = [10.95:0.1:20.84];   %第二次的时间段</span><br><span class="line"></span><br><span class="line">y2 = y2*pi/4*302.76;    %每时刻对应水的体积</span><br><span class="line">v2 = gradient(y2&apos;,x2&apos;)   %每时刻对应的水流速度</span><br><span class="line">v2 = pchip(x2,v2,xce2);   %将所有时刻的速度计算出来</span><br><span class="line">figure(2)</span><br><span class="line">plot(xce2,-v2,&apos;g&apos;)</span><br><span class="line"></span><br><span class="line">%第三段时间部分</span><br><span class="line">x3 = [23.88 24.99 25.91];</span><br><span class="line">y3 = [10.59 10.35 10.18];</span><br><span class="line">xce3 = [23.88:0.1:25.91];</span><br><span class="line">y3 = y3*pi/4*302.76;    %每时刻对应水的体积</span><br><span class="line">v3 = gradient(y3&apos;,x3&apos;)   %每时刻对应的水流速度</span><br><span class="line">v3 = pchip(x3,v3,xce3);   %将所有时刻的速度计算出来</span><br><span class="line">figure(3)</span><br><span class="line">plot(xce3,-v3)</span><br><span class="line"></span><br><span class="line">%绘制总体图</span><br><span class="line">x = [xce xce2 xce3];</span><br><span class="line">V = [-v1 -v2 -v3];</span><br><span class="line">figure(4)</span><br><span class="line">plot(x,V,&apos;r&apos;)</span><br></pre></td></tr></table></figure></code></pre><p>解得图像<br><img src="https://i.imgur.com/pBMYPFs.png" alt></p><h2 id="拟合法"><a href="#拟合法" class="headerlink" title="拟合法"></a>拟合法</h2><h3 id="习题1-1"><a href="#习题1-1" class="headerlink" title="习题1.1"></a>习题1.1</h3><p>本题为插值法1.1的另一种解。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">% 第一段时间部分</span><br><span class="line">y1 = [9.68 9.48 9.31 9.13 8.98 8.81 8.69 8.52 8.39 8.22];   %第一个时间段水位的高度</span><br><span class="line">xce = [0:0.1:8.22]; %需要预测的时间段</span><br><span class="line">x1 = [0 0.92 1.84 2.95 3.87 4.98 5.9 7.01 7.93 8.97];   %已知的时刻</span><br><span class="line"></span><br><span class="line">y1 = y1*pi/4*302.76;    %每时刻对应水的体积</span><br><span class="line">v = gradient(y1&apos;,x1&apos;);  %每时刻对应的水流速度</span><br><span class="line">v = -v;</span><br><span class="line"></span><br><span class="line">a1 = polyfit(x1,v&apos;,3);</span><br><span class="line">Y1 = polyval(a1,xce);</span><br><span class="line"></span><br><span class="line">figure(1)</span><br><span class="line">plot(xce,Y1)</span><br><span class="line">%第二部分时间计算</span><br><span class="line">x2 = [10.95 12.03 12.95 13.88 14.98 15.9 16.83 17.93 19.04 19.96 20.84 ];   %第二段时间中的时刻</span><br><span class="line">y2 = [10.82 10.5 10.21 9.94 9.65 9.41 9.18 8.92 8.66 8.43 8.22];</span><br><span class="line">xce2 = [10.95:0.1:20.84];   %第二次的时间段</span><br><span class="line"></span><br><span class="line">y2 = y2*pi/4*302.76;    %每时刻对应水的体积</span><br><span class="line">v2 = gradient(y2&apos;,x2&apos;);  %每时刻对应的水流速度</span><br><span class="line">v2 = -v2;</span><br><span class="line"></span><br><span class="line">a2 = polyfit(x2,v2&apos;,3);</span><br><span class="line">Y2 = polyval(a2,xce2);</span><br><span class="line"></span><br><span class="line">figure(2)</span><br><span class="line">plot(xce2,Y2)</span><br><span class="line">% 第三段时间部分</span><br><span class="line">x3 = [23.88 24.99 25.91];</span><br><span class="line">y3 = [10.59 10.35 10.18];</span><br><span class="line">xce3 = [23.88:0.1:25.91];</span><br><span class="line">y3 = y3*pi/4*302.76;    %每时刻对应水的体积</span><br><span class="line">v3 = gradient(y3&apos;,x3&apos;)   %每时刻对应的水流速度</span><br><span class="line">v3 = -v3</span><br><span class="line"></span><br><span class="line">a3 = polyfit(x3,v3&apos;,3);</span><br><span class="line">Y3 = polyval(a3,xce3);</span><br><span class="line"></span><br><span class="line">figure(3)</span><br><span class="line">plot(xce3,Y3)</span><br><span class="line">%绘制总图</span><br><span class="line">x = [xce xce2 xce3];</span><br><span class="line">V = [Y1 Y2 Y3];</span><br><span class="line">figure(4)</span><br><span class="line">plot(x,V,&apos;r&apos;)</span><br></pre></td></tr></table></figure></code></pre><p>解得图像<br><img src="https://i.imgur.com/yeigMaS.png" alt></p><h2 id="灰色预测法"><a href="#灰色预测法" class="headerlink" title="灰色预测法"></a>灰色预测法</h2><p>###习题1.1<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">%本例为GM(1,2)灰色预测模型</span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">%导入数据，并将数据转化为行向量,数据一定要用行向量</span><br><span class="line">data = [4383 7625 10500 11316 17818];     %产品利润</span><br><span class="line">x0 =[83 131 180 195 306];   %甲原料</span><br><span class="line">x2 =[146 212 233 259 404];  %乙原料</span><br><span class="line">data2 = [0 0 0 0];</span><br><span class="line">n = size(data,2);</span><br><span class="line">jibi = data(1:n-1)./data(2:n);    %计算需要预测的数据的级比</span><br><span class="line">%a = exp(-2/(n+1))</span><br><span class="line">%b = exp(2/(n+1))   %计算检验值</span><br><span class="line">data1 = cumsum(data);  </span><br><span class="line">x11 = cumsum(x0);</span><br><span class="line">x21 = cumsum(x2);        %进行三次累加，得到数据集data1</span><br><span class="line"></span><br><span class="line">for i = 1:4</span><br><span class="line">    data2(i) = (data1(i)+data1(i+1))/2;</span><br><span class="line">end         %生成一个临近数据集</span><br><span class="line"></span><br><span class="line">B = [-data2(1:n-1)&apos; x11(2:n)&apos; x21(2:n)&apos;]; %构造数据矩阵</span><br><span class="line">Y = data(2:n);</span><br><span class="line"></span><br><span class="line">u = B\Y&apos;;</span><br><span class="line"></span><br><span class="line">syms x(t)</span><br><span class="line">x1 = dsolve(&apos;Dx1+a*x1 == b2*x2+b3*x3&apos;,&apos;x1(0)==x10&apos;);   %求得微分方程形式</span><br><span class="line">x1 = subs(x1,&#123;&apos;a&apos;,&apos;b2&apos;,&apos;b3&apos;,&apos;x10&apos;&#125;,&#123;u(1),u(2),u(3),data(1,1)&#125;);</span><br><span class="line">x1_s1 = vpa(x1,9)</span><br><span class="line">x1_s2 = vpa(simplify(x1),9)</span><br><span class="line">x1_s3 = vpa(expand(x1),9)       %时间响应方程</span><br><span class="line">x20 = [x0,400];</span><br><span class="line">x30 = [x2,500];</span><br><span class="line">x22 = cumsum(x20);</span><br><span class="line">x32 = cumsum(x30);</span><br><span class="line"></span><br><span class="line">x1 = subs(x1,&#123;&apos;t&apos;,&apos;x2&apos;,&apos;x3&apos;&#125;,&#123;[0:n],x22,x32&#125;)</span><br><span class="line">x1 = double(x1)     %求出的是预测值的之间的差值，需要还原一步</span><br><span class="line">x10hat = [x1(1),diff(x1)]       %进行还原</span><br><span class="line"></span><br><span class="line">% 检验部分</span><br><span class="line">cancha = x0(1,:) - x10hat(1:end-1)    %计算残差</span><br><span class="line">xiangduiwucha = abs(cancha./x0(1,:))   %计算相对误差</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xhat = x10hat(end)      %给出最终预测结果</span><br></pre></td></tr></table></figure></p><p>解得</p><pre><code>```残差为   1.0e+04 *   -0.4300   -0.6439   -1.0976   -1.1355   -1.7506相对误差为   51.8072   49.1555   60.9786   58.2315   57.2089预测结果为   2.3406e+04```    </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在大致学习了几类数学建模的模型和算法后，我决定开始做题试一试。&lt;br&gt;本节笔记例题均来自司守奎的算法与应用。&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>备忘录</title>
    <link href="http://linmushen.com/2019/08/30/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://linmushen.com/2019/08/30/备忘录/</id>
    <published>2019-08-30T03:28:19.000Z</published>
    <updated>2019-09-10T13:22:47.573Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>仔细阅读题目，仔细阅读规则。</em></strong></p><p><strong>模型求解在国赛中是最为重要的。评委不看重结果的准确性，但是评委看重对参数、误差的讨论，如果没有求解的话，何来误差分析。所以，无论求解正确与否，我们都必须给出结果。</strong></p><p><strong>能用彩色图的就不用黑白图，能用三维图的就不用二维图，漂亮的图对你的论文加分不少。</strong></p><p>看优秀论文时发现了一些好的方法、陈述。怕记在别的笔记中找不到。<br><a id="more"></a></p><h1 id="几个链接"><a href="#几个链接" class="headerlink" title="几个链接"></a>几个链接</h1><p>放几个链接，防止找不到<br>关于论文侧重点的说明<br>&lt; <a href="https://www.zhihu.com/question/65256909/answer/365283612" target="_blank" rel="noopener">https://www.zhihu.com/question/65256909/answer/365283612</a><br>建模概述<br>&lt; <a href="https://zhuanlan.zhihu.com/p/32918281" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32918281</a></p><p>论文模板<br><a href="https://wenku.baidu.com/view/a3bd8763783e0912a2162a9e.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/a3bd8763783e0912a2162a9e.html</a></p><p>matlab文档查询</p><blockquote><p><a href="https://ww2.mathworks.cn/help/matlab/index.html" target="_blank" rel="noopener">https://ww2.mathworks.cn/help/matlab/index.html</a></p></blockquote><p>matlab统计概率分布</p><blockquote><p><a href="https://www.cnblogs.com/djcsch2001/archive/2012/02/05/2339193.html" target="_blank" rel="noopener">https://www.cnblogs.com/djcsch2001/archive/2012/02/05/2339193.html</a></p></blockquote><p>学校图书馆地址</p><blockquote><p><a href="http://lib.hrbust.edu.cn/" target="_blank" rel="noopener">http://lib.hrbust.edu.cn/</a></p></blockquote><p>数学建模的一般步骤</p><blockquote><p><a href="https://wenku.baidu.com/view/dc1712795acfa1c7aa00cc65.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/dc1712795acfa1c7aa00cc65.html</a></p></blockquote><h1 id="层次分析法相关"><a href="#层次分析法相关" class="headerlink" title="层次分析法相关"></a>层次分析法相关</h1><ul><li>国家统计局：可以查找到许多数据（人口、学费、家庭收入等）</li><li>据简化的明瑟收益率[2]方程： Z4(p) = Wau−Wah+t× p </li><li>层次分析法是一种定性分析和定量计算相结合的方法，首先构造因素间的成对 比较矩阵 </li></ul><h1 id="实验室预约"><a href="#实验室预约" class="headerlink" title="实验室预约"></a>实验室预约</h1><p>一定要在用户预约里弄，会有一个选座位的才是。</p><h1 id="论文写作"><a href="#论文写作" class="headerlink" title="论文写作"></a>论文写作</h1><p>可以拿着一篇优秀的论文，对着写即可。</p><h1 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h1><p>摘要应该体现你用了什么方法，建立了什么模型，解决了什么问题，得出了什么结论，还可作那些推广。</p><p>摘要包括： a.模型的数学归类（在数学上属于什么类型）；b.建模的思想（思路）；c.算法思想（求解思路）；d.建模特点（模型优点，建模思想或方法，算法特点，结果检验，灵敏度分析，模型检验…….）；e.主要结果（数值结果，结论）（回答题目所问的全部“问题”）。</p><p>最好统计下每篇论文主要的思路和方法，如果不是明显现成的方法，就需要研究下他的参考论文主要是哪个方向的论文。</p><p>对于B题来说，比较容易出现使用常规方法，但是特色指标定义的办法。对于A题，比较容易出现固定方法，但是是参考文献当中才有，数模书当中没有的结果。</p><p>如果是B题，那么好办，学习的时候，结合数学建模教材，一点一点地啃，熟悉案例程序以及基本原理，这些内容在《数学建模算法与应用》这本书当中有着很好的体现。</p><p>对于A题，则更多地需要从参考文献当中获得一些信息，我前面也说到了硕博学位论文也是非常详细的，这一点和数学建模论文非常相似，可能给出了具体的软件操作甚至源代码，因此硕博论文是一个非常好的突破口。</p><p>最好多学习别人如何把自己的建模给程序化，如何设定变量，如何设定数据集，如何将解析的问题变成数值的问题，都是值得我们去考虑的。</p><h1 id="论文结果分析部分"><a href="#论文结果分析部分" class="headerlink" title="论文结果分析部分"></a>论文结果分析部分</h1><p>在我们的模型假设中，忽略了一些对问题影响的次要因素，使问题得到了简化，但必然会产生一些误差；另外解决问题的方法是很多的，在论文中可能只用了其中的一两种方法，思维可能显得比较局限；而模型本身也会有它的优势和缺陷。因此，我们在这部分应该做的工作主要有下面三点：</p><p>A． 是否能用其他方式或方法解决。</p><p>B． 模型的优缺点分析。</p><p>C． 模型的误差分析或灵敏度分析。</p><p>#关于绘图<br>设置线宽度(LineWidth)，标记点的边缘颜色(MarkerEdgeColor)，<br>填充颜色 (MarkerFaceColor)及标记点的大小(MarkerSize)</p><p>例:设置绘图线的线型,颜色,宽度,标记 点的颜色及大小：<br>t=0:pi/20:pi;<br>y=sin(4<em>t).</em>sin(t)/2;<br>plot(t,y,’-bs’,’LineWidth’,2,… %设置线的宽度为2<br>‘MarkerEdgeColor’,’k’,… %设置标记点边缘颜色为黑色<br>‘MarkerFaceColor’,’y’,… %设置标记点填充颜色为黄色<br>‘MarkerSize’,10) %设置标记点的尺寸为10</p><h1 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h1><p>怎样用matlab确定数据的分布<br>分布的正太性检验：<br>x为你要检验的数据。<br>load x<br>histfit(x);<br>normplot(x);<br>从这两个图中可以看出是否近似服从正太分布。<br>然后估计参数：<br>[muhat,sigmahat,muci,sigmaci]=normfit(x);<br>muhat , sigmahat,muci,sigmaci 分别表示均值、方差、均值的0.95置信区间、方差0.95置信区间。<br>现在可以用t检验法对其进行检验： </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;仔细阅读题目，仔细阅读规则。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模型求解在国赛中是最为重要的。评委不看重结果的准确性，但是评委看重对参数、误差的讨论，如果没有求解的话，何来误差分析。所以，无论求解正确与否，我们都必须给出结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;能用彩色图的就不用黑白图，能用三维图的就不用二维图，漂亮的图对你的论文加分不少。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看优秀论文时发现了一些好的方法、陈述。怕记在别的笔记中找不到。&lt;br&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://linmushen.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>Matlab学习笔记</title>
    <link href="http://linmushen.com/2019/08/16/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/08/16/Matlab学习笔记/</id>
    <published>2019-08-16T05:16:47.000Z</published>
    <updated>2019-08-31T07:45:22.690Z</updated>
    
    <content type="html"><![CDATA[<p>好好学习Matlab。<br><a id="more"></a></p><p>学习目标：基本常用拟合曲线形式及特点、线性拟合线性度。了解插值、回归。<br>微分、偏微分方程求解及数值解，了解数学意义及程序</p><p>知识积累：<br>运算：<br>1） .  ：矩阵中相同位置的元素进行.后的运算。</p><p>函数：<br>1）画图<br>x = linspace(起始点，终止点，点的个数)<br>y = sin(x)<br>沿sin(x)曲线生成点的个数（默认是100个）个等间距的点</p><p>2）数据拟合：<br>p = polyfit(x,y,n)；返回n+1阶拟合后函数的系数。<br>配合y = polyval(p,x)；计算对应点y的值。</p><p>3）读取Excel电子表格文件<br>xlsread(filename,sheetx,xlrange)<br>filename：文件名<br>sheetx：第几个表格（sheet1,sheet2…）<br>xlrange:矩阵范围A1：H99（从A行的第一列的元素到H行的第九十九的元素之间的矩阵）</p><p>4）清除临时变量<br>clearvars 临时变量1 临时变量2；</p><p>5）创建一个新的临时图像窗口<br>figure</p><p>6）datetick(变量1，变量2)<br>变量1：要改变的轴<br>变量2：日期转变的形式<br><img src="https://i.imgur.com/DGFnl7c.png" alt></p><p>7）xlabel(txt,name,value)</p><ul><li>txt-轴标签</li><li>name-变量的名称 如 fontsize</li><li>value-变量的值  如 fontsize对应的12</li></ul><p>8）mean(变量（一个向量）)<br>返回变量的均值</p><p>9）sum(变量（一个向量）)<br>将变量累加</p><p>10）subplot(m,n,p)<br>将窗口划分成m*n个区域，并在p区域画图。</p><p>11）axis([x1 x2 y1 y2])<br>用来确定x轴y轴范围的函数。</p><p>12）<br>grid on；%添加网格<br>grid off；%去掉网格</p><p>13）unifrnd(A,B,m,n)函数<br>生成被A和B指定上下端点[A,B]的连续均匀分布的随机数组。<br>当存在m，n时，数组大小为m*n；当没有m,n时，数组大小由A,B数组确定。<br>附上Matlab文档</p><blockquote><p>A和B可以是向量也可以是标量，若两个都是向量，则两者都是列向量或都是行向量，而且维数相等。从A到B产生一系列区间，若A和B均为向量，则区间个数等于他们的维数；若其中恰有一个是向量，假设A为向量，则区间个数等于A的维数；若两个均为标量，则A&lt;= B，区间个数为1，且区间为[A,B]。然后在这一系列区间中随机产生连续均匀分布的数组R并返回之。具体例子下述。<br>如：<br>执行指令</p></blockquote><blockquote><blockquote><p>x = [1:9];<br>y = [2:10];<br>unifrnd(x,y)</p></blockquote></blockquote><p>得到</p><p>ans =</p><pre><code>1.9595    2.6557    3.0357    4.8491    5.9340    6.6787    7.7577    8.7431    9.3922</code></pre><p>从x到y产生区间[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9.10].然后从每个区间产生一个随机数，得到R。</p><blockquote><p>执行指令</p></blockquote><blockquote><blockquote><p>x = [1:3];<br>R1 = unifrnd(x,1);<br>R2 = unifrnd(1,x);</p></blockquote></blockquote><p>得到</p><p>R1 =</p><pre><code>1   NaN   NaN</code></pre><p>R2 =</p><pre><code>1.0000    1.2769    1.0923</code></pre><p>NaN表示”not a number”即不是数字。观察语句R1 = unifrnd(x,1);“从x到1”产生区间[1,1],[2,1],[3,1]显然只有第一个区间可以取得“随机数”1，其余区间不符合规定，故而返回NaN。</p><p>观察R2 = unifrnd(1,x);从1到x产生区间[1,1],[1,2],[1,3],取得随机数组R2。</p><p>14） exp(X)：指数函数，返回X中每个元素的e^x。<br>15）legend(‘线条名称1’，···，‘线条名称n’，’Location’,’Sountheast’):最后一个变量用来指定说明的位置，前面是东南处。</p><p>16）匿名函数：NAME =@(参数列表) 实现功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = @(x,y) x^2+y^2;%定义匿名函数</span><br><span class="line">f(1,2);%使用； 1^2+2^2</span><br></pre></td></tr></table></figure></p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><h2 id="学习目录"><a href="#学习目录" class="headerlink" title="学习目录"></a>学习目录</h2><p>1）了解Matlab基本用法，常用的命令。<br>2）熟悉常见模型的求解算法和套路，如：连续模型、规划模型等。<br>3）将机理建模的过程模拟出来，能够建立和求解没有套路的模型。</p><h2 id="主要题型对应的模型"><a href="#主要题型对应的模型" class="headerlink" title="主要题型对应的模型"></a>主要题型对应的模型</h2><p><img src="https://i.imgur.com/3oIfAhp.png" alt><br><img src="https://i.imgur.com/mQt1xY1.png" alt></p><h1 id="第一篇—实战项目"><a href="#第一篇—实战项目" class="headerlink" title="第一篇—实战项目"></a>第一篇—实战项目</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>已知股票的交易数据：日期、开盘价、最高价、最低价、收盘价、成交量、换手率，用某种方法来评价这只股票的价值和风险。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>作为一个科学计算问题，典型的流程是：1.获取并导入数据；2.数据探索和建模；3.分享结果</p><h2 id="Matlab实现"><a href="#Matlab实现" class="headerlink" title="Matlab实现"></a>Matlab实现</h2><h3 id="第一步—从外部读取数据（获取省略，已下为导入部分）"><a href="#第一步—从外部读取数据（获取省略，已下为导入部分）" class="headerlink" title="第一步—从外部读取数据（获取省略，已下为导入部分）"></a>第一步—从外部读取数据（获取省略，已下为导入部分）</h3><p>1）在左侧窗口下找到需要读取的数据的位置<br><img src="https://i.imgur.com/gB5VTcr.png" alt><br>2）右击该文件，点击导入数据<br>3）出现一个导入引擎<br><img src="https://i.imgur.com/gUGdBnC.png" alt><br>4）点击导入所选内容（大绿色对号），点击之前可以选择导入的形式（默认是列向量的形式），之后Matlab工作区出现这些导入的数据。</p><h3 id="第二步—数据探索和建模"><a href="#第二步—数据探索和建模" class="headerlink" title="第二步—数据探索和建模"></a>第二步—数据探索和建模</h3><p>绘制图形：<br>首先双击变量名，然后选中变量，点击绘图建，选择想要绘制的图形，可视化查看数据。<br><img src="https://i.imgur.com/djqIzuE.jpg" alt><br><img src="https://i.imgur.com/xoddok0.png" alt><br>或者输入 plot(x轴：文件名.变量名,y轴：文件名.变量名)</p><p>创建脚本：<br>还是找到数据所在位置，然后右击导入数据，进入菜单，点击大绿对号下的小箭头，选择生成脚本，然后保存该脚本。<img src="https://i.imgur.com/lUzJTng.png" alt></p><p>知识积累：<br>1）画图<br>x = linspace(起始点，终止点，点的个数)<br>y = sin(x)<br>沿sin(x)曲线生成点的个数（默认是100个）个等间距的点</p><p>2）数据拟合：<br>p = polyfit(x,y,n)；返回n+1阶拟合后函数的系数。<br>配合y = polyval(p,x)；计算对应点y的值。</p><p>3）读取Excel电子表格文件<br>xlsread(filename,sheetx,xlrange)<br>filename：文件名<br>sheetx：第几个表格（sheet1,sheet2…）<br>xlrange:矩阵范围A1：H99（从A行的第一列的元素到H行的第九十九的元素之间的矩阵）</p><p>4）清除临时变量<br>clearvars 临时变量1 临时变量2；</p><p>5）创建一个新的临时图像窗口<br>figure</p><p>6）datetick(变量1，变量2)<br>变量1：要改变的轴<br>变量2：日期转变的形式<br><img src="https://i.imgur.com/DGFnl7c.png" alt></p><p>Matlab程序<br>写在了 C:\Users\树枝990\Matlab\Matlab学习1 下</p><h3 id="第三步—发布并转换成word形式"><a href="#第三步—发布并转换成word形式" class="headerlink" title="第三步—发布并转换成word形式"></a>第三步—发布并转换成word形式</h3><p>1）点击发布下的编辑发布内容<br><img src="https://i.imgur.com/YpTRybG.png" alt></p><p>2）改为word形式<br><img src="https://i.imgur.com/ednd6ng.png" alt><br>发布出来的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc,clear,close all</span><br><span class="line">[~,~,raw] = xlsread(&apos;sz000004.xlsx&apos;,&apos;Sheet1&apos;,&apos;A2:H99&apos;);   %读取sz000004.xls文件中的sheet表格中的A2到H99之间矩阵的所有元素</span><br><span class="line">data = reshape([raw&#123;:&#125;],size(raw));     %将raw&#123;:&#125;重构成原来尺寸的矩阵</span><br><span class="line"></span><br><span class="line">Date = data(:,1);</span><br><span class="line">DataNum = data(:,2);</span><br><span class="line">Popen = data(:,3);</span><br><span class="line">Phigh = data(:,4);</span><br><span class="line">Plow = data(:,5);</span><br><span class="line">Pclose = data(:,6);</span><br><span class="line">Volum = data(:,7);</span><br><span class="line">Turm = data(:,8);</span><br><span class="line"></span><br><span class="line">clearvars data raw;</span><br><span class="line"></span><br><span class="line">plot(DataNum,Pclose,&apos;k&apos;)</span><br><span class="line">datetick(&apos;x&apos;,&apos;dd&apos;);     %修改日期形式</span><br><span class="line">xlabel(&apos;日期&apos;);</span><br><span class="line">ylabel(&apos;收盘价格&apos;);</span><br><span class="line">figure %创建一个临时窗口</span><br><span class="line">bar(Pclose)</span><br><span class="line"></span><br><span class="line">p = polyfit(DataNum,Pclose,1);</span><br><span class="line">P1 = polyval(p,DataNum);    %进行拟合</span><br><span class="line">figure</span><br><span class="line">plot(DataNum,P1,DataNum,Pclose,&apos;*g&apos;)</span><br><span class="line">value = p(1);</span><br><span class="line"></span><br><span class="line">MaxDD = maxdrawdown(Pclose);</span><br><span class="line">risk = MaxDD;</span><br></pre></td></tr></table></figure><h1 id="第二篇—回归方法"><a href="#第二篇—回归方法" class="headerlink" title="第二篇—回归方法"></a>第二篇—回归方法</h1><p>数学建模有很多方法，数学建模常用方法包括：回归、统计、机器学习、深度学习、灰色预测、主成分分析、神经网络、时间序列分析。<br>本章介绍几种回归方法。<br>回归方法分为：一元线性、一元非线性、多元回归、逐步回归、Logistic回归。</p><h2 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h2><h3 id="最小二乘法进行拟合"><a href="#最小二乘法进行拟合" class="headerlink" title="最小二乘法进行拟合"></a>最小二乘法进行拟合</h3><p>公式：y=b1*x+b0<br>确定系数的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Lxx = sum((x-mean(x)).^2); %最小二乘法</span><br><span class="line">Lxy = sum((x-mean(x)).*(y-mean(y)));</span><br><span class="line">b1 = Lxy/Lxx;              %最小二乘法拟合出来的直线的斜率</span><br><span class="line">b0 = mean(y)-b1*mean(x);   %最小二乘法拟合出来的直线的截距</span><br></pre></td></tr></table></figure><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">close all;</span><br><span class="line">x = [23.80,27.60,31.60,32.40,33.70,34.90,43.20,52.80,63.80,73.40];</span><br><span class="line">y = [41.40,51.80,61.70,67.90,68.70,77.50,95.90,137.40,155.00,175.00];</span><br><span class="line"></span><br><span class="line">figure</span><br><span class="line">plot(x,y,&apos;r*&apos;)             %画出x,y的散点图</span><br><span class="line">xlabel(&apos;x(职工工资总额)&apos;,&apos;fontsize&apos;,12)   %为x轴标注，并将字体设置为12号</span><br><span class="line">ylabel(&apos;y(商品零售总额)&apos;,&apos;fontsize&apos;,12)   %为y轴标注，并将字体设置为12号</span><br><span class="line">set(gca,&apos;linewidth&apos;,2)     %为坐标轴设置线宽为2号</span><br><span class="line"></span><br><span class="line">Lxx = sum((x-mean(x)).^2); %最小二乘法</span><br><span class="line">Lxy = sum((x-mean(x)).*(y-mean(y)));</span><br><span class="line">b1 = Lxy/Lxx;              %最小二乘法拟合出来的直线的斜率</span><br><span class="line">b0 = mean(y)-b1*mean(x);   %最小二乘法拟合出来的直线的截距</span><br><span class="line">y1 = b1*x+b0;              %拟合后的直线</span><br><span class="line">hold on</span><br><span class="line">plot(x,y1,&apos;linewidth&apos;,2);</span><br></pre></td></tr></table></figure><p>最小二乘法是将散点拟合到一条直线上，得到的直线方程是y=k<em>x+b<br>其中k的公式为<img src="https://i.imgur.com/dDKeeNE.jpg" alt><br>b的公式为y的平均值-k</em>x的平均值。</p><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://i.imgur.com/nq2Xncm.png" alt></p><h2 id="非线性回归"><a href="#非线性回归" class="headerlink" title="非线性回归"></a>非线性回归</h2><p>变量的关系并不都是线性的，用非线性回归首先要解决的问题是回归方程中参数如何估计。</p><h3 id="对数方法进行拟合"><a href="#对数方法进行拟合" class="headerlink" title="对数方法进行拟合"></a>对数方法进行拟合</h3><p>公式：y=a+b*lnx<br>确定系数a,b的方法：调用 fitnlm(x,y,m1,[0.01;0.01])函数<br>具体代码：见最后，和指数方法的一起列出</p><h3 id="指数方法进行拟合"><a href="#指数方法进行拟合" class="headerlink" title="指数方法进行拟合"></a>指数方法进行拟合</h3><p>公式：y=a*x^b<br>确定系数a,b的方法：调用fitnlm(x,y,m2,[1;1])函数<br>具体代码：见最后</p><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">%输入数据</span><br><span class="line"></span><br><span class="line">x = [1.5,4.5,7.5,10.5,13.5,16.5,19.5,22.5,25.5];</span><br><span class="line">y = [7.0,4.8,3.6,3.1,2.7,2.5,2.4,2.3,2.2];</span><br><span class="line"></span><br><span class="line">%画散点图，标明xy轴，加粗坐标轴</span><br><span class="line"></span><br><span class="line">figure</span><br><span class="line">plot(x,y,&apos;b*&apos;);</span><br><span class="line">xlabel(&apos;x(销售额x/万元)&apos;,&apos;fontsize&apos;,12)</span><br><span class="line">ylabel(&apos;y(流通费率y/%)&apos;,&apos;fontsize&apos;,12)</span><br><span class="line">set(gca,&apos;linewidth&apos;,2)</span><br><span class="line"></span><br><span class="line">%进行拟合（对数方法）</span><br><span class="line"></span><br><span class="line">m1 = @(b,x)b(1) + b(2)*log(x);</span><br><span class="line">nonlinfit1 = fitnlm(x,y,m1,[0.01;0.01]);</span><br><span class="line">b = nonlinfit1.Coefficients.Estimate;</span><br><span class="line">Y1 = b(1,1) + b(2,1)*log(x);</span><br><span class="line">hold on</span><br><span class="line">plot(x,Y1,&apos;--k&apos;,&apos;linewidth&apos;,2)</span><br><span class="line"></span><br><span class="line">%再次进行拟合（指数方法）</span><br><span class="line"></span><br><span class="line">m2 = &apos;y~b1*x^b2&apos;;</span><br><span class="line">nonlinfit2 = fitnlm(x,y,m2,[1,1]);</span><br><span class="line">b1 = nonlinfit2.Coefficients.Estimate(1,1);</span><br><span class="line">b2 = nonlinfit2.Coefficients.Estimate(2,1);</span><br><span class="line">Y2 = b1*x.^b2;</span><br><span class="line">hold on</span><br><span class="line">plot(x,Y2,&apos;r&apos;,&apos;linewidth&apos;,2)</span><br><span class="line"></span><br><span class="line">%为每条线加注释</span><br><span class="line"></span><br><span class="line">legend(&apos;原始数据&apos;,&apos;a+b*lnx&apos;,&apos;a*x^b&apos;)</span><br></pre></td></tr></table></figure><h3 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://i.imgur.com/tJM98Lu.png" alt></p><h2 id="多元回归"><a href="#多元回归" class="headerlink" title="多元回归"></a>多元回归</h2><p>在拟合之前，应先通过数据可视化，判断问题能否应该多元线性拟合。</p><h3 id="regress-函数进行拟合"><a href="#regress-函数进行拟合" class="headerlink" title="regress()函数进行拟合"></a>regress()函数进行拟合</h3><h4 id="regress-函数"><a href="#regress-函数" class="headerlink" title="regress()函数"></a>regress()函数</h4><p>[回归系数字母B，回归系数置信区间左边界bint，回归系数（中值）b，回归系数置信区间右区间rint，统计变量s]=repress(Y,X,0.05)</p><p>回归系数:[1,2,3,4]—四个，分别对应b0,b1,b2,b3,<br>回归系数置信区间:[bint,rint]—四组，分别对应b0,b1,b2,b3<br>统计变量s:相关系数的平方R^2;假设检验统计量F;F对应的概率P;s^2的值。</p><p>最终得到方程y = b0 +b1<em>x1 +b2</em>x2 +b3*x3</p><h4 id="判断模型："><a href="#判断模型：" class="headerlink" title="判断模型："></a>判断模型：</h4><p>1）结果法：回归系数置信区间不包含零点的模型比较好。残差在零点附近比较好。<br>2）R法：R越靠近1，说明相关性越高。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>首先将y转置，再构建一个n+1列的矩阵X（x1,x2…,xn均转置，第一列为ones(n,1)）</p><h4 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">%输入数据</span><br><span class="line"></span><br><span class="line">x1 = [3.5,5.3,5.1,5.8,4.2,6.0,6.8,5.5,3.1,7.2,4.5,4.9,8.0,6.5,6.6,3.7,6.2,7.0,4.0,4.5,5.9,5.6,4.8,3.9];</span><br><span class="line">x2 = [9,20,18,33,31,13,25,30,5,47,25,11,23,35,39,21,7,40,35,23,33,27,34,15];</span><br><span class="line">x3 = [6.1,6.4,7.4,6.7,7.5,5.9,6.0,4.0,5.8,8.3,5.0,6.4,7.6,7.0,5.0,4.4,5.5,7.0,6.0,3.5,4.9,4.3,8.0,5.8];</span><br><span class="line">y = [33.2,40.3,38.7,46.8,41.4,37.5,39.0,40.7,30.1,52.9,38.2,31.8,43.3,44.1,42.5,33.6,34.2,48.0,38.0,35.9,40.4,36.8,45.2,35.1];</span><br><span class="line"></span><br><span class="line">%绘制散点图</span><br><span class="line"></span><br><span class="line">plot(x1,y,&apos;b*&apos;)</span><br><span class="line">hold on</span><br><span class="line">plot(x2,y,&apos;ro&apos;)</span><br><span class="line">hold on</span><br><span class="line">plot(x3,y,&apos;g+&apos;)</span><br><span class="line">hold on</span><br><span class="line"></span><br><span class="line">%进行拟合</span><br><span class="line"></span><br><span class="line">n = 24;</span><br><span class="line">X = [ones(n,1),x1&apos;,x2&apos;,x3&apos;];</span><br><span class="line">Y = y&apos;;</span><br><span class="line">[b,bint,r,rint,s] = regress(Y,X,0.05)</span><br><span class="line"></span><br><span class="line">%写出表达式</span><br><span class="line"></span><br><span class="line">y1 = b(1)+ b(2)*x1 +b(3)*x2 +b(4)*x3</span><br></pre></td></tr></table></figure><h2 id="逐步回归"><a href="#逐步回归" class="headerlink" title="逐步回归"></a>逐步回归</h2><p>调用stepwise(X,Y,0.05,0.1)函数<br>X是由x1，x2…xn组成的，x1，x2…xn的第一个元素组成第一行，第二个组成第二行…<br>然后得到逐步回归窗口点击 Next Step 直至变成灰色，表明逐步回归结束，得到最终的回归模型。</p><h2 id="logistic回归"><a href="#logistic回归" class="headerlink" title="logistic回归"></a>logistic回归</h2><p>搞不懂，大概是输入一组数据，判断是0是1。</p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">[~,~,raw] = xlsread(&apos;Logistic.xlsx&apos;,&apos;sheet1&apos;,&apos;A2:F26&apos;);</span><br><span class="line">data = reshape([raw&#123;:&#125;],size(raw));</span><br><span class="line"></span><br><span class="line">X0 = xlsread(&apos;Logistic.xlsx&apos;,&apos;B2:D21&apos;);</span><br><span class="line">Y0 = xlsread(&apos;Logistic.xlsx&apos;,&apos;E2:E21&apos;);</span><br><span class="line">X1 = xlsread(&apos;Logistic.xlsx&apos;,&apos;B2:D26&apos;);</span><br><span class="line">%logistic函数</span><br><span class="line">GM = fitglm(X0,Y0,&apos;Distribution&apos;,&apos;binomial&apos;);</span><br><span class="line">Y1 = predict(GM,X1);</span><br><span class="line">%模型评估</span><br><span class="line">N0 = 1:size(Y0,1);N1 = 1:size(Y1,1);</span><br><span class="line">hold on</span><br><span class="line">scatter(N1&apos;,Y1,&apos;b&apos;);</span><br><span class="line">plot(N0&apos;,Y0,&apos;-kd&apos;);</span><br><span class="line">xlabel(&apos;数据点编号&apos;);</span><br><span class="line">ylabel(&apos;输出值&apos;);</span><br></pre></td></tr></table></figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1）判断变量个数：一个用一元回归，超过两个用多元回归。<br>2）如果一元，判断是否线性；如果多元，先拟合，再检验效果。</p><h1 id="第三篇—全局最优解"><a href="#第三篇—全局最优解" class="headerlink" title="第三篇—全局最优解"></a>第三篇—全局最优解</h1><h2 id="蒙特卡洛算法"><a href="#蒙特卡洛算法" class="headerlink" title="蒙特卡洛算法"></a>蒙特卡洛算法</h2><ol><li>举个例子，假如筐里有100个苹果，让我每次闭眼拿1个，挑出最大的。于是我随机拿1个，再随机拿1个跟它比，留下大的，再随机拿1个……我每拿一次，留下的苹果都至少不比上次的小。拿的次数越多，挑出的苹果就越大，但我除非拿100次，否则无法肯定挑出了最大的。这个挑苹果的算法，就属于蒙特卡罗算法——尽量找好的，但不保证是最好的。</li><li>随机算法，在采样不全时，通常不能保证找到最优解，只能说是尽量找。</li><li>由此知：蒙特卡洛算法是一种尽量找最优解的方法。<br>数值计算方法<br>1）作用：</li><li>用于计算：<br>计算圆周率：<br>设有一个正方形，正方形中间有一个内切圆，他们的面积之比为Pi/4。<br>在这个正方形内部生成10000个点，计算他们与圆心之间的距离，从而判断点是否落在圆内。如果这些点均匀分布，则落在圆内的点应占所有点的pi/4，因此将圆内点/所有点的值乘4，就是pi的值。<br><img src="https://i.imgur.com/U8jmGs2.png" alt></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%蒙特卡洛算法估计圆周率</span><br><span class="line">n = input(&apos;请输入n:&apos;);</span><br><span class="line">m = 0;</span><br><span class="line">a = 2;      %半径为2</span><br><span class="line"></span><br><span class="line">for i=1:n</span><br><span class="line">    x = rand * a/2;</span><br><span class="line">    y = rand * a/2;</span><br><span class="line">    if(x^2+y^2&lt;=(a/2)^2)</span><br><span class="line">        m = m+1;        %落入圆中的点数</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">fprintf(&apos;pi = %d\n&apos;,4*m/n)</span><br></pre></td></tr></table></figure><ol start="2"><li>用于模拟系统内部的随机运动。<br>模拟单车道交通堵塞<br>根据 Nagel-Schreckenberg 模型，车辆的运动满足以下规则。</li></ol><ul><li>当前速度是 v 。</li><li>如果前面没车，它在下一秒的速度会提高到 v + 1 ，直到达到规定的最高限速。</li><li>如果前面有车，距离为d，且 d &lt; v，那么它在下一秒的速度会降低到 d - 1 。</li><li>此外，司机还会以概率 p 随机减速， 将下一秒的速度降低到 v - 1 。</li></ul><p>在一条直线上，随机产生100个点，代表道路上的100辆车，另取概率p为0.3 。<br>横轴代表距离（从左到右），纵轴代表时间（从上到下），因此每一行就表示下一秒的道路情况。<br>该模型会随机产生交通拥堵。这就证明了，单车道即使没有任何原因，也会产生交通堵塞。</p><h2 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h2><p>上述的蒙特卡洛算法为本节中实例的一小部分，因此提前简要介绍。一下。<br>模拟退火算法为一种现代优化算法，用来求解全局最小（最优）解<br>模拟退火法：<br>核心原理：当材料从状态i进入状态j时，若E(j)&lt;=E(i),状态会被转移（E(i)=E(j)）;若为其他情况，状态会以小概率被转移。也就是说，模拟退火法是一个不断寻找新解和缓慢降温交替的过程。<br>具体实现：</p><ol><li>优化函数 f(x)。</li><li>初始温度，初始解x0。</li><li>根据初始温度，初始解，生成下一个解x2。</li><li>判断f(x2)与f(x0)的关系，并根据核心原理进行判断、取值。、</li><li>根据规定的每一个温度结束的标志，判断是否需要降温</li><li>返回第三步</li></ol><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="https://i.imgur.com/2gw4akc.png" alt></p><h3 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h3><p>求解TSP问题<br>例:有100个目标，需要找出巡航最优路径。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">clc,clear</span><br><span class="line"></span><br><span class="line">%导入数据部分</span><br><span class="line"></span><br><span class="line">[~,~,raw] = xlsread(&apos;sj.xlsx&apos;,&apos;Sheet1&apos;,&apos;A2:H26&apos;);</span><br><span class="line">sj0 = reshape([raw&#123;:&#125;],size(raw)); %将raw&#123;:&#125;重构成原来尺寸的矩阵</span><br><span class="line">x = sj0(:,[1:2:8]);     %将数据中的经度部分存储在x矩阵中</span><br><span class="line">x = x(:);               %将x（四列）转为一列</span><br><span class="line">y = sj0(:,[2:2:8]);     %将数据中的纬度部分存储在y矩阵中</span><br><span class="line">y = y(:);               %将y（四列）转为一列</span><br><span class="line"></span><br><span class="line">%对数据进行处理的部分</span><br><span class="line"></span><br><span class="line">sj = [x y];             %将xy矩阵合成，sj中第一列为x；sj中第二列为y</span><br><span class="line">d1 = [70,40];           %将基地位置存储进去</span><br><span class="line">sj = [d1;sj;d1];        %将基地存储入数据中,都整合成两列</span><br><span class="line">sj = sj*pi/180;         %将角度转为弧度制（计算距离时，位置坐标被当作角度计算）</span><br><span class="line"></span><br><span class="line">%创建距离公式，距离存储矩阵（用于存储两个点之间的距离）</span><br><span class="line"></span><br><span class="line">d = zeros(102);         %创建距离矩阵</span><br><span class="line">for i = 1:101</span><br><span class="line">    for j = i+1:102</span><br><span class="line">        d(i,j) = 6370*acos(cos(sj(i,1)-sj(j,1))*cos(sj(i,2))*cos(sj(j,2))+sin(sj(i,2))*sin(sj(i,2))*sin(sj(j,2)));</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">d =d +d&apos;;</span><br><span class="line"></span><br><span class="line">path = [];              %创建用于存储路径的矩阵</span><br><span class="line">long = inf;             %初始化距离变量（inf为正无穷）</span><br><span class="line">rand(&apos;state&apos;,sum(clock));           %初始化随机数发生器，这种写法的作用：是每一次初始值不同，避免出现相同数字</span><br><span class="line"></span><br><span class="line">%蒙特卡洛算法部分，为了得到更好的初始值，先用蒙特卡洛法求解相对较好的解</span><br><span class="line"></span><br><span class="line">for j=1:1000            %随机产生一千种解</span><br><span class="line">    path0 = [1,1+randperm(100),102];%解的情况</span><br><span class="line">    temp =0;</span><br><span class="line">    %求解每种情况对应的距离值</span><br><span class="line"></span><br><span class="line">    for i=1:101         %通过循环，解得该情况下的距离</span><br><span class="line">        temp = temp + d(path0(i)+path0(i+1));</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %对每种情况进行比较，得到最优（小）解</span><br><span class="line"></span><br><span class="line">    if temp&lt;long</span><br><span class="line">        path = path0;</span><br><span class="line">        long =temp;</span><br><span class="line">        long</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%模拟退火法部分</span><br><span class="line">e = 0.1^30;     %结束条件</span><br><span class="line">L = 20000;      %迭代次数（解空间的大小）</span><br><span class="line">at = 0.999;     %执行一次的降温比例</span><br><span class="line">T = 1;          %初始温度</span><br><span class="line">for k =1:L</span><br><span class="line">    c = 2+floor(100*rand(1,2));</span><br><span class="line">    %另c取20000次大于2的值；其中c是一个一行二列的矩阵，rand产生一行二列的元素大于0小于1的随机数矩阵</span><br><span class="line">    c = sort(c);        %对c的元素进行升序排列</span><br><span class="line">    c1 = c(1);c2=c(2);</span><br><span class="line">    df = d(path(c1-1),path(c2))+d(path(c1),path(c2+1)) - d(path(c1-1),path(c1))-d(path(c2),path(c2+1));</span><br><span class="line">    %判断两组不相邻的两个点的具体是否小于两组相邻两个点之间的距离</span><br><span class="line">    if df&lt;0</span><br><span class="line">        path = [path(1:c1-1),path(c2:-1:c1),path(c2+1:102)]; long = long+df;</span><br><span class="line">        %如果新解距离小于原来解，则进行替换</span><br><span class="line">    elseif exp(-df/T) &gt;= rand</span><br><span class="line">        path = [path(1:c1-1),path(c2:-1:c1),path(c2+1:102)]; long = long+df;</span><br><span class="line">        %以这个极小的概率，进行替换</span><br><span class="line">    end</span><br><span class="line">    T = T*at;</span><br><span class="line">    if T&lt;e</span><br><span class="line">        break;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%输出部分</span><br><span class="line"></span><br><span class="line">path;</span><br><span class="line">long;</span><br><span class="line">xx = sj(path,1);</span><br><span class="line">yy = sj(path,2);</span><br><span class="line">figure</span><br><span class="line">plot(xx,yy,&apos;- *&apos;)</span><br><span class="line">legend(&apos;巡航最优路径&apos;)</span><br><span class="line">figure</span><br><span class="line">plot(xx,yy,&apos;ro&apos;)</span><br><span class="line">legend(&apos;巡航点位置&apos;)</span><br></pre></td></tr></table></figure><h3 id="实现效果-2"><a href="#实现效果-2" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://i.imgur.com/Fe8WKHJ.jpg" alt></p><h3 id="模拟退火法模板"><a href="#模拟退火法模板" class="headerlink" title="模拟退火法模板"></a>模拟退火法模板</h3><p>依据上述程序改动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">%模拟退火法部分</span><br><span class="line">e =   ;     %结束条件（到该温度终止）</span><br><span class="line">L =   ;     %迭代次数（解空间的大小）</span><br><span class="line">at =  ;     %执行一次的降温比例</span><br><span class="line">T =   ;     %初始温度</span><br><span class="line">for k =1:L</span><br><span class="line">%&#123;</span><br><span class="line"></span><br><span class="line">计算新解的代价</span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line">    </span><br><span class="line">    if %取新解的条件（新解的代价需要满足的条件）</span><br><span class="line">        </span><br><span class="line">    %&#123;</span><br><span class="line">满足条件，进行替换</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">    elseif exp(-df/T) &gt;= rand%不满足条件且被替换的概率</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">发生这个概率的事件，进行替换</span><br><span class="line">&#125;%</span><br><span class="line">    </span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    T = T*at;%每次进行降温</span><br><span class="line">    if T&lt;e%达到目标温度，结束模拟退火法</span><br><span class="line">        break;</span><br><span class="line">    end</span><br></pre></td></tr></table></figure></p><h1 id="第三篇—评价类问题"><a href="#第三篇—评价类问题" class="headerlink" title="第三篇—评价类问题"></a>第三篇—评价类问题</h1><h2 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h2><h3 id="确定指标"><a href="#确定指标" class="headerlink" title="确定指标"></a>确定指标</h3><p>根据别人的文章，确定指标   [比如评价旅游目的地，首先应该在知网、万方数据、虫部落-快搜 等平台查找评价一个旅游目的地是否优秀的指标。（通过引用别人的指标，显得专业 1.只引用他的指标，注明引用的文章。2.引用他判断该指标的依据。）如果没有找到，则要自己思考+找别人的看法。]</p><h3 id="求指标权重"><a href="#求指标权重" class="headerlink" title="求指标权重"></a>求指标权重</h3><h4 id="绘制图表"><a href="#绘制图表" class="headerlink" title="绘制图表"></a>绘制图表</h4><ol><li>绘制权重表格。<img src="https://i.imgur.com/FnaF6hi.png" alt></li><li>二步骤带来的问题—容易考虑不周。解决方案：两个两个指标进行比较，根据两两比较的结果推算权重。   重要度表格<br><img src="https://i.imgur.com/OCMW70S.png" alt><br>重要度矩阵<br><img src="https://i.imgur.com/xyqLHyC.png" alt><h4 id="判断矩阵"><a href="#判断矩阵" class="headerlink" title="判断矩阵"></a>判断矩阵</h4><img src="https://i.imgur.com/xyqLHyC.png" alt><br>其中a11为针对的元素（苏杭、北戴河、桂林）<br>对角线两侧的数据互相呈倒数。A12=3;A21=1/3。<br>根据重要度表格，填写重要度矩阵，根据矩阵算权重。<br>记表中的元素为aij,其含义是：与j相比i的重要程度。<h4 id="一致矩阵"><a href="#一致矩阵" class="headerlink" title="一致矩阵"></a>一致矩阵</h4><img src="https://i.imgur.com/o0xa0M7.png" alt><br>一致矩阵：不发生矛盾（矛盾：A&gt;B,A=C,B&gt;C）。特点：各行各列成倍数关系。<strong>使用矩阵求权重前，一定要验证一致性；当不一致时，要判断该矩阵与一致矩阵差别是否太大</strong>验证办法：一直矩阵秩为1，特征值为n，特征向量为k*第一行元素的倒数。若矩阵非一致时，特征值&gt;n（和n的差距等于该矩阵与一致矩阵的差距）。<h4 id="一致性矩阵的验证"><a href="#一致性矩阵的验证" class="headerlink" title="一致性矩阵的验证"></a>一致性矩阵的验证</h4></li><li>一致性指标CI： CI = 最大特征值-n/n-1</li><li>查找平均随机一致性指标RI</li><li>计算一致性比例CR：CR = CI/RI</li><li>判断一致性：CR&lt;0.1,则认为该矩阵的一致性可以接受；否则需要修正。<h4 id="权重计算（算术平均法）"><a href="#权重计算（算术平均法）" class="headerlink" title="权重计算（算术平均法）"></a>权重计算（算术平均法）</h4></li><li>由一直矩阵进行归一化处理：<br><img src="https://i.imgur.com/wewwN9l.png" alt><br>以上图为例进行归一化：<br>苏杭 = 1/（1+1/2+1/4）<br>北戴河 = 1/（2+1+1/2）<br>桂林 = 1/（4+2+1）</li><li>由不一致矩阵进行归一化：<br><img src="https://i.imgur.com/jfP4t1g.png" alt><br>分别按照上述方法计算三列的（按列进行归一化），进行取平均值。<br>还有三种方法，见第一个视频的40-46分钟。</li></ol><p><strong>然后还要求几种条件的权重（景色、花费、交通等等）</strong>（用上述的方法：先填写比较程度，然后一致性处理，然后计算权重等等）</p><h3 id="指标填入"><a href="#指标填入" class="headerlink" title="指标填入"></a>指标填入</h3><p>将  地方的权重值、指标的权重值  分别填入重要度表格中。</p><h3 id="计算得分"><a href="#计算得分" class="headerlink" title="计算得分"></a>计算得分</h3><p>计算三个地方的得分，将指标权重与对应的地方的权重相乘，然后将五个指标乘后结果相加。<br><img src="https://i.imgur.com/ByTdLiZ.png" alt><br>比如：苏杭得分 = 0.5954<em>0.2636+0.0819</em>0.4758+0.4286<em>0.0538+0.6337</em>0.0981+0.1667*0.1087<br>用excel可以计算。方法：在另一个格子按=，然后选格，然后选择加减乘除就可以了。F4锁定表格，可以选不相邻的。</p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>分别用平均值法、几何法、特征值法求处权重；然后计算一致性指标、判断一致性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目标：需要评价的目标<br>方案：可以选择的方案<br>准则：评价的指标、准则<br><img src="https://i.imgur.com/zyTIcqR.png" alt><br>比较表格，通过这八个表格来填写。右边的五个小的，得到五个权重指标。左边三个大的得到每一个目的地五个指标的得分，然后对应指标的权重与得分相乘。<br>50分钟后，教制图。</p><h2 id="Mtalb实现"><a href="#Mtalb实现" class="headerlink" title="Mtalb实现"></a>Mtalb实现</h2><p>假设已知变量：6*6的矩阵A</p><ol><li>算术平均法求权重</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">%首先标准化矩阵</span><br><span class="line"></span><br><span class="line">n = 6;</span><br><span class="line">SUMA = sum(A);%对A按列求和，得到一个一行六列的矩阵</span><br><span class="line">SUMA = repmat(SUMA,n,1);  %将A平铺产生一个新矩阵，新矩阵的行数为第一个数字乘A的行数；新矩阵的列数为第二个数字乘是A的列数。得到一个六行六列的矩阵</span><br><span class="line">Stand_A = A./SUMA;%每个元素除以每一列之和，得到标准化矩阵。得到一个六行六列矩阵</span><br><span class="line"></span><br><span class="line">%然后求权重</span><br><span class="line"></span><br><span class="line">SUM1 = sum(Stand_A,2)%对标准矩阵按行求和，得到一个列向量</span><br><span class="line">SUM1 = SUM1./n%最终得到的权重</span><br></pre></td></tr></table></figure><ol start="2"><li><p>几何平均法求权重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = 6;%矩阵阶数 </span><br><span class="line">ProductA = prod(A,2);%矩阵每行种所有元素相乘，生成一个列向量（1*6）</span><br><span class="line">ProductA = ProductA.^(1/n);%将矩阵种每个元素开n次方</span><br><span class="line">ProductA = ProductA./sum(ProductA);%得到最终结果</span><br></pre></td></tr></table></figure></li><li><p>特征值法求权重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = 6;</span><br><span class="line">[V,D] =eig(A);%V是特征向量做列向量构成的矩阵；D是特征值构成的对角矩阵。</span><br><span class="line">Max_eig = max(max(D));%里面的max返回最大列向量；外面的max返回列向量中最大的数。</span><br><span class="line">[R,C] = find(D == Max_eig,1);%找到D中第一个与Max_eig相等的元素，并记录位置。</span><br><span class="line">ans = V(:,c) ./ sum(V(:,c))%最终结果</span><br></pre></td></tr></table></figure></li></ol><h1 id="第四篇—预测类问题-插值算法"><a href="#第四篇—预测类问题-插值算法" class="headerlink" title="第四篇—预测类问题(插值算法)"></a>第四篇—预测类问题(插值算法)</h1><p>当数据较少的时候，这时通过一些数学方法，模拟数据的产生一些新的有比较准确的值。<br>样本量多，用拟合；样本量少，用插值。</p><h2 id="一维数据插值的概念"><a href="#一维数据插值的概念" class="headerlink" title="一维数据插值的概念"></a>一维数据插值的概念</h2><ol><li>有n+1个点。</li><li>要有插值区间[a,b] 。</li><li>有一个函数f(x)过这n+1个点。</li><li>求f(x)的过程叫<strong>插值法</strong>。<h2 id="几种一维数据的插值形式"><a href="#几种一维数据的插值形式" class="headerlink" title="几种一维数据的插值形式"></a>几种一维数据的插值形式</h2></li><li>插值多项式：f(x)为次数不超过n的代数多项式。</li><li>分段插值：P(x)为分段多项式。</li><li>三角插值：P(x)为三角多项式。<br>前两种，尤其是第二种比较常见。<h2 id="一维数据插值"><a href="#一维数据插值" class="headerlink" title="一维数据插值"></a>一维数据插值</h2><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3></li><li>三次埃米特插值：直接调用Matlab函数：pchip(x,y,new_x);x是点横坐标；y是点纵坐标；new_x是要插入的点的横坐标。</li><li>三次样条插值：直接调用Matlab函数：splin((x,y,new_x);用法同上。<h3 id="Matlab实现-1"><a href="#Matlab实现-1" class="headerlink" title="Matlab实现"></a>Matlab实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%三次埃米特插值</span><br><span class="line">x = -pi:pi; %以1为间距生成-pi到pi的等差数列。</span><br><span class="line">y = sin(x);</span><br><span class="line">new_x = -pi:0.1:pi;%以0.1为间距生成-pi到pi的等差数列。</span><br><span class="line">p = pchip(x,y,new_x);%埃米特插值法计算p。</span><br><span class="line">plot(x,y,&apos;bo&apos;,new_x,p,&apos;r-&apos;)%绘制图像。</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%三次样条插值</span><br><span class="line">x = -pi:pi;</span><br><span class="line">y = sin(x);</span><br><span class="line">new_x = -pi:0.1:pi;</span><br><span class="line">p = pchip(x,y,new_x);</span><br><span class="line">p1 = spline(x,y,new_x);</span><br><span class="line">plot(x,y,&apos;bo&apos;,new_x,p,&apos;r--&apos;,new_x,p1,&apos;g--&apos;)</span><br></pre></td></tr></table></figure><h2 id="n维数据插值"><a href="#n维数据插值" class="headerlink" title="n维数据插值"></a>n维数据插值</h2><h2 id="实际使用-1"><a href="#实际使用-1" class="headerlink" title="实际使用"></a>实际使用</h2><p>p = interpn(x1,x2,···,xn,y,new_x1,new_x2,···,new_xn,method):method为要使用的插值方法，包括</p><ol><li>‘linear’：线条插值</li><li>‘cubic’：三次插值</li><li>‘spline’：三次样条插值（最为准确）</li><li>‘nearest’：最邻近插值</li></ol><h2 id="预测实例–人口预测"><a href="#预测实例–人口预测" class="headerlink" title="预测实例–人口预测"></a>预测实例–人口预测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%人口预测</span><br><span class="line">pop = [133126,133770,134413,135069,135738,136427,137122,137866,138639,139538];</span><br><span class="line">%过去几年人口的数据</span><br><span class="line">year = 2009:2018;%已知年份</span><br><span class="line">new_x = 2019:2021%要预测的年份</span><br><span class="line">p1 = pchip(year,pop,new_x);%埃米特插值法</span><br><span class="line">p2 = spline(year,pop,new_x);%样条插值法</span><br><span class="line">plot(year,pop,&apos;ro&apos;,new_x,p1,&apos;r-&apos;,new_x,p2,&apos;g--&apos;)</span><br></pre></td></tr></table></figure><p><strong><em>插值和拟合的区别：n&gt;30时，数据量比较大，则需要用拟合。</em></strong></p><h2 id="拟合算法"><a href="#拟合算法" class="headerlink" title="拟合算法"></a>拟合算法</h2><p>拟合算法的思想：拟合问题不需要曲线一定过给定的点。你和问题的目标是寻求一个函数（曲线），使得该曲线在某种准则下与所有的数据点距离最为接近。<br>由于多样本点时次数过高，造成龙格现象，因此出现了拟合。</p><h1 id="第五篇—多元分析法"><a href="#第五篇—多元分析法" class="headerlink" title="第五篇—多元分析法"></a>第五篇—多元分析法</h1><p>可用于聚类分析(方便画图)、回归分析，但不可用于评价类问题。</p><h2 id="主成分分析法"><a href="#主成分分析法" class="headerlink" title="主成分分析法"></a>主成分分析法</h2><p>当研究问题涉及到多变量且变量之间存在很强的相关性时，通过主成分分析法对数据进行简化。<br>主成分分析法是一种降维算法，能够将多个指标转化为少数几个主成分。<br>原则：用较少变量替代原来较多的变量，且尽量保存之前的信息。</p><h3 id="主成分分析-PCA-的思想"><a href="#主成分分析-PCA-的思想" class="headerlink" title="主成分分析(PCA)的思想"></a>主成分分析(PCA)的思想</h3><ol><li><p>根据n个样本、p个指标，<strong>构成样本矩阵x</strong></p></li><li><p>首先对样本矩阵标准化处理(调用zscore(x)函数)：<br>&lt; 按列计算均值和按列计算标准差。<br>&lt; 标准化数据为：<img src="https://i.imgur.com/4htW40V.png" alt></p></li><li>计算标准化矩阵的协方差矩阵(就是相关系数矩阵)R。<br>&lt;公式是：<blockquote><p><img src="https://i.imgur.com/DQmJppl.png" alt><br>注：以上两步可以合并为一步，直接求相关系数矩阵<br>公式为：<img src="https://i.imgur.com/UVmT5UR.png" alt><br><strong>直接调用corrcoef()函数来得到相关系数矩阵。</strong></p></blockquote></li><li>计算R的特征值(n1,n2,n3…)和特征向量，调用eig()函数可以得到。</li><li>计算主成分贡献率(ni/特征值之和)和累计贡献率(从1到该成分贡献率之和)（ni为该成分的特征值）。</li><li>写出主成分（解释主成分代表的含义）（判断条件为：累计率超过80%的特征值对应的主成分）。</li><li>主成分(F)：F1 =特征向量1<em>样本1+···+特征向量n</em>样本n</li><li>使用F进行相关操作（聚类、回归）<h3 id="实际使用-2"><a href="#实际使用-2" class="headerlink" title="实际使用"></a>实际使用</h3></li></ol><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>题目如下：<br><img src="https://i.imgur.com/Z8tCzHs.jpg" alt></p><ol><li>题中给了相关系数矩阵(实际使用中，要自己列出样本矩阵，然后调用corrvef函数求相关系数矩阵)。<br>还可以通过excel将数据可视化（相关系数越大，颜色越重）<br>&lt; 方法：通过格式设置—&gt;行高—&gt;改为50—&gt;条件格式—&gt;色阶—&gt;管理规则。</li><li>计算得到特征向量、特征值。<br><img src="https://i.imgur.com/zT65ary.jpg" alt></li><li>根据贡献率求得主成分，并根据特征向量为三个主成分命名<br>&lt; 命名的依据与xi系数的正负，大小有关。</li></ol><h4 id="Matlab实现-2"><a href="#Matlab实现-2" class="headerlink" title="Matlab实现"></a>Matlab实现</h4><p>代码和题不一致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">load data.xlxs;% 1.导入数据后默认存储为x</span><br><span class="line">[n,p] = size(x);% 2.计算样本数量、指标数量</span><br><span class="line">X = zscore(x);% 3.将x标准化处理</span><br><span class="line">R = COV(X);% 4.计算样本协方差(相关系数矩阵)矩阵</span><br><span class="line">% 前两步可以合并为: R = corrcoef(x)</span><br><span class="line">[V,D] = eig(R);% 5.计算得到V特征向量；D特征值的对角矩阵</span><br><span class="line">D = diag(D);%将D转为列向量(从小到大，不符合要求，要求为从大到小)</span><br><span class="line">D = D(end:-1:1);%从大到小，重新排列</span><br><span class="line">G = D/sum(D);%计算贡献率</span><br><span class="line">LG = cumsum(D)/sum(D);%计算累计贡献率</span><br><span class="line">V = rot90(V)&apos;;%将V逆时针旋转90度,然后转置，实现列颠倒(V的每一列与D一一对应D颠倒后V也要颠倒)</span><br><span class="line">%以上部分为用来展示在论文中的特征值、特征向量、贡献率、累计贡献率</span><br><span class="line">%以下为根据累计贡献率计算需要的主成分的值</span><br><span class="line">m = input(&apos;输入需要的主成份值&apos;)；%输出主成分指标矩阵</span><br><span class="line">F = zeros(n,m);%初始化主成分指标矩阵，行数为样本数，列数为主指标数</span><br><span class="line">for i = 1:m</span><br><span class="line">ai = V(:,i)&apos;;%将第i个指标对应的特征向量取出并转置为行向量</span><br><span class="line">Ai = repmat(ai,n,1);</span><br><span class="line">F(:,i) = sum(Ai.*X,2);%sum(  ,2)包含每一行总和的列向量</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h2 id="主成分聚类"><a href="#主成分聚类" class="headerlink" title="主成分聚类"></a>主成分聚类</h2><p>得到的主成分指标的特征向量，用它来进行Spss聚类，绘制出聚类效果图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">第一主成分第二主成分</span><br><span class="line">5.4264428242.466610071</span><br><span class="line">2.0064021720.044897784</span><br><span class="line">-0.7695772080.580486019</span><br><span class="line">-1.8487218310.404449961</span><br><span class="line">-1.8267260620.509910414</span><br><span class="line">-1.3135558720.844834476</span><br><span class="line">-1.8597657660.15135913</span><br><span class="line">-1.9275746390.636691716</span><br><span class="line">5.866580082-0.195590149</span><br><span class="line">0.407206443-0.311959647</span><br><span class="line">3.5839360230.531841117</span><br><span class="line">-1.796734483-0.519304406</span><br><span class="line">0.201157205-1.337538882</span><br><span class="line">-2.234432278-1.867172919</span><br><span class="line">-0.1474639770.983842797</span><br><span class="line">-1.947265673-0.388124368</span><br><span class="line">0.219021415-0.203553132</span><br><span class="line">-0.717010904-0.247235911</span><br><span class="line">5.583541617-3.071999293</span><br><span class="line">-0.251547629-2.058477339</span><br><span class="line">-1.15751891-1.913072019</span><br><span class="line">1.1156184440.409970592</span><br><span class="line">-0.5336503850.041788916</span><br><span class="line">-1.298147689-0.341976439</span><br><span class="line">0.4357335240.479094465</span><br><span class="line">0.4373180482.36499945</span><br><span class="line">-0.859474363-0.501061268</span><br><span class="line">-1.5494234840.526219683</span><br><span class="line">-1.0451919360.426094042</span><br><span class="line">-1.5017110160.906911419</span><br><span class="line">-0.6974636910.64706372</span><br></pre></td></tr></table></figure></p><h2 id="主成分回归"><a href="#主成分回归" class="headerlink" title="主成分回归"></a>主成分回归</h2><p>在视频主成分分析的后面，没有看。</p><h1 id="第六篇—预测类问题"><a href="#第六篇—预测类问题" class="headerlink" title="第六篇—预测类问题"></a>第六篇—预测类问题</h1><h2 id="灰色预测模型"><a href="#灰色预测模型" class="headerlink" title="灰色预测模型"></a>灰色预测模型</h2><p>灰色系统(数据集)：部分信息已知，部分信息位置。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>对原始数据进行生成处理来寻找系统变动的规律，并生成有较强规律性的数据序列，然后建立相应的微分方程模型，从而预测事物未来发展的状况。</p><h3 id="最简单的灰色预测模型GM-1-1-模型"><a href="#最简单的灰色预测模型GM-1-1-模型" class="headerlink" title="最简单的灰色预测模型GM(1,1)模型"></a>最简单的灰色预测模型GM(1,1)模型</h3><p>一阶微分方程，一个变量<br>GM(1,1)使用原始的<strong>离散非负数据列</strong>，通过依次累加生成削弱随机性的较有规律的新的离散数据列，然后通过建立微分方程模型，得到在离散处的解经过累减生成的原始数据的近似估计值，从而预测原始数据的后续发展。</p><h4 id="数据的准备"><a href="#数据的准备" class="headerlink" title="数据的准备"></a>数据的准备</h4><p>原始数据列：x(0) = x(0)(1),x(0)(2),···,x(0)(n)<br>累加数据列：x(1) = x(1)(1),x(1)(2),···,x(1)(n)[其中:x(1)(n)=x(0)(1)+···+x(0)(n)]<br>紧邻均值生成数据列：z = z(1),z(2),···,z(n)[其中:z(m) = 0.5<em> x(1)(m)+0.5</em> x(m-1)]</p><h4 id="模型的基本形式"><a href="#模型的基本形式" class="headerlink" title="模型的基本形式"></a>模型的基本形式</h4><p>x(0)(k)+a*z(k) = b   【便于理解的形式：y-kx = b】<br>b:灰作用量<br>-a:发展系数</p><h3 id="应用步骤"><a href="#应用步骤" class="headerlink" title="应用步骤"></a>应用步骤</h3><p>见司守奎类似的算法与应用P400。</p><h3 id="Matlab实现-3"><a href="#Matlab实现-3" class="headerlink" title="Matlab实现"></a>Matlab实现</h3><p>具体实现预测城市噪声。<br>参见算法与应用–灰色预测例1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">%导入数据，并将数据转化为行向量</span><br><span class="line">[~,~,raw] = xlsread(&apos;GM.xlsx&apos;,&apos;Sheet1&apos;,&apos;A2:C8&apos;);</span><br><span class="line">data = reshape([raw&#123;:&#125;],size(raw));</span><br><span class="line">data = data(:,3)&apos;;</span><br><span class="line"></span><br><span class="line">jibi = data(1:6)./data(2:7);    %计算级比</span><br><span class="line">for i = 1:6         %判断级比有没有问题</span><br><span class="line">    if(jibi(i)&gt;=0.982)</span><br><span class="line">        if(jibi(i)&lt;=1.0098)</span><br><span class="line">            a = 1;  %没问题</span><br><span class="line">        else</span><br><span class="line">            a = 0;  %有问题</span><br><span class="line">        end</span><br><span class="line">    else</span><br><span class="line">        a = 0;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">if(a==0)        %如果有问题则显示出错</span><br><span class="line">    disp(&quot;错误&quot;)</span><br><span class="line">end</span><br><span class="line">if(a==1)        %没有问题则继续进行</span><br><span class="line">    x1 = data&apos;;        %取后六位数据</span><br><span class="line">    x2 = cumsum(data)&apos;;%进行累加</span><br><span class="line">    %求微分方程的系数</span><br><span class="line">    B = [-0.5*(x1(1:6)+x2(2:7)),ones(6,1)];</span><br><span class="line">    Y = data(2:7)&apos;;</span><br><span class="line">    u = B\Y;</span><br><span class="line">    syms x(t)</span><br><span class="line">    x = dsolve(diff(x)+u(1)*x==u(2),x(0) == data(1));   %求得微分方程符号解</span><br><span class="line">    xt = vpa(x,6)   %以小数形式显示出来</span><br><span class="line">    yuce = subs(xt,t,[0:6]);     %将已知值对应的序号带入，用来测试</span><br><span class="line">    yuce =double(yuce);          %转化为数值类型，便于进行差分（预测值）</span><br><span class="line">    yuce = [data(1),diff(yuce)]  %进行差分运算（得到预测值）</span><br><span class="line">    cancha = data-yuce;</span><br><span class="line">    cancha = abs(cancha./data)   %计算残差</span><br><span class="line">    piancha = 1 - (1 - 0.5*u(1))/(1+0.5*u(1))*jibi%计算级比偏差</span><br><span class="line">    %使用 --- 预测四个未知数</span><br><span class="line">    yuce1 = subs(xt,t,[0:10]);</span><br><span class="line">    yuce1 =double(yuce1);</span><br><span class="line">    yuce1 = [data(1),diff(yuce1)]</span><br><span class="line">end</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><h1 id="第七篇—回归分析"><a href="#第七篇—回归分析" class="headerlink" title="第七篇—回归分析"></a>第七篇—回归分析</h1><p>## </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好好学习Matlab。&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>PID学习笔记</title>
    <link href="http://linmushen.com/2019/08/13/PID%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/08/13/PID学习笔记/</id>
    <published>2019-08-13T06:38:03.000Z</published>
    <updated>2019-08-18T16:13:04.306Z</updated>
    
    <content type="html"><![CDATA[<p>潜心学习技术，最近发现了一篇比较好的介绍PID的文章。学习并记录一下。<br><a id="more"></a><br>PID控制是对偏差进行比例，积分和微分的控制。PID由三个单元组成，分别是比例单元，积分单元，微分单元。</p><h1 id="位置闭环控制"><a href="#位置闭环控制" class="headerlink" title="位置闭环控制"></a>位置闭环控制</h1><h2 id="PID简介"><a href="#PID简介" class="headerlink" title="PID简介"></a>PID简介</h2><p>位置闭环控制是根据编码器的脉冲累加测量电机的位置信息，并与目标值进行比较，进而得到控制偏差，然后对偏差进行比例、积分、微分进行控制。使偏差趋近于0。</p><h2 id="PID理论知识"><a href="#PID理论知识" class="headerlink" title="PID理论知识"></a>PID理论知识</h2><p>1）PID公式<br><img src="https://i.imgur.com/j5YKEuO.png" alt><br>2）符号含义<br><img src="https://i.imgur.com/ICGUcUc.png" alt></p><h2 id="控制原理"><a href="#控制原理" class="headerlink" title="控制原理"></a>控制原理</h2><p><img src="https://i.imgur.com/JJfTRfg.png" alt><br>其中PID控制器，是一个软件实现过程（比如程序里的一个函数）。</p><h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><p>通过改变KP,KI,KD的值实现调参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int Position_PID(int Encoder,int Targe)//入口参数为位置测量值和位置目标值</span><br><span class="line">&#123;</span><br><span class="line">Static float Bias,Pwm,Integral_bias,Last_Bias;  </span><br><span class="line">Bias = Encoder-Target;//计算偏差</span><br><span class="line">Interal_bias+=Bias;//用累加法，求出偏差的积分</span><br><span class="line">Pwm=Position_KP*Bias+Position_KI*Integral_bias+Position_KD*(Bias-Last_Bias);//根据PID计算Pwm输出值</span><br><span class="line">Last_Bias=Bias;//保存上一次偏差</span><br><span class="line">return Pwm;//返回Pwm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在中断服务函数中调用这个函数并将输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PWM = Position_PID(Encoder,Targe)</span><br></pre></td></tr></table></figure></p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>1）稳定性：主要评估指标为最大超调量，最大超调量是指响应曲线的最大峰值与稳态值的差。<br>2）快速性：主要评估指标为上升时间，上升时间是指响应工作状态从原始工作状态出发，第一次到达输出稳定值所需要的时间，是评估系统快速性的一个重要指标。<br>3）准确性：主要评估指标为静差，静差是被控制量与给定值之差，一般用于衡量系统的准确性。<img src="https://i.imgur.com/5tp9brf.png" alt></p><h2 id="调参注意事项"><a href="#调参注意事项" class="headerlink" title="调参注意事项"></a>调参注意事项</h2><p>P：用于提高响应速度。<br>I：用于减小静差。<br>D：用于抑制震荡。<br>一般调参时，先将I值和D值设置为0，然后把P值从0逐渐增大，直到系统震荡。<br>静差一般是在P值较小，且I值为0的时候出现的。所以增大P值可以一定程度上的消除静差，提高响应速度，但会导致系统震荡。<br>加入D值后，震荡得到抑制，但响应速度变慢了。<br>所以一般调节经验可以总结为：先只P控制，增大P直至系统震荡之后加入D控制，消除一点震荡后，再次调节P和I参数。<br>控制难度取决于系统转动惯量和对相应速度的要求。转动惯量越小，对相应速度要求越低，PID参数就越不敏感。</p><h1 id="速度闭环控制"><a href="#速度闭环控制" class="headerlink" title="速度闭环控制"></a>速度闭环控制</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;潜心学习技术，最近发现了一篇比较好的介绍PID的文章。学习并记录一下。&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>破解论文</title>
    <link href="http://linmushen.com/2019/08/12/%E7%A0%B4%E8%A7%A3%E8%AE%BA%E6%96%87/"/>
    <id>http://linmushen.com/2019/08/12/破解论文/</id>
    <published>2019-08-12T01:58:55.000Z</published>
    <updated>2019-09-08T13:29:28.438Z</updated>
    
    <content type="html"><![CDATA[<p>为了准备数学建模竞赛，力求在假期剩余的十几天中，破解七篇优秀论文。<br><a id="more"></a></p><p>使用软件：Excel、作图软件origin、Visio、SPSS、matlab</p><p>论文写作：</p><ol><li>论文在20-25页左右，加上附录也不要超过40页。</li><li>用专业的visio绘图，效果更好。</li></ol><p>题型分布：</p><ol><li>A题需要强大的工科、物理学背景，需要比较好的数学基础、查阅论文能力。一般考察建模同学实力，完全自主建模，然后matlab实现</li><li>B题社会性比较强，偏于统计学方法，相对入手简单，好做。</li></ol><h1 id="第一篇优秀论文"><a href="#第一篇优秀论文" class="headerlink" title="第一篇优秀论文"></a>第一篇优秀论文</h1><h2 id="模型一部分"><a href="#模型一部分" class="headerlink" title="模型一部分"></a>模型一部分</h2><h3 id="模型准备"><a href="#模型准备" class="headerlink" title="模型准备"></a>模型准备</h3><p>建立坐标系，为各个结构件命名。<br>（以锚和锚链的交点为原点，建立坐标系；将各个结构件从上至下命名为P1~P267）</p><h3 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h3><p>1）对有关结构件进行受力分析，得到各个力之间的方程（模型）。<br>2）确定约束条件（水的深度；吃水深与各个结构件的投影之和等于水的深度）。<br>3）最后要将所有的到的方程汇总写在一起。<br><img src="https://i.imgur.com/HAsNEAC.png" alt></p><h3 id="模型修正"><a href="#模型修正" class="headerlink" title="模型修正"></a>模型修正</h3><p>对特殊情况予以考虑，并得到修正方程（修正模型）。<br>（是否有铁链沉底）。</p><h3 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h3><p>共有两个变量吃水深h以及各个角度Ai。<br>1）将多目标非线性方程（在第二步中汇总的方程）转换为单目标非线性方程（利用角度与吃水深之间的递推关系）。<br>2）将连续型的变量h转化为离散型的（通过规定步长（步长就是累加的数））。<br>3）计算每一个解，由于最优解等于最大的h（h&lt;=2），计算出满足h&lt;=2的最大h即为最优解。<br><img src="https://i.imgur.com/dRzGAao.png" alt><br>4）算法精度检验（暂时不懂）。</p><h2 id="Matlab程序"><a href="#Matlab程序" class="headerlink" title="Matlab程序"></a>Matlab程序</h2><p>当存在一个变量在多个地方有意义时，应该使用矩阵<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">mq = 1200;%重物球质量</span><br><span class="line">n = 210;%锚链数量（22.5/锚链直径）</span><br><span class="line">min = inf;%实际水深和计算得到的水的深度的差值</span><br><span class="line">minh = 0;%修正时目前的计算得到的吃水深</span><br><span class="line">minH = 0;%修正时目前得到的水深（由吃水深度+投影得到的，但不到18m，因此需要修正）</span><br><span class="line">minbeta = 0;%修正时目前的铁桶与竖直方向的夹角。</span><br><span class="line">minthital1 = zeros(1,4);%修正时目前的钢管与竖直方向的夹角。</span><br><span class="line">minthital2 = zeros(1,n)+pi/2;%修正时目前的锚链与竖直方向的夹角的修正办法。</span><br><span class="line">minFt2 = zeros(1,n+1);%创建一个一行211列的零矩阵（）</span><br><span class="line"></span><br><span class="line">for h= 0 : 0.0001 : 2%h从0开始，每次运行完结构内容后加0.0001，一直到2。</span><br><span class="line"></span><br><span class="line">Ft = zeros(1,5);%各钢管、浮标之间的拉力</span><br><span class="line">alpha = zeros(1,5);%各钢管、浮标之间的角度</span><br><span class="line">thital1 = zeros(1,4);%各钢管与竖直方向的夹角</span><br><span class="line">beta = 0；%钢桶与竖直方向夹角</span><br><span class="line">Ft2 = zeros(1,n+1); %各锚链之间的力</span><br><span class="line">gama = zeros(1,n+1);%各锚链之间的夹角</span><br><span class="line">thital2 = zeros(1,n);%各锚链与竖直方向的夹角</span><br><span class="line"></span><br><span class="line">%&#123;以下为浮标部分&#125;%</span><br><span class="line"></span><br><span class="line">v = 24;%风速=24</span><br><span class="line">S = 2*(2-h);%浮标没有没入水中部分的横截面积</span><br><span class="line">m = 1000;%浮标质量为1000kg</span><br><span class="line">rou = 1025; %水的密度</span><br><span class="line">g = 9.8；%重力加速度</span><br><span class="line">V = pi*1^2*h;%体积 = (pi*d^2*h)/4;d^2 = 4</span><br><span class="line">Ffeng = 0.625*S*v^2;%由公式：Ffeng = 0.625*横截面积*风速^2</span><br><span class="line">Ffu = rou*g*V;%浮标浮力</span><br><span class="line">G = m*g;%浮标重力</span><br><span class="line"></span><br><span class="line">if Ffu - G &lt; 0</span><br><span class="line">continue;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">alpha(1) = atan(Ffeng/(Ffu-G));%根据建立的模型，解得浮标与第一个钢管之间的角度</span><br><span class="line">Ft(1) = sqrt(Ffeng^2+(Ffu-Gfu)^2);%根据之前建立的模型，解得浮标与第一个钢管之间的拉力</span><br><span class="line"></span><br><span class="line">%&#123;以下为钢管部分&#125;%</span><br><span class="line"></span><br><span class="line">Vg = 1*pi*0.025^2;%钢管的体积</span><br><span class="line">Ggang = 10*g;%钢管的质量</span><br><span class="line">Fgfu = rou*g*Vg;%钢管的浮力</span><br><span class="line">for i=1:4</span><br><span class="line">alpha(i+1) = atan(Ft(i)*sin(alpha(i))/(Ft(i)*cos(alpha(i))+Fgfu-Ggang));%根据之前得到的模型，分别计算出四个钢管的之间的角度</span><br><span class="line">Ft(i+1) = Ft(i)*sin(alpha(i+1));thital1(i) = atan(Ft(i)*sin(alpha(i))*1/(Fgfu-Ggang)*1/2+Ft(i)*cos(alpha(i))));%根据之前建立的模型，分别计算出来四个钢管之间的作用力</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%&#123;以下是钢桶部分&#125;%</span><br><span class="line"></span><br><span class="line">Vt = 1*pi*0.15^2;%钢桶的体积（钢桶直径为30cm）</span><br><span class="line">Vq = mq/7800;%重物球的体积（由于本题中球的半径没有给出，因此，用铁道密度代指球的密度，用球的质量比球的体积，进而得到球的体积）</span><br><span class="line">Gt = 100*g;%钢桶的重量</span><br><span class="line">Gq = mq*g;%重物球的重量</span><br><span class="line">Ftfu = rou*g*Vt;%桶收到的浮力</span><br><span class="line">Fqfu = rpu*g*Vq;%球受到的浮力</span><br><span class="line"></span><br><span class="line">gama(1) = atan(Ft(5)*sin(alpha(5))/(Ftfu+Ft(5)*cos(alpha(5))-Gt-Gq+Fqfu));</span><br><span class="line">%根据之前得到的模型，计算第一个锚链与钢桶的夹角</span><br><span class="line">bata = atan(Ft(5)*sin(alpha(5)*1/(Ftfu-Gt)*1/2+Ft(5)*cos(alpha(5))*1));%根据之前得到的模型，计算出钢桶与竖直夹角</span><br><span class="line"></span><br><span class="line">%&#123;以下是锚链部分&#125;%</span><br><span class="line"></span><br><span class="line">mm = 0.735;%锚链的质量（查阅资料得到）</span><br><span class="line">roum = 6450;%锚链的密度（查阅资料得到）</span><br><span class="line">Vm = mm/roum;%锚链的体积</span><br><span class="line">Fmfu = rou*g*Vm;%锚链收到的浮力</span><br><span class="line">Gm = mm*g;%锚链受到的重力</span><br><span class="line">Lm = 0.105;%一节锚链的长度（22.05/210得到）</span><br><span class="line"></span><br><span class="line">for i=1:n</span><br><span class="line">gama(i+1)=atan(Ft2(i)*sin(gama(i))/(Ft(i)*cos(gama(i))+Fmfu - Gm));%根据之前得到的模型，计算出每个锚链之间的夹角。</span><br><span class="line"></span><br><span class="line">if gama(i+1)&lt;0%如果夹角小于0，则加派。</span><br><span class="line"></span><br><span class="line">gama(i+1) = gama(i+1)+pi</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Ft2(i+1) = Ft2(i)*sin(gama(i))/sin(gama(i+1));%根据模型，得到各个锚链之间的作用力。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thital2(i) = atan(Ft2(i)*sin(gama(i))*Lm/((Fmfu-Gm)*Lm/2+Ft2(i)*cos(gama(i))*Lm));%根据模型，计算得到每个锚链与竖直方向的夹角。</span><br><span class="line"></span><br><span class="line">if thital2(i)&lt;0%如果夹角小于0，则加派</span><br><span class="line"></span><br><span class="line">thital=thital+pi;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">H = h+1*sum(cos(thital1))+1*cos(beta)+Lm*sum(cos(thital2))%构建几何约束条件，其中sum()为求和函数。</span><br><span class="line"></span><br><span class="line">%&#123;当出现有铁链沉底的情况，需要进行修正&#125;%</span><br><span class="line"></span><br><span class="line">if abs(H-18)&lt;min</span><br><span class="line">minh = h;</span><br><span class="line">min = abs(H-18);</span><br><span class="line">minH = H ;</span><br><span class="line">minthita1 = thita1;</span><br><span class="line">minthita2 = thita2;</span><br><span class="line">minbeta = beta;</span><br><span class="line">minFt2 = Ft2;</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h2 id="模型二部分"><a href="#模型二部分" class="headerlink" title="模型二部分"></a>模型二部分</h2><h3 id="模型准备-1"><a href="#模型准备-1" class="headerlink" title="模型准备"></a>模型准备</h3><p>根据问题一的模型，求解当前风速（36m/s）时的各系统参数（钢管、浮标、吃水深度）。<br>然后根据问题一的模型，将钢桶倾斜角和锚链在锚点处的夹角，计算得到重物球重量范围。</p><h3 id="模型建立-1"><a href="#模型建立-1" class="headerlink" title="模型建立"></a>模型建立</h3><p>1）确定决策变量（决策变量等同于因变量，这个因变量有一定范围）—-本题中的重物球重量。<br>2）确定目标变量（目标变量等同于要求解的变量，等同于自变量）—-本题中有三个自变量（钢桶倾斜角、浮标吃水深度、浮标游动区域）。<br>3）确定约束变量（约束条件一般由题目已知条件）—-本题中锚点210与竖直方向夹角小于16度和钢桶倾斜角小于5度。</p><h3 id="模型建立-2"><a href="#模型建立-2" class="headerlink" title="模型建立"></a>模型建立</h3><p><img src="https://i.imgur.com/7Ns9n2x.png" alt></p><h3 id="模型求解-1"><a href="#模型求解-1" class="headerlink" title="模型求解"></a>模型求解</h3><p>求解方法还是循环搜索算法，但重物球有重量上下范围，同样需要设置步长。<br>先将最开始计算得到参数值带入，从重量球最小值开始带入，计算得到U，每次计算重量球重量球加步长，最后当达到最大值时，输出U。</p><h3 id="灵敏性分析"><a href="#灵敏性分析" class="headerlink" title="灵敏性分析"></a>灵敏性分析</h3><p>灵敏性—决策变量对每一个优化目标的影响（画图），最终得到结论，重量球重量对浮标游动、吃水深影响较小；对钢桶倾角影响大。<br><img src="https://i.imgur.com/FaUHj7H.png" alt></p><h2 id="Matlab程序-1"><a href="#Matlab程序-1" class="headerlink" title="Matlab程序"></a>Matlab程序</h2><p>function [y1,…,yN] = myfun(x1,…,xM) 声明名为 myfun 的函数，该函数接受输入 x1,…,xM 并返回输出 y1,…,yN。此声明语句必须是函数的第一个可执行代码行。有效的函数名称以字母字符开头，并且可以包含字母、数字或下划线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">n=210;%锚链数目</span><br><span class="line"></span><br><span class="line">%&#123;创建几个用于存放数据的矩阵&#125;%</span><br><span class="line"></span><br><span class="line">kxmq=[];</span><br><span class="line">kxh=[];</span><br><span class="line">kxr=[];</span><br><span class="line">kxbeta=[];</span><br><span class="line">zfenshu=[];</span><br><span class="line"></span><br><span class="line">%&#123;开始搜索法，求出每一个mq对应的值&#125;%</span><br><span class="line"></span><br><span class="line">for mq=1800:4100</span><br><span class="line">mq%输出mq</span><br><span class="line">min = inf;%最小值，用于存放实际水深（18m）和计算得到的水深的差值。</span><br><span class="line">minh = 0;%得到的最小吃水深度。</span><br><span class="line">minH = 0;%根据最小吃水深度得到的计算水深。</span><br><span class="line">minbeta = 0;%得到的钢桶最小夹角。</span><br><span class="line">minthita1 = zeros(1,4);%浮标、钢管之间的夹角。</span><br><span class="line">minthita2 = zeros(1,n);%锚链、铁桶之间的夹角。</span><br><span class="line">minFt2 = zeros(1,n+1);%锚链、铁桶、锚之间的拉力。</span><br><span class="line"></span><br><span class="line">for h= 0 : 0.0001 : 2       %h从0开始，每次运行完结构内容后加0.0001，一直到2。</span><br><span class="line"></span><br><span class="line">    Ft = zeros(1,5);    %各钢管、浮标之间的拉力</span><br><span class="line">    alpha = zeros(1,5); %各钢管、浮标之间的角度</span><br><span class="line">    thital1 = zeros(1,4);   %各钢管与竖直方向的夹角</span><br><span class="line">    beta = 0；           %钢桶与竖直方向夹角</span><br><span class="line">    Ft2 = zeros(1,n+1); %各锚链之间的力</span><br><span class="line">    gama = zeros(1,n+1);%各锚链之间的夹角</span><br><span class="line">    thital2 = zeros(1,n);   %各锚链与竖直方向的夹角</span><br><span class="line"></span><br><span class="line">    %&#123;以下为浮标部分&#125;%</span><br><span class="line"></span><br><span class="line">    v = 24;     %风速=24</span><br><span class="line">    S = 2*(2-h);%浮标没有没入水中部分的横截面积</span><br><span class="line">    m = 1000;   %浮标质量为1000kg</span><br><span class="line">    rou = 1025; %水的密度</span><br><span class="line">    g = 9.8；    %重力加速度</span><br><span class="line">    V = pi*1^2*h;   %体积 = (pi*d^2*h)/4;d^2 = 4</span><br><span class="line">    Ffeng = 0.625*S*v^2;    %由公式：Ffeng = 0.625*横截面积*风速^2</span><br><span class="line">    Ffu = rou*g*V;  %浮标浮力</span><br><span class="line">    G = m*g;        %浮标重力</span><br><span class="line"></span><br><span class="line">    if Ffu - G &lt; 0</span><br><span class="line">        continue;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    alpha(1) = atan(Ffeng/(Ffu-G));     %根据建立的模型，解得浮标与第一个钢管之间的角度</span><br><span class="line">    Ft(1) = sqrt(Ffeng^2+(Ffu-Gfu)^2);  %根据之前建立的模型，解得浮标与第一个钢管之间的拉力</span><br><span class="line"></span><br><span class="line">    %&#123;以下为钢管部分&#125;%</span><br><span class="line"></span><br><span class="line">    Vg = 1*pi*0.025^2;  %钢管的体积</span><br><span class="line">    Ggang = 10*g;       %钢管的质量</span><br><span class="line">    Fgfu = rou*g*Vg;    %钢管的浮力</span><br><span class="line">    for i=1:4</span><br><span class="line">        alpha(i+1) = atan(Ft(i)*sin(alpha(i))/(Ft(i)*cos(alpha(i))+Fgfu-Ggang));    %根据之前得到的模型，分别计算出四个钢管的之间的角度</span><br><span class="line">        Ft(i+1) = Ft(i)*sin(alpha(i+1));thital1(i) = atan(Ft(i)*sin(alpha(i))*1/(Fgfu-Ggang)*1/2+Ft(i)*cos(alpha(i))));     %根据之前建立的模型，分别计算出来四个钢管之间的作用力</span><br><span class="line">    end </span><br><span class="line"></span><br><span class="line">    %&#123;以下是钢桶部分&#125;%</span><br><span class="line"></span><br><span class="line">    Vt = 1*pi*0.15^2;   %钢桶的体积（钢桶直径为30cm）</span><br><span class="line">    Vq = mq/7800;       %重物球的体积（由于本题中球的半径没有给出，因此，用铁道密度代指球的密度，用球的质量比球的体积，进而得到球的体积）</span><br><span class="line">    Gt = 100*g;         %钢桶的重量</span><br><span class="line">    Gq = mq*g;          %重物球的重量</span><br><span class="line">    Ftfu = rou*g*Vt;    %桶收到的浮力</span><br><span class="line">    Fqfu = rpu*g*Vq;    %球受到的浮力</span><br><span class="line"></span><br><span class="line">    gama(1) = atan(Ft(5)*sin(alpha(5))/(Ftfu+Ft(5)*cos(alpha(5))-Gt-Gq+Fqfu));</span><br><span class="line">    %根据之前得到的模型，计算第一个锚链与钢桶的夹角</span><br><span class="line">    bata = atan(Ft(5)*sin(alpha(5)*1/(Ftfu-Gt)*1/2+Ft(5)*cos(alpha(5))*1)); %根据之前得到的模型，计算出钢桶与竖直夹角</span><br><span class="line"></span><br><span class="line">    %&#123;以下是锚链部分&#125;%</span><br><span class="line"></span><br><span class="line">    mm = 0.735;     %锚链的质量（查阅资料得到）</span><br><span class="line">    roum = 6450;    %锚链的密度（查阅资料得到）</span><br><span class="line">    Vm = mm/roum;   %锚链的体积</span><br><span class="line">    Fmfu = rou*g*Vm;%锚链收到的浮力</span><br><span class="line">    Gm = mm*g;      %锚链受到的重力</span><br><span class="line">    Lm = 0.105;     %一节锚链的长度（22.05/210得到）</span><br><span class="line"></span><br><span class="line">    for i=1:n</span><br><span class="line">        gama(i+1)=atan(Ft2(i)*sin(gama(i))/(Ft(i)*cos(gama(i))+Fmfu - Gm)); %根据之前得到的模型，计算出每个锚链之间的夹角。</span><br><span class="line"></span><br><span class="line">        if gama(i+1)&lt;0      %如果夹角小于0，则加派。</span><br><span class="line"></span><br><span class="line">            gama(i+1) = gama(i+1)+pi</span><br><span class="line"></span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        Ft2(i+1) = Ft2(i)*sin(gama(i))/sin(gama(i+1));  %根据模型，得到各个锚链之间的作用力。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thital2(i) = atan(Ft2(i)*sin(gama(i))*Lm/((Fmfu-Gm)*Lm/2+Ft2(i)*cos(gama(i))*Lm));      %根据模型，计算得到每个锚链与竖直方向的夹角。</span><br><span class="line"></span><br><span class="line">        if thital2(i)&lt;0     %如果夹角小于0，则加派</span><br><span class="line"></span><br><span class="line">            thital=thital+pi;</span><br><span class="line"></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    H = h+1*sum(cos(thital1))+1*cos(beta)+Lm*sum(cos(thital2))  %构建几何约束条件，其中sum()为求和函数。</span><br><span class="line"></span><br><span class="line">    %&#123;当出现有铁链沉底的情况，需要进行修正&#125;%</span><br><span class="line"></span><br><span class="line">    if abs(H-18)&lt;min    </span><br><span class="line">        minh = h;</span><br><span class="line">        min = abs(H-18);</span><br><span class="line">        minH = H ;</span><br><span class="line">        minthita1 = thita1;</span><br><span class="line">        minthita2 = thita2;</span><br><span class="line">        minbeta = beta;</span><br><span class="line">        minFt2 = Ft2;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%&#123;验证是否满足水深约束，不满足则调用修正函数&#125;%</span><br><span class="line"></span><br><span class="line">if minthia2(n)&gt;pi/2%大于90度，则说明沉底</span><br><span class="line"></span><br><span class="line">[r,minh,minbeta,minthita1,minthita2,minH] = tuodir(n,mq);%调用修正函数，得到新值</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">r = Lm*sum(sin(minthia2))+sum(sin(minbeta))+sum(sin(minthia1));</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%&#123;验证是否满足约束条件，不满足直接结束本次循环，进行下一次&#125;%</span><br><span class="line"></span><br><span class="line">if minthia*180/pi&gt;5</span><br><span class="line">continue;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if (90-minthia2(n)*180/pi)&gt;16;</span><br><span class="line">cintinue;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if abs(minH-18)&gt;0.2</span><br><span class="line">continue;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">kxmq = [kxmq,mq];</span><br><span class="line">kxh = [kxh,minh];</span><br><span class="line">kxbeta = [kxbeta,minbeta];</span><br><span class="line">kxr = [kxr,r];</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">[fenshu,i] = max(-zfenshu);%将矩阵中最优（U最大）的拿出来</span><br><span class="line">fenshu%打印出来</span><br><span class="line">kxmq(i)</span><br></pre></td></tr></table></figure></p><h1 id="第二遍优秀论文"><a href="#第二遍优秀论文" class="headerlink" title="第二遍优秀论文"></a>第二遍优秀论文</h1><p>除去摘要和问题重述，第一部分为问题分析。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="问题一分析"><a href="#问题一分析" class="headerlink" title="问题一分析"></a>问题一分析</h3><p>1）阐述问题：要求建立合理的指标，并分析出租车资源的匹配程度。<br>2）简述述解决问题的答案：建立了两个指标—里程利用率、供求比。<br>3）详述解决问题的方法：得到平衡点N(K<em>,n</em>)和实际点M(K,n)；通过归一化处理后，计算实际点与平衡点之间的距离，距离越大供求匹配度越低。</p><h3 id="问题二分析"><a href="#问题二分析" class="headerlink" title="问题二分析"></a>问题二分析</h3><p>1）阐述问题：要求分析各公司补贴办法是否有用。<br>2）简述解决问题的步骤：</p><ol><li>计算各公司对乘客、对司机的补贴金额。</li><li>设计意愿半径、软件使用人数来计算人均车辆占有率（有多少使用软件的人在司机的意愿半径内）。</li><li>通过人均车辆占有率来检测不同补贴效果。<h3 id="问题三分析"><a href="#问题三分析" class="headerlink" title="问题三分析"></a>问题三分析</h3>1）阐述问题：设计补贴方案并论证合理性。<br>2）简述解决办法</li></ol><h2 id="模型一部分-1"><a href="#模型一部分-1" class="headerlink" title="模型一部分"></a>模型一部分</h2><h3 id="模型准备—指标确立"><a href="#模型准备—指标确立" class="headerlink" title="模型准备—指标确立"></a>模型准备—指标确立</h3><p>1）里程利用率<br>公式：里程利用率K = 载客里程/行驶里程 *100%<br>指标意义：<br>K大—对司机：空驶率较低；对乘客—可供打的车不多。<br>K小—对司机：空驶率较高；对乘客—可供打的车较多。<br>因此，K存在一个平衡值。</p><p>2）供求比率<br>公式：供求比率n = 一定时间内某市场可供额的总和/相应的需求额总和 *100%<br>指标意义：<br>n&gt;1：供大于求。<br>n&lt;1：供小于求。<br>n=1：供等于求。<br>因此，n存在一个平衡值。</p><h3 id="模型建立—指标理想值确定"><a href="#模型建立—指标理想值确定" class="headerlink" title="模型建立—指标理想值确定"></a>模型建立—指标理想值确定</h3><p>1）里程利用率理想值<br>出租车总里程L；出租车载客总里程Ls；乘客需求里程Ld。<br>K = L/Ls；当Ls = Ld时，得到K的平衡值K*。</p><p>本题将L细分为：</p><ul><li>出租车保有量—N</li><li>主要时间段平均运营时间—T</li><li>出租车平均行驶速度—v</li><li>出租车出车率—a</li><li>主要时间段占全天运营时间的比例—b<br>L = TvNa/b</li></ul><p>本题将Ld细分为：</p><ul><li>人口总量—n</li><li>人均出行—o</li><li>出租车出行占所有出行方式的比例—p</li><li>每次出行的平均距离—d</li><li>出租车承担的人民出行周转量（旅客人数与其距离的乘积）—Q</li><li>平均每天乘出租车总人数—s<br>Ld = nopd/s</li></ul><p>得到理想值<br>Ld = Ls<br>最终得到 K* = nopdb/TNsva</p><p>2）供求比率理想值<br>需求订单量D，出租车数量S，n = S/D。<br>以每个人（每个订单）为圆心，以司机的意愿半径为半径，画圆。由于不同地方n的值差异较大，因此将大区域划分为n个小区域。<br>小区域分为三种</p><ul><li>供大于求,D1,n1</li><li>供小于求,D2,n2</li><li>供等于求,D3,n3<br>n = (D1/D)<em>n1+(D2/D)</em>n2+D3/(D*n3)—不是打错了，n3&lt;1，所以n3越大表示供求越平衡，所以需要改动。<br>n1&gt;1，所以n1越大表示供求越不平衡。</li></ul><p>得到理想值n = 1。</p><h3 id="模型建立-3"><a href="#模型建立-3" class="headerlink" title="模型建立"></a>模型建立</h3><p>此时得到了平衡点坐标N(K<em>,n</em>)和实际点M(K,n)，但不是关于原点的情况，不易于求解，因此通过<strong>归一化处理</strong>转化为关于原点的数据，点Q。<br>Q = (K-K<em>/K</em>,n<em>-n/n</em>)<br>综合不平衡度—Q到原点的距离r。</p><p><img src="https://i.imgur.com/vYLHcff.png" alt></p><h3 id="模型求解-2"><a href="#模型求解-2" class="headerlink" title="模型求解"></a>模型求解</h3><p>带入理想值需要的数据，求解得到K<em>，n</em>。<br>利用matlab仿真，得到K，n<br>并分别在时间角度、空间角度下，解得r。</p><h1 id="2016B题"><a href="#2016B题" class="headerlink" title="2016B题"></a>2016B题</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>建立评价指标体系</p><ol><li>选取评价指标</li><li>层次分析法求权重</li><li>根据权重判断指标的可行性</li></ol><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><ol><li>TOPSOS模型求得排序指标值(影响力度)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了准备数学建模竞赛，力求在假期剩余的十几天中，破解七篇优秀论文。&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>OPENMV学习笔记</title>
    <link href="http://linmushen.com/2019/07/29/OPENMV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/07/29/OPENMV学习笔记/</id>
    <published>2019-07-29T11:07:59.000Z</published>
    <updated>2019-08-18T15:15:28.590Z</updated>
    
    <content type="html"><![CDATA[<p>本节根据星瞳科技的OPENMV<br><a id="more"></a></p><h1 id="OPENMV图像处理方法"><a href="#OPENMV图像处理方法" class="headerlink" title="OPENMV图像处理方法"></a>OPENMV图像处理方法</h1><h2 id="感光元件"><a href="#感光元件" class="headerlink" title="感光元件"></a>感光元件</h2><p>sensor模块，用于设置感光元件的参数。</p><blockquote><p>初始化：.resert()–初始化感光元件。<br>设置彩色/黑白：.set_pixformat(sensor.RGB565[彩色]/sensor.GARYSCALE[灰度])<br>设置图像大小：.set_framesize([A])</p><blockquote><p>其中A：sensor.QQVGA: 160x120<br>sensor.QQVGA2: 128x160 (用于 lcd 扩展板)<br>sensor.HQVGA: 240x160<br>sensor.QVGA: 320x240<br>sensor.VGA: 640x480 (只用于OpenMV Cam M7 的灰度图处理图像，或者彩图采集图像)<br>sensor.QQCIF: 88x72<br>sensor.QCIF: 176x144<br>sensor.CIF: 352x288</p></blockquote></blockquote><blockquote><p>跳过一些帧：.skip_frames(n=需要跳过的帧数,time=需要跳过的ms数)。<br>获取一张图象：.snapshot()，拍摄一张照片并返回一个image对象。<br>自动增益：.set_auto_gain(True/False)，使用颜色追踪时，需要关闭(False)自动增益。<br>白平衡：.set_auto_whitebat(True/False)，使用颜色追踪时，需要关闭(False)白平衡。<br>设置窗口ROI：.set_windowing(roi)，roi的格式是(x,y)，取中间的x*y区域。ROI为感兴趣区。<br>设置翻转：.set_hmirror(True)—水平方向翻转；.set_vflip(True)—垂直方向翻转。</p></blockquote><h1 id="图像的基本运算"><a href="#图像的基本运算" class="headerlink" title="图像的基本运算"></a>图像的基本运算</h1><h2 id="获取设置像素点-pixel"><a href="#获取设置像素点-pixel" class="headerlink" title="获取设置像素点(pixel)"></a>获取设置像素点(pixel)</h2><ol><li>image.get_pixel(x,y):返回image中(x,y)处的像素值（若为灰度图，返回灰度值；若为彩色图，返回RGB 的元组）。</li><li>image.set_pixel(x,y):设置image中(x,y)处的像素值（若为灰度图，设置灰度值；若为彩色图，设置(R,G,B)的值。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节根据星瞳科技的OPENMV&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>数学建模</title>
    <link href="http://linmushen.com/2019/07/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    <id>http://linmushen.com/2019/07/21/数学建模/</id>
    <published>2019-07-21T13:14:50.000Z</published>
    <updated>2019-08-21T09:08:46.060Z</updated>
    
    <content type="html"><![CDATA[<p>一些有关数学建模的知识及matlab算法<br><a id="more"></a></p><h1 id="线性规划问题"><a href="#线性规划问题" class="headerlink" title="线性规划问题"></a>线性规划问题</h1><h2 id="纯线性规划问题"><a href="#纯线性规划问题" class="headerlink" title="纯线性规划问题"></a>纯线性规划问题</h2><p>（例程：px1.m 和 px2.m)<br>1.线性规划概念：在一组线性约束条件限制下，求一组线性目标最大或最小的<br>题<br>1）目标函数： max z=4x+3y<br>2) 约束条件(s.t.)：{2x+y&lt;=10,x+y&lt;=8,0&lt;y&lt;=7,x&gt;0<br>3）决策变量：x,y<br>4）可行解：满足约束条件的解X=[x,y,z…]称为可行解<br>5）可行域：所有可行解的集合X…称为可行域<br>注：难点在于选择合适的决策变量</p><p>2.线性规划的Matlab的标准形式及软件求解<br>1）将问题转换成Matlab标准形式：1.其中目标函数应为求最小值。2.目标函数中不等式应为小于等于的形式<br>2）然后根据转换得到的形式列出要创建的列向量f（价值向量）,X,b（资源向量）,beq,lb,ub。<br>3）然后创建矩阵A,Aeq。<br>4）通过[X,fval]=linprog(f,A,b)或<br>[X,fval]=linprog(f,A,b,Aeq,beq)或<br>[X,fval]=linprog(f,A,b,Aeq,beq,lb,nb)求解出最优解(X)和最有解对应的值(fval)<br>注：1.f列向量是目标函数的系数，是一个列向量。<br>2.b是各约束条件（小于等于形式的不等式）所对应的常数构成的列向量。<br>3.A是约束条件（小于等于形式的不等式）系数构成的矩阵。<br>4.lb,ub（列向量）:  lb&lt;=X&lt;=ub.   lb,ub的行数与X的行数相同。如： x1,x2,x3&gt;=0  则lb=[0;0;0]<br>5.当存在lb而没有Aeq，beq时，对应缺失的矩阵用[]代替。如：linprog(f,A,b,[],[],lb)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些有关数学建模的知识及matlab算法&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>stm32学习笔记</title>
    <link href="http://linmushen.com/2019/07/18/stm32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/07/18/stm32学习笔记/</id>
    <published>2019-07-18T13:22:17.000Z</published>
    <updated>2019-08-18T16:13:04.307Z</updated>
    
    <content type="html"><![CDATA[<p>有关STM32知识的笔记<br><a id="more"></a></p><h1 id="关于MDK5的几个使用技巧"><a href="#关于MDK5的几个使用技巧" class="headerlink" title="关于MDK5的几个使用技巧"></a>关于MDK5的几个使用技巧</h1><p>1）TAB键的妙用。首先要介绍的就是TAB键的使用，这个键在很多编译器里面都是用来空位的，每按一下移 空几个位。如果你是经常编写程序的对这个键一定再熟悉不过了。但是 MDK 的 TAB 键和一般 编译器的 TAB 键有不同的地方，和 C++的 TAB 键差不多。MDK 的 TAB 键支持块操作。也就 是可以让一片代码整体右移固定的几个位，也可以通过 SHIFT+TAB 键整体左移固定的几个位。</p><p>2）快速查看一个函数或者变量所定义的地方的功能。 也可能想看看某个变量或数组是在哪个地方定义的等。MDK提供了这样的快速定位的功能只要你把光标放到这个函数/变量的上面，然后右键，弹出菜单栏，我们找到Go to Definition Of‘名字’ 这个地方，然后单击左键就可以快速跳到该函数的定义处（注意要先在 Options for Target 的 Output 选项卡里面勾选 Browse Information 选项，再编译，再定位，否则无法定位！）</p><p>3）快速注释与快速消注释功能。在调试代码的时候，你可能会想注释某一片的代码，来看看执行的情况，MDK提供了这样的快速注释/消注释块代码的功能。也是通过右键实现的。这个操作比较简单，就是先选中你要注释的代码区，然后右键，选择Advanced-&gt;Comment Selection 就可以了。</p><p>4）快速打开头文件功能。在将光标放到要打开的引用头文件上，然后右键选择 Open Document“XXX”，就可以快速打开这个文件了（XXX 是你要打开的头文件名字）</p><p>5）查找替换功能。这个和WORD等很多文档操作的替换功能是差不多的， 在MDK5里面查找替换的快捷键是“CTRL+H”，只要你按下该按钮就会调出查找替换功能。这个和WORD等很多文档操作的替换功能是差不多的。</p><p>6）跨文件查找功能，先双击你要找的函数/变量名，然后再点击IDE上面的左数第九个按键，然后再点击find。</p><h1 id="MDk下C语言基础复习"><a href="#MDk下C语言基础复习" class="headerlink" title="MDk下C语言基础复习"></a>MDk下C语言基础复习</h1><h2 id="六种位操作"><a href="#六种位操作" class="headerlink" title="六种位操作"></a>六种位操作</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li>&amp;：按位与，全1为1，有0为0。</li><li>|：按位或，全0为0，有1为1。</li><li>^：按位异或，相同为0，不同为1。</li><li>~：取反，按位取反，1变0，0变1。（由于是对其本身进行变换，所以~为单目运算符。</li><li>&lt;&lt;：左移，用来将一个数的各位全部向左移N位，右边补零（a=a&lt;&lt;N)</li><li><blockquote><blockquote><p>：右移，与左移作用一样只是方向不同。<br>注：复合运算：a&amp;=1—&gt;a=a&amp;1（其他符号同理）</p></blockquote></blockquote><h3 id="位操作的使用"><a href="#位操作的使用" class="headerlink" title="位操作的使用"></a>位操作的使用</h3>1）与操作的清零作用：如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOA-&gt;CRL&amp;=0XFFFFFF0F;//将4-7位清零</span><br></pre></td></tr></table></figure></li></ol><p>2）或运算设置相应值：如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOA-&gt;CRL|=0X00000040;//设置相应位，不改变其他位</span><br></pre></td></tr></table></figure></p><p>3）提高可读性：如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOx-&gt;BSRR=(((uint32_t)0x01)&lt;&lt;pinpos);//将GPIOx-&gt;BSRR寄存器的第PINPOS位设置为1</span><br></pre></td></tr></table></figure></p><p>其中(uint32_t)0x01是将0x01转换为32位。（因为该寄存器32位）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPIOA-&gt;ODR|=1&lt;&lt;5;</span><br><span class="line">= GPIOA-&gt;ODR=GPIOA-&gt;ODR|(00000001&lt;&lt;5);</span><br><span class="line">= GPIOA-&gt;ODR=GPIOA-&gt;ODR|0100000;//将第二位置1，其余位不变</span><br></pre></td></tr></table></figure></p><h2 id="define宏定义"><a href="#define宏定义" class="headerlink" title="define宏定义"></a>define宏定义</h2><p>常见格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define 标识符 字符串</span><br></pre></td></tr></table></figure></p><p>标识符为所定义宏名，字符串可以是常数，表达式，格式串等。<br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SYSCLK_FREQ_72MHZ 72000000</span><br></pre></td></tr></table></figure><p>此时，SYSCLK_FREQ_72MHZ = 72000000</p><h2 id="ifdef条件编译"><a href="#ifdef条件编译" class="headerlink" title="ifdef条件编译"></a>ifdef条件编译</h2><p>当满足某条件时，对一组语句进行编译；不满足某条件时，则编译另一组语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 标识符</span><br><span class="line">程序段 1</span><br><span class="line">#else</span><br><span class="line">程序段2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>作用是：当标识符用#define定义过，则对程序段1 进行编译，否则编译程序段2。（#else部分可以没有）</p><h2 id="extern变量声明"><a href="#extern变量声明" class="headerlink" title="extern变量声明"></a>extern变量声明</h2><p>extern置于变量或函数前时，表示变量在别的文件中。</p><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>为下文注：子优先级又叫做响应优先级。</p><h2 id="中断寄存器"><a href="#中断寄存器" class="headerlink" title="中断寄存器"></a>中断寄存器</h2><ul><li>ISER[8]：中断使能寄存器，ISER[0]的bit0~bit31对应中断0~31，ISER[1]的bit0~bit27对应中断0~27。通过将对应中断的ISER位置1，使该中断使能。</li><li>ICER[8]：中断除能寄存器，与ISER功能相反（对相应位置1，清除相应中断使能）。</li><li>ISPR[8]：中断挂起寄存器，通过将与中断对应的位置1，可以将正在进行的中断挂起。</li><li>ICPR[8]：中断解挂寄存器，通过将与中断对应的位置1，可以将挂起的中断解挂。</li><li>IABR[8]：中断激活标志位寄存器组，与相应中断对应的位如果为1，则表示该中断正在进行。</li><li>IP[240]：中断优先级控制寄存器组，IP[0]~IP[59]分别对应中断0~59。每个IP[]为8bit（共240个），叫做一个寄存器，该寄存器只用了高四位，分别为抢占优先级和子优先级（抢占优先级在前，子优先级在后）。</li></ul><h2 id="中断分组"><a href="#中断分组" class="headerlink" title="中断分组"></a>中断分组</h2><p>STM32中断分为五组（0~4），其中的不同是不同组中抢占优先级和子优先级对应的位不同。<br>如0组：则0位抢占优先级，4位子优先级；<br>1组：1位抢占优先级，3位子优先级。<br>以此类推。<br>高优先级的中断可以打断低优先级的中断，优先级对应的数字越小，优先级越高。</p><h2 id="优先级的概念"><a href="#优先级的概念" class="headerlink" title="优先级的概念"></a>优先级的概念</h2><p>抢占优先级：抢占优先级大的，可以打断抢占优先级小的。<br>响应优先级：同时触发两个中断时，先响应抢占优先级大的。但抢占优先级相同时，响应优先极大的不能打断抢占优先级小的。</p><h2 id="库函数使用"><a href="#库函数使用" class="headerlink" title="库函数使用"></a>库函数使用</h2><h3 id="中断优先级分组函数"><a href="#中断优先级分组函数" class="headerlink" title="中断优先级分组函数"></a>中断优先级分组函数</h3><p>原型：void NVIC_PriorityGroupConfig(u32_tNVIC_PriorityGroup)<br>作用：对中断优先级进行分组。<br>注意：该函数在只可以被调用一次。<br>使用：NVIC_PriorityGroupConfig(NVIC_PriorityGroup_x)<br>x的范围为0-4。x对应为上述对应x组。</p><h3 id="设置优先级函数"><a href="#设置优先级函数" class="headerlink" title="设置优先级函数"></a>设置优先级函数</h3><p>原型：void NVIC_Init(NVIC_InitTypeDef*InitStruct)<br>作用：1.选定需要确定优先级的中断；2.为中断确定响应优先极大和抢占优先级。<br>使用：1.首先定义一个NVIC_InitTypeDef类型的指针；2.用指针设置结构体内的几个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123; </span><br><span class="line">uint8_t NVIC_IRQChannel;//选定中断</span><br><span class="line">    uint8_t NVIC_IRQChannelPreemptionPriority;   //设置抢占优先级</span><br><span class="line">uint8_t NVIC_IRQChannelSubPriority;    //设置响应优先级</span><br><span class="line">FunctionalState NVIC_IRQChannelCmd;   //使能</span><br><span class="line">&#125; NVIC_InitTypeDef;</span><br></pre></td></tr></table></figure></p><p>调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitTypeDef   NVIC_InitStructure;  </span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;//串口 1 中断  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1 ;// 抢占优先级 1</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; // 子优先级位 2  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;   //IRQ 通道使能  </span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure); //根据上面指定的参数初始化 NVIC 寄存器</span><br></pre></td></tr></table></figure></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>在程序最开始的地方，进行中断分组（调用void NVIC_PriorityGroupConfig(u32_tNVIC_PriorityGroup)）。</li><li>设置用到的中断的优先级。</li></ol><h1 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h1><p>STM32F103共有19个外部中断，0~15对应着GPIOx.0~GPIOx.15（x：A~G。A~G等价)；16中断-&gt;PVD输出；17中断-&gt;RTC闹钟事件；18中断-&gt;USB唤醒事件。</p><h2 id="库函数使用-1"><a href="#库函数使用-1" class="headerlink" title="库函数使用"></a>库函数使用</h2><h3 id="GPIO与外部中断的映射关系的函数"><a href="#GPIO与外部中断的映射关系的函数" class="headerlink" title="GPIO与外部中断的映射关系的函数"></a>GPIO与外部中断的映射关系的函数</h3><p>原型：void GPIO_EXTILineConfig(uint8_t GPIO_PortSource,uint8_t GPIO_PinSource2)<br>参数意义：参数1，GPIOx；参数2，中断x（相当于pin）<br>使用：GPIO_EXTILINEConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2)<br>作用：将端口GPIO_PortSource与中断GPIO_PinSource2来连接起来。</p><h3 id="中断初始化函数"><a href="#中断初始化函数" class="headerlink" title="中断初始化函数"></a>中断初始化函数</h3><p>原型：void EXTI_Init(EXTI_InitTypeDef*EXTI_InitStruct)<br>参数意义：设置结构体成员的结构体指针。<br>作用：设置需要设置的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;</span><br><span class="line">uint32_t EXTI_Line;//设置需要初始化的中断</span><br><span class="line">EXTIMode_TypeDef EXTI_Mode;      //设置模式--&gt;中断\事件（Interrupt\Event）</span><br><span class="line">EXTITrigger_TypeDef EXTI_Trigger;    //设置触发边沿--&gt;下降沿\上升沿\上升和下降（Falling\Rising\Rising_Falling)</span><br><span class="line">FunctionalState EXTI_LineCmd;   //使能(ENABLE)或失能(DISABLE)</span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTI_InitTypeDef  EXTI_InitStructure;</span><br><span class="line">   EXTI_InitStructure.EXTI_Line=EXTI_Line4;    </span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;     </span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; </span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;    </span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br></pre></td></tr></table></figure></p><h3 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h3><p>原型：NVIC_Init(&amp;NVIC_InitStructure)<br>参数意义：与上一章相同。（此处需将变量NVIC_InitStructure.NVIC_IRQChannel设置为EXTIx_IRQn;x代表外部中断x）。<br>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel=EXTI2_IRQn;         //使能按键外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级 2，  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;  //子优先级 2 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;   //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure);                          //中断优先级分组初始化</span><br></pre></td></tr></table></figure></p><h3 id="检查状态函数"><a href="#检查状态函数" class="headerlink" title="检查状态函数"></a>检查状态函数</h3><p>原型：FlagStatus ITStatus EXTI_GetITStauts(uint32_t EXTI_Line)<br>参数意义：指定中断（EXTI_LINEx）<br>使用：EXTIStatus = EXTI_GetFlagStatus(EXTI_Linex)<br>作用：返回指定中断的状态（SET/RESET)</p><h3 id="清除中断标志函数"><a href="#清除中断标志函数" class="headerlink" title="清除中断标志函数"></a>清除中断标志函数</h3><p>原型：void EXTI_ClearITPendingBit(u32_t EXTI_Line)<br>参数意义：指定中断<br>使用EXTI_ClearITPendingBit（EXTI_Linex）<br>作用：一般在中断函数结束之前，清除中断标志位</p><h3 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h3><p>注意：所有中断函数都有固定名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPORT  EXTI0_IRQHandler           </span><br><span class="line">EXPORT  EXTI1_IRQHandler        </span><br><span class="line">EXPORT  EXTI2_IRQHandler          </span><br><span class="line">EXPORT  EXTI3_IRQHandler         </span><br><span class="line">EXPORT  EXTI4_IRQHandler//0~4中断分别对应这几个函数           </span><br><span class="line">EXPORT  EXTI9_5_IRQHandler  //5~9中断公用这一个函数</span><br><span class="line">EXPORT  EXTI15_10_IRQHandler//10~15中断公用这一个函数</span><br></pre></td></tr></table></figure></p><h3 id="一般中断函数的形式"><a href="#一般中断函数的形式" class="headerlink" title="一般中断函数的形式"></a>一般中断函数的形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void EXTIx_IRQHandler()</span><br><span class="line">&#123;</span><br><span class="line">if(EXTI_GetITStatus(EXTI_Linex)!=RESET)//判断终端是否发生</span><br><span class="line">&#123;</span><br><span class="line">函数主体···</span><br><span class="line">EXTI_ClearITPendingBit（EXTI_Line3）；//清除中断标志位</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外部中断使用步骤"><a href="#外部中断使用步骤" class="headerlink" title="外部中断使用步骤"></a>外部中断使用步骤</h2><p>1）初始化GPIO口为输入（要开启的中断所对应的GPIO口）<br>2）开启AFIO时钟</p><blockquote><p>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //②使能 AFIO 时钟 </p></blockquote><p>3）设置IO口与中断的映射关系</p><blockquote><p>如：GPIO_EXTILINEConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2);</p></blockquote><p>4）初始化中断</p><blockquote><p>EXTI_Init(&amp;EXTI_InitStructure);</p></blockquote><p>5）配置中断分组，并且使能该中断<br>6）编写中断服务函数</p><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>自动重装载周期A；cpu时钟频率B；预分频系数C；需要的时间：T<br>(B/C)/A = T<br>//如：时钟频率72M，预分频系数为7200，则：1s对应10000个时钟周期；所需时间T=（1/10000）*A</p><h2 id="定时器种类"><a href="#定时器种类" class="headerlink" title="定时器种类"></a>定时器种类</h2><p>STM32F103共有11个定时器[2个高级定时器（TIM1,TIM8)，4个普通定时器(TIM2-TIM5)，2个基本定时器(TIM6,TIM7)，2个看门狗定时器，1个系统滴答定时器]</p><h2 id="3种计数模式"><a href="#3种计数模式" class="headerlink" title="3种计数模式"></a>3种计数模式</h2><ol><li>向上计数模式：从0开始，计到预设值，产生溢出事件，返回重新计数。</li><li>向下计数模式：从预设值开始，计到0，产生溢出事件，返回重新计时。</li><li>中央对齐模式：从0开始向上计数，计到预设值产生溢出事件，然后从预设值开始向下计数，计数到1后产生溢出事件，然后再从0开始向上计数。</li></ol><h2 id="3种定时器主要功能"><a href="#3种定时器主要功能" class="headerlink" title="3种定时器主要功能"></a>3种定时器主要功能</h2><ol><li>基本定时器主要功能(TIM6,TIM7)：只有基本定定时功能。</li><li>普通定时器主要功能(TIM2-TIM5)：除基本的定时器功能外，可以测量输入信号的脉冲长度或者产生输出波形（PWM和输出比较）。</li><li>高级定时器主要功能(TIM1,TIM8)：除上述功能，还可以控制交直流电机的所有功能。</li></ol><h1 id="普通定时器"><a href="#普通定时器" class="headerlink" title="普通定时器"></a>普通定时器</h1><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ol><li>16位自动装载计数器（向上，向下，向上\向下）</li><li>16位可编程预分频器（分频系数：1~65535）</li><li>4个独立通道（TIMx_CH1~4)，通道作用：A.输入捕获；B。输出比较；C.PWM生成；D.单脉冲模式输出。</li><li>可实现一个定时器控制另一个定时器的同步电路</li></ol><h2 id="触发中断"><a href="#触发中断" class="headerlink" title="触发中断"></a>触发中断</h2><ol><li>中断触发条件：A.计数器溢出或计数器初始化。</li><li>触发事件：计数器启动、停止、初始化或者有内部/外部触发计数。</li><li>输入捕获</li><li>输出比较</li><li>增量编码器或霍尔传感器电路</li><li>触发输入作为外部时钟或者按周期的电路管理</li></ol><h2 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h2><ul><li>TIM_CR1：控制寄存器，功能有：使能定时器，设置计数方向（向上\向下），设置计数对齐方式，设置时钟分频因子。</li><li>TIMx_DIER：中断使能寄存器，功能有：顾名思义，用来允许更新事件所产生的中断。</li><li>TIMx_PSC：预分频寄存器，功能有：对时钟进行分频，作为定时器的时钟。</li><li>TIMx_CNT：定时器的计数器，功能有：存储当前定时器的计数值。</li><li>TIMx_ARR：自动重装载寄存器，功能有：用来设置自动重装载的值（值为空时，寄存器不起作用）。</li><li>TIMx_SR：状态寄存器，功能是：标记当前与定时器相关的中断是否发生。</li></ul><h2 id="库函数使用-2"><a href="#库函数使用-2" class="headerlink" title="库函数使用"></a>库函数使用</h2><h3 id="定时器时钟使能"><a href="#定时器时钟使能" class="headerlink" title="定时器时钟使能"></a>定时器时钟使能</h3><p>原型：void RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIMx,ENABLE)<br>参数意义：指明是使能哪一个定时器。x范围是2~5（普通定时器）<br>使用：RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIMx,ENABLE)；使能TIMx定时器。</p><h3 id="初始化定时器"><a href="#初始化定时器" class="headerlink" title="初始化定时器"></a>初始化定时器</h3><p>原型：void TIM_TimeBaseInit(TIM_TypeDef<em>TIMx,TIM_TimeBaseInitTypeDef</em>TIM_TimeBaseInitStruct)<br>参数意义：第一个参数：指定定时器；第二个参数：用于设置初始值的结构体指针。<br>结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;   </span><br><span class="line">uint16_t TIM_Prescaler;//设置分频系数</span><br><span class="line">uint16_t TIM_CounterMode;//设置计数方式(向上计数模式TIM_CounterMode_Up；向下计数模式：TIM_CounterMode_Down)</span><br><span class="line">uint16_t TIM_Period;//设置自动重载计数周期值</span><br><span class="line">uint16_t TIM_ClockDivision; //设置时钟分频因子</span><br><span class="line">uint8_t TIM_RepetitionCounter;//高级定时器使用</span><br><span class="line">&#125; TIM_TimeBaseInitTypeDef;</span><br></pre></td></tr></table></figure></p><p>使用：以TIM3为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">TIM_TimeBaseStructure.TIM_Period = 5000;//自动装载周期：5000</span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =7199;//分频系数：7199</span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision =TIM_CKD_DIV1;//设置时间分频因子</span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数方式：向上计数模式</span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure);</span><br></pre></td></tr></table></figure></p><h3 id="设置允许更新"><a href="#设置允许更新" class="headerlink" title="设置允许更新"></a>设置允许更新</h3><p>原型：void TIM_ITConfig(TIMx,TIM_IT,ENABLE/DISABLE)<br>参数意义：第一个参数：指明定时器；第二个参数指明中断类型（由什么触发中断；如，更新中断，输入捕获中断）；第三个参数：使能/失能<br>使用：以TIM3为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_ITConfig(TIM3,TIM_IT_Updata,ENABLE);//设置为更新中断</span><br></pre></td></tr></table></figure></p><h3 id="使能TIMx函数"><a href="#使能TIMx函数" class="headerlink" title="使能TIMx函数"></a>使能TIMx函数</h3><p>原型：void TIM_Cmd(TIM_TypeDef*TIMx,ENABLE/DISABLE)<br>参数意义：第一个参数：指明定时器；第二个参数：使能/失能。<br>使用：TIM_Cmd(TIMx,enable/disable)</p><h3 id="检查状态函数-1"><a href="#检查状态函数-1" class="headerlink" title="检查状态函数"></a>检查状态函数</h3><p>原型：ITStatus TIM_GetITStatus(TIM_TypeDef*TIMx,中断类型)<br>参数意义：第一个参数：指明定时器；第二个参数：指明中断类型。<br>作用：返回状态值SET/RESET.<br>使用：TIM_GetStatus(TIMx,TIM_IT_Upadata)        //更新类型中断</p><h3 id="清除标志位函数"><a href="#清除标志位函数" class="headerlink" title="清除标志位函数"></a>清除标志位函数</h3><p>原型：void TIM_ClearITPendingBit(TIM_TypeDef*TIMx,中断类型)<br>参数意义：与上相同<br>使用：TIM_ClearITPendingBit(TIM3,TIM_IT_Upadata)</p><h2 id="定时器使用步骤"><a href="#定时器使用步骤" class="headerlink" title="定时器使用步骤"></a>定时器使用步骤</h2><p>1）时钟使能<br>2）初始化定时器（计数模式，自动装载周期，分频因子等）<br>3）允许中断并配置中断类型<br>4）中断优先级设置（调用NVIC库实现）<br>5）使能TIMx<br>6）编写中断服务函数<br>注意：中断服务函数：void TIMx_IRQHandler()<br>设置中断初始化的中断频道：TIMx_IRQn</p><h1 id="PWM输出"><a href="#PWM输出" class="headerlink" title="PWM输出"></a>PWM输出</h1><p>实现：使用TIMx的一个通道，把该通道重映射到GPIO端口，产生PWM。<br>默认：CH1–PA6;CH2–PA7;CH3–PB0;CH4–PB1。<br>部分重映射：CH1–PB4;CH2–PB5;CH3–PB0;CH4–PB1。<br>重映射：CH1–PC6;CH2–PC7;CH3–PC8;CH4–PC9。</p><h2 id="STM32与PWM"><a href="#STM32与PWM" class="headerlink" title="STM32与PWM"></a>STM32与PWM</h2><p>基本定时器（TIM6;TIM7)无法产生PWM。<br>不同定时器（TIM2~TIM5）可以产生四路PWM输出。<br>高级定时器（TIM1;TIM8）可以产生七路PWM输出。</p><h2 id="相关寄存器-1"><a href="#相关寄存器-1" class="headerlink" title="相关寄存器"></a>相关寄存器</h2><p>TIMx_CCMR1/2：捕获/比较模式寄存器，TIMx_CCMR1控制CH1,CH2;TIMx_CCMR2控制CH3，CH4。主要使用其模式设置功能。<br>TIMx_CCER:捕获/比较使能寄存器，顾名思义：使能PWM波。<br>TIMx_CCR1~4：捕获/比较寄存器，输出模式下，该寄存器的值与CNT寄存器的值比较，根据结果产生相应动作。<br>实际使用中，通过修改这个寄存器的值来控制PWM的输出脉宽。（ccr1~4分别对应CH1~4）</p><h2 id="硬件相关"><a href="#硬件相关" class="headerlink" title="硬件相关"></a>硬件相关</h2><p>由于STM32每个通道连接固定的GPIO口，因此，需要用到GPIO的重映射。<br>STM32的重映射是由复用重映射和IP配置寄存器（AFIO_MAPR）控制的。该寄存器的各位描述见STM32开发指南（库函数版）P217。<br>重映射实现</p><h2 id="库函数使用-3"><a href="#库函数使用-3" class="headerlink" title="库函数使用"></a>库函数使用</h2><p>关于极性的问题：<br>如果是PWM1模式 :<br>如果设置TIM_OCPolarity_High     TIMx_CNT&lt;TIMx_CCR输出为高电平   TIMx_CNT&gt;TIMx_CCR输出为低电平<br>如果设置TIM_OCPolarity_Low      TIMx_CNT&lt;TIMx_CCR输出就为低电平  TIMx_CNT&gt;&lt;TIMx_CCR输出就为高电平<br>如果是PWM2模式 :<br>如果设置TIM_OCPolarity_High     TIMx_CNT&gt;TIMx_CCR输出为低电平   TIMx_CNT&lt;TIMx_CCR输出为高电平<br>如果设置TIM_OCPolarity_Low      TIMx_CNT&gt;TIMx_CCR输出就为高电平  TIMx_CNT&lt;TIMx_CCR输出就为低电平</p><h3 id="开启TIM3时钟以及【复用功能时钟（AFIO）】（如果需要的话）"><a href="#开启TIM3时钟以及【复用功能时钟（AFIO）】（如果需要的话）" class="headerlink" title="开启TIM3时钟以及【复用功能时钟（AFIO）】（如果需要的话）"></a>开启TIM3时钟以及【复用功能时钟（AFIO）】（如果需要的话）</h3><p>RCC_APB1PeriphClockCmd(RCC_PAB1Periph_TIM3,ENABLE)    //TIM3时钟使能<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIP,ENABLE)    //使能复用时钟</p><h3 id="设置重映射（如果有需要的话）"><a href="#设置重映射（如果有需要的话）" class="headerlink" title="设置重映射（如果有需要的话）"></a>设置重映射（如果有需要的话）</h3><p>原型：void GPIO_PinRemapConfig(u32_t GPIO_Remap,FunctionalState NewState)<br>参数：第一个参数：GPIO_FullRenmap_TIMx;(重映射)；GPIO_PartialRenmap_TIMx;(部分重映射)；第二个参数：使能/失能<br>使用：GPIO_PinRemapConfig(GPIO_PinRemap_TIM3,ENABLE);TIM3重映射使能</p><h3 id="初始化定时器-1"><a href="#初始化定时器-1" class="headerlink" title="初始化定时器"></a>初始化定时器</h3><p>设置重装值，预分频系数，时钟分割（此时该参数设为0），计数模式</p><h3 id="设置TIMx-CHx的PWM模式"><a href="#设置TIMx-CHx的PWM模式" class="headerlink" title="设置TIMx_CHx的PWM模式"></a>设置TIMx_CHx的PWM模式</h3><p>原型：void TIM_OCxInit(TIM_TypeDef<em>TIMx,TIM_OCInitTypeDef</em>TIM_OCInitStruct)【x代表选中的通道】<br>参数：第一个参数：TIM2、TIM3….<br>第二个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;</span><br><span class="line">uint16_t TIM_OCMode;//设置模式是PWM还是输出比较；PWM下的格式：TIM_OC_PWM2</span><br><span class="line">uint16_t TIM_OutputState;//使能PWM到端口；PWM下的格式：TIM_OutputState_ENABLE</span><br><span class="line">uint16_t TIM_OutputNState;//高级定时器使用。</span><br><span class="line">uint16_t TIM_Pulse;//高级定时器使用</span><br><span class="line">uint16_t TIM_OCPolarity;//设置极性高/低</span><br><span class="line">uint16_t TIM_OCNPolarity;//高级定时器使用</span><br><span class="line">uint16_t TIM_OCIdleState;//高级定时器使用</span><br><span class="line">uint16_t TIM_OCNIdleState;//高级定时器使用</span><br><span class="line">&#125; TIM_OCInitTypeDef;</span><br></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line"></span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; //选择 PWM 模式 2 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性高</span><br><span class="line"></span><br><span class="line">TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure);  //初始化 TIM3 OC2</span><br></pre></td></tr></table></figure></p><h3 id="控制占空比"><a href="#控制占空比" class="headerlink" title="控制占空比"></a>控制占空比</h3><p>原型：void TIM_SetComparex(TIM_TypeDef*TIMx,Compare2)【x代表通道】<br>参数：第一个参数：TIMx；第二个参数：自动重装载寄存器的新值。<br>使用：TIM_SetCompare1(TIM2,重装载值)</p><h2 id="产生PWM值的步骤"><a href="#产生PWM值的步骤" class="headerlink" title="产生PWM值的步骤"></a>产生PWM值的步骤</h2><p>1）使能TIM3的时钟。看需要使能复用功能时钟。<br>2）看需要进行GPIO口映射。<br>3）初始化TIM3。<br>4）设置该定时器的该通道的PWM模式。<br>5）使能TIM3。<br>6）控制占空比。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有关STM32知识的笔记&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>树莓派笔记</title>
    <link href="http://linmushen.com/2019/06/14/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/06/14/树莓派笔记/</id>
    <published>2019-06-14T14:45:13.000Z</published>
    <updated>2019-08-18T16:13:04.311Z</updated>
    
    <content type="html"><![CDATA[<p>记录有关树莓派学习的笔记<br><a id="more"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>核心元件：树莓派 L298N</li><li>需要实现：视觉识别（Opencv） 底层电机驱动</li><li>核心功能：识别赛道图像，沿着白线走</li><li>核心原理：利用二值化（大律法二值化）将白色单独显示出来</li><li>未知问题：<blockquote><p>腐蚀膨胀问题？—一种对图像的处理方法，腐蚀是去掉，膨胀是把图放大<br>缩放倍率？</p></blockquote></li></ol><h1 id="GPIO控制使用"><a href="#GPIO控制使用" class="headerlink" title="GPIO控制使用"></a>GPIO控制使用</h1><ol><li>GPIO–通入输入/输出端口</li><li>wiringPi/RPI.GPIO是需要导入的库函数</li></ol><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ol><li>import RPI.GPIO as GPIO</li><li>设置编码规范： gpio.setmode(gpio.BOARD)<blockquote><p>编码规范：</p><blockquote><p>1）BOARD： 从左到右，从上到下：左边基数，右边偶数：1-40<br>2）BCM：编号侧重 CPU 寄存器，根据 BCM2835 的 GPIO 寄存器编号<br>3）wpi： 编号侧重实现逻辑，把扩展 GPIO 端口从 0 开始编号，这种编号方便编程。</p></blockquote></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录有关树莓派学习的笔记&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>Matlab相关</title>
    <link href="http://linmushen.com/2019/04/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1M/"/>
    <id>http://linmushen.com/2019/04/17/数学建模M/</id>
    <published>2019-04-17T13:59:01.000Z</published>
    <updated>2019-08-18T15:15:28.594Z</updated>
    
    <content type="html"><![CDATA[<p>有一些关于Matlab的知识<br><a id="more"></a></p><h1 id="Matlab知识笔记"><a href="#Matlab知识笔记" class="headerlink" title="Matlab知识笔记"></a>Matlab知识笔记</h1><ul><li>Matlab主要用来处理整个矩阵和数组。</li><li>所有matlab变量都是多维的。</li><li>matlab将数字存储为浮点值</li></ul><h2 id="命令与函数"><a href="#命令与函数" class="headerlink" title="命令与函数"></a>命令与函数</h2><h3 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h3><ol><li>help inv ：显示函数（inv）的帮助信息</li><li>[]  ：创建矩阵</li><li>[]; : 创建一个矩阵但不在命令行中显示出来</li><li>,   ：矩阵行元素分隔符号</li><li>;   ：矩阵列元素分隔符号</li><li>%   : 注释行</li><li>clear ：清理工作空间中的各种变量</li><li>== ：关系运算符：等于</li><li>~= ：关系运算符：不等于</li><li>| ：逻辑或运算</li></ol><h3 id="定义类型"><a href="#定义类型" class="headerlink" title="定义类型"></a>定义类型</h3><ol><li>format short : 定义输出格式为短，显示小数点后四位</li><li>format long : 定义输出格式为长，显示小数点后14（15）位</li><li>format rat：以有理数形式输出<blockquote><p>format只影响输出格式，不影响存储方式 </p></blockquote></li><li>syms x ：定义x为符号变量</li></ol><h3 id="控制流程语句"><a href="#控制流程语句" class="headerlink" title="控制流程语句"></a>控制流程语句</h3><ol><li>if..else if..end : 条件语句，作用与c中类似</li><li>for..end : for循环语句，与c类似</li></ol><h3 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h3><ol><li>n=input(‘…’):输入函数，其中’’之间的是提示字符</li><li>disp(‘….’):显示单引号中字符串</li></ol><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="创建矩阵的函数"><a href="#创建矩阵的函数" class="headerlink" title="创建矩阵的函数"></a>创建矩阵的函数</h3><ol><li>eye(n):创建n阶单位矩阵</li><li>zeros（m,n）：创建m*n阶零矩阵</li><li>zeros(n) :创建n阶方阵</li><li>ones（m,n):创建m*n阶元素全为1的矩阵</li><li>rand（m,n):创建m*n阶元素为从0到1均匀分布的随机数矩阵</li><li>randn(m,n):创建m*n阶均值为0，方差为1的标准正态分布随机矩阵</li><li>round（A）：对矩阵A所有元素进行四舍五入运算</li></ol><h3 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h3><ol><li>inv(A):求矩阵A的逆</li><li>A^-1:用幂运算求矩阵A的逆</li><li>a’ ：a的转置</li><li>inv(a):a的逆矩阵</li><li><ul><li>：执行标准矩阵乘法，计算行与列之间的内积</li></ul></li><li>\ :MATLAB特有的矩阵左除A/B=inv（A)*B</li><li>/ ：matlab特有的矩阵右除B/A=B*inv（A)</li><li>. ：在运算符号前加 . 含义为对应矩阵群运算（元素级运算，即每一个元素之间的运算）<blockquote><ul><li>只有乘除幂运算有相应的群运算。</li><li>C=A.*B：矩阵元素群运算（A,B矩阵中对应元素相乘）</li><li>D=A.^2:矩阵元素群运算（A中每一个元素平方）【a^2，相当于a乘a；a.^2，相当于a的每一个元素平方】</li></ul></blockquote></li><li>：  ：冒号运算符，start:step:end   不写step的值时，默认为1<blockquote><p>可以创建等距向量 ：B=0：50：100    </p><blockquote><p>B = 0，50，100</p></blockquote></blockquote></li></ol><h2 id="行列式与方程组求解"><a href="#行列式与方程组求解" class="headerlink" title="行列式与方程组求解"></a>行列式与方程组求解</h2><ol><li>U=rref(A)  :对矩阵A进行初等行变换，得到的U是A的最简行列式<blockquote><p>rref([A,b]) :就是将A，b的混合矩阵化为行最简</p></blockquote></li><li>[m,n]=size(A)：计算A的行，列，并返回一个二维向量</li><li>det(A):计算矩阵A的行列式</li><li>rank(A):计算矩阵A的秩</li><li>A(i,j) :引出A的第i行第j列的元素</li><li>B（：，i)=b : 把向量b的值赋给矩阵B的第i列（矩阵B的列向量和向量b同型）</li><li>B（：，1：5）：取矩阵的第一列至第五列</li><li>[A,eye(5)] : 创建一个5*10矩阵，前五列为A，后五列为单位矩阵i</li><li>T(1,:)=[] : 把一个空行赋给T的第1行（删除T的第一行）</li><li>factor(D):对符号变量多项式D进行因式分解</li><li>solve(D) :求符号变量多项式方程D=0的解</li></ol><h2 id="工作区变量"><a href="#工作区变量" class="headerlink" title="工作区变量"></a>工作区变量</h2><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>在Matlab中创建或从其他程序导入的变量</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><ol><li>使用： whos</li><li>直接在工作区窗格查看</li></ol><h3 id="保存和还原"><a href="#保存和还原" class="headerlink" title="保存和还原"></a>保存和还原</h3><ol><li>使用save name.mat保存到压缩文件中</li><li>使用load name.mat将mat中数据还原到工作区</li></ol><h2 id="文本和字符"><a href="#文本和字符" class="headerlink" title="文本和字符"></a>文本和字符</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>文本：与其他语言类似：字符串用单引号括起来，如果字符串中有单引号则单引号用两个单引号’’表示。</li><li>把文本赋值给变量，变量类型为数组（数据类型为char）</li><li>同样可以用[]来进行串联 a=’lin’ b=’mu’  A = [a,’-‘,b]<blockquote><p>A: ‘lin-mu’</p></blockquote><h3 id="数值与字符的转化"><a href="#数值与字符的转化" class="headerlink" title="数值与字符的转化"></a>数值与字符的转化</h3></li><li>由于数值不能与字符变量进行串联，所以需要将数值转化成char型</li></ul><ol><li>num2str(c)  c=3.33  <blockquote><p>转化为 ‘3.33’</p></blockquote></li><li>int2str(c) <blockquote><p>转化为 ‘3’</p></blockquote></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>clc: 清空命令窗口<br>clear: 清空工作区间的变量<br>mean()：获得一个序列的均值<br>std（）：获得一个序列的方差<br>magic():魔方矩阵<br>hilb():产生一个希尔伯特矩阵</p><blockquote><p>矩阵各个值为H（ij）= i+j-1分之一</p></blockquote><h1 id="入门学习"><a href="#入门学习" class="headerlink" title="入门学习"></a>入门学习</h1><h2 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h2><h3 id="常规方法"><a href="#常规方法" class="headerlink" title="常规方法"></a>常规方法</h3><p> 使用 ， 或 空格 来分隔各元素</p><blockquote><p>a = [1,2,3,4]<br>b = [1 2 3 4]<br> 使用 ； 来分隔各行</p></blockquote><h3 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h3><p> 使用ones zeros 或 rand函数（具体函数参照上文）</p><blockquote><p>z = zeros(5,1)   %创建一个五行一列的矩阵</p></blockquote><h2 id="矩阵与数组的运算"><a href="#矩阵与数组的运算" class="headerlink" title="矩阵与数组的运算"></a>矩阵与数组的运算</h2><h3 id="使用运算符"><a href="#使用运算符" class="headerlink" title="使用运算符"></a>使用运算符</h3><p> 使用单一的算术运算符或函数来处理矩阵中的所有值</p><blockquote><p>a+10     %对矩阵a中每一个元素加十<br>sin(a)   %对矩阵中每一个元素进行正弦处理<br>a’       %对矩阵a转置</p></blockquote><h3 id="串联"><a href="#串联" class="headerlink" title="串联"></a>串联</h3><ol><li>串联是连接数组以便形成更大数组的过程。（数组的创建也是如此，通过将各个元素串联而构成的）</li><li>[]即为串联符<br>规则：<blockquote><p>A = [a,b]   %将数组a与数组b水平串联，ab必须具有相同的行数<br>B = [a;b]   %将数组a与数组b竖直串联，ab必须具有相同的列数</p></blockquote></li></ol><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>复数包含 实部和虚部<br>虚数单位是-1的平方根</p><h2 id="数组的索引"><a href="#数组的索引" class="headerlink" title="数组的索引"></a>数组的索引</h2><p>前提 ：</p><blockquote><p>A = [1,2,3,4;4,3,2,1;5,6,7,8]</p></blockquote><h3 id="引用单个元素"><a href="#引用单个元素" class="headerlink" title="引用单个元素"></a>引用单个元素</h3><ol><li>A(4,2)     %引用数组中的特定元素，指定行标和列标</li><li>A(8)       %用单一下标，逐个遍历每一<strong>**</strong>列<strong>**</strong>  ；也叫线性索引<h3 id="添加单个元素"><a href="#添加单个元素" class="headerlink" title="添加单个元素"></a>添加单个元素</h3></li></ol><ul><li>A(4,3)=10  %在索引不存在的情况下，在右边进行赋值，数组大小就会扩大，其余部分填0<h3 id="引用多个元素"><a href="#引用多个元素" class="headerlink" title="引用多个元素"></a>引用多个元素</h3>用冒号 </li></ul><ol><li>A(1:3,2)   %指定一个start:end的范围（以原来形式列出前三行第二列的元素）</li><li>A(:,2)     %单独只有冒号，则列出该列所有元素 </li></ol><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>无接收值无参数： clc    （只写函数名）</p><h3 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h3><ol><li>使用单个参数：name(a)</li><li>使用多个参数：name(a,b)<h3 id="接收函数值"><a href="#接收函数值" class="headerlink" title="接收函数值"></a>接收函数值</h3></li><li>接收单个值：A = name(a)</li><li>接收多个值：[A,B] = name(a)</li></ol><h2 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h2><h3 id="线图"><a href="#线图" class="headerlink" title="线图"></a>线图</h3><ol><li>使用plot(x,y)函数绘制<blockquote><p>plot(x,y,‘r–’):第三个参数为线条设定（r–为红色虚线）<strong>注意：要用单引号引起来</strong></p><blockquote><p>线条设定包括线条颜色（r,g…)、样式、标记的字符(+、o、*标记各个数据点）</p></blockquote></blockquote></li><li>在plot(x,y)后使用 xlabel(‘x’)  ylabel(‘y’)  title(‘my title’)标记各个轴和写标题</li><li>默认情况下，matlab每调用一次绘图函数、重置坐标区及其他元素时，都会清除图窗<blockquote><p>若要保留，则使用 hold on。终止用hold off。</p></blockquote></li></ol><h3 id="三维图形"><a href="#三维图形" class="headerlink" title="三维图形"></a>三维图形</h3><ol><li>首先使用meshgrid创建一组点（x,y)<blockquote><p>meshgrid(X,Y): X，Y：为两个行向量，步数默认为1，范围给定（X=1：2   Y=1:3)<br>然后将X复制Y的元素个数次（3次），将Y复制X的元素个数次（2次）</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些关于Matlab的知识&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>知识积累</title>
    <link href="http://linmushen.com/2019/04/12/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    <id>http://linmushen.com/2019/04/12/知识积累/</id>
    <published>2019-04-12T14:30:38.000Z</published>
    <updated>2019-08-18T16:13:04.312Z</updated>
    
    <content type="html"><![CDATA[<p>一个用于日常知识积累的笔记<br><a id="more"></a></p><h1 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h1><p>此电脑—&gt;属性—-&gt;高级系统设置—-&gt;path—-&gt;新建</p><h1 id="python-安装第三方库"><a href="#python-安装第三方库" class="headerlink" title="python 安装第三方库"></a>python 安装第三方库</h1><p>cmd (powershell)</p><blockquote><p>转到pip下的cache目录<br>pip install 库名</p></blockquote><h1 id="关于pip时的编码错误问题"><a href="#关于pip时的编码错误问题" class="headerlink" title="关于pip时的编码错误问题"></a>关于pip时的编码错误问题</h1><p>最近安装pip-19.1 执行python setup.py install一直提示编码错误<br>弄了一晚上找到解决办法<br>在python27–&gt;Lib–&gt;site-packages下添加一个名为sitecustomize.py的文件<br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&apos;gb2312&apos;)</span><br></pre></td></tr></table></figure></p><p>用utf-8不好使，可能是环境不一样的问题</p><h1 id="创建python虚拟环境"><a href="#创建python虚拟环境" class="headerlink" title="创建python虚拟环境"></a>创建python虚拟环境</h1><p>记得要cd到Python27下的Scripts下运行virtualven name（创建一个名为name的虚拟环境）<br>运行Scripts\active进入虚拟环境<br>运行deactive退出虚拟环境</p><h1 id="高深的爬虫基础"><a href="#高深的爬虫基础" class="headerlink" title="高深的爬虫基础"></a>高深的爬虫基础</h1><p>这个笔记拿来记录一点零星的爬虫知识，以备后用<br><!--more--></p><h2 id="urllib模块"><a href="#urllib模块" class="headerlink" title="urllib模块"></a>urllib模块</h2><h3 id="打开网址-url-的操作"><a href="#打开网址-url-的操作" class="headerlink" title="打开网址(url)的操作"></a>打开网址(url)的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import urllib</span><br><span class="line">f = urllib.urlopen(&apos;网址&apos;)</span><br></pre></td></tr></table></figure><h3 id="返回一个文件对象，有与对文件对象类似的操作"><a href="#返回一个文件对象，有与对文件对象类似的操作" class="headerlink" title="返回一个文件对象，有与对文件对象类似的操作"></a>返回一个文件对象，有与对文件对象类似的操作</h3><ul><li>read() , readline() ,readlines() , fileno() , close() ：这些方法的使用方式与文件对象完全一样</li><li>info()：返回一个httplib.HTTPMessage对象，表示远程服务器返回的头信息</li><li>getcode()：返回Http状态码。如果是http请求，200请求成功完成;404网址未找到</li><li>geturl()：返回请求的url</li></ul><p>后续过于高深，暂时不写<br>关于代码，可以查看py42.py</p><h1 id="HTML文本的笔记"><a href="#HTML文本的笔记" class="headerlink" title="HTML文本的笔记"></a>HTML文本的笔记</h1><p>最近学习了一点有关HTML的知识<br>在此记录一下<br><!--more--></p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>好像是用&lt;&gt;来表示的<br>标签就好像是python里的函数<br>如 </p><ol><li><figure class="highlight plain"><figcaption><span>``` 表示主题内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2. ```&lt;html&gt; &lt;/html&gt;``` 表示HTML文件</span><br><span class="line">3. ```&lt;form&gt; &lt;/form&gt;``` 表示表单文件</span><br><span class="line">4. ```&lt;input&gt;``` 标签</span><br><span class="line"></span><br><span class="line">## input标签</span><br></pre></td></tr></table></figure></li></ol><p><input type="(1)"><br><code>`</code><br>其中（1）内容为以下</p><blockquote><p>button<br>定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）。<br>如果在HTML表单中使用button元素，不同的浏览器会提交不同的值。Internet Explorer将提交<code>&lt;button&gt;与&lt;button/&gt;</code>之间的文本<br>checkbox<br>定义复选框。<br>file<br>定义输入字段和 “浏览”按钮，供文件上传。<br>hidden<br>定义隐藏的输入字段。<br>image<br>定义图像形式的提交按钮。<br>password<br>定义密码字段。该字段中的字符被掩码。<br>radio<br>定义单选按钮。<br>reset<br>定义重置按钮。重置按钮会清除表单中的所有数据。<br>submit<br>定义提交按钮。提交按钮会把表单数据发送到服务器。<br>text<br>定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。</p></blockquote><h2 id="设置字体风格"><a href="#设置字体风格" class="headerlink" title="设置字体风格"></a>设置字体风格</h2><p>font 简写属性。作用是把所有针对字体的属性设置在一个声明中。<br>font-family 设置字体系列。<br>font-size 设置字体的尺寸。<br>font-size-adjust 当首选字体不可用时，对替换字体进行智能缩放。（CSS2.1 已删除该属性。）<br>font-stretch 对字体进行水平拉伸。（CSS2.1 已删除该属性。）<br>font-style 设置字体风格。<br>font-variant 以小型大写字体或者正常字体显示文本。<br>font-weight 设置字体的粗细。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个用于日常知识积累的笔记&lt;br&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://linmushen.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>实战1</title>
    <link href="http://linmushen.com/2019/04/11/%E5%AE%9E%E6%88%981/"/>
    <id>http://linmushen.com/2019/04/11/实战1/</id>
    <published>2019-04-11T14:40:15.000Z</published>
    <updated>2019-08-18T16:13:04.309Z</updated>
    
    <content type="html"><![CDATA[<p>第一个实战小项目<br><a id="more"></a></p><h2 id="解决问题的起点：步骤"><a href="#解决问题的起点：步骤" class="headerlink" title="解决问题的起点：步骤"></a>解决问题的起点：步骤</h2><ol><li>根据要解决的问题画出流程图</li><li>摘录第一条的关键概念并研究</li><li>创建一个类和对象的层次结构图</li><li>用代码实现各个类，并测试</li><li>重复上述步骤</li></ol><p>**有抽象概念入手，逐渐细化</p><h2 id="各种名字"><a href="#各种名字" class="headerlink" title="各种名字"></a>各种名字</h2><p>根据思路写出一个名词列表作为变量名<br>根据思路写出一个动词列表作为函数名</p><h2 id="对各种操作进行研究"><a href="#对各种操作进行研究" class="headerlink" title="对各种操作进行研究"></a>对各种操作进行研究</h2><p>如：玩家引爆炸弹的工作<br>怎么把游戏状态存储金数据库<br>应该通过学习类似游戏的工作原理来研究</p><h2 id="创建层次图和对象关系图"><a href="#创建层次图和对象关系图" class="headerlink" title="创建层次图和对象关系图"></a>创建层次图和对象关系图</h2><p>类的结构图：</p><ul><li>和其他东西有哪些类似</li><li>那个东西是另一个东西的换个说法而已</li></ul><h2 id="字典真是好用"><a href="#字典真是好用" class="headerlink" title="字典真是好用"></a>字典真是好用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scenes = &#123;</span><br><span class="line">&apos;Death&apos;:Death(),</span><br><span class="line">&apos;Escapepod&apos;:Escapepod(),</span><br><span class="line">&apos;TheBridge&apos;:TheBridge(),</span><br><span class="line">&apos;LaserWeaponArmony&apos;:LaserWeaponArmony(),</span><br><span class="line">&apos;central_corridor&apos;:CentralCorridor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过返回值来简单的引用类</p><ul><li>父类中的函数，若与子类的重名，而且没有被调用，则会被覆盖<h2 id="类中变量的使用"><a href="#类中变量的使用" class="headerlink" title="类中变量的使用"></a>类中变量的使用</h2>类中的被多个类中函数调用的变量要加上self表明位置，否则出现全局变量错误。（而参数不用）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class English(object):   #游戏引擎，用来根据场景名生产变量并切换场景</span><br><span class="line">def __init__(self,scene_map):</span><br><span class="line">self.dizhi = scene_map</span><br><span class="line">def play(self):</span><br><span class="line">current_scene = self.dizhi.opening_scene()</span><br><span class="line">while True:</span><br><span class="line">print &quot;\n--------&quot;</span><br><span class="line"></span><br><span class="line">self.next_scene_name = current_scene.enter()</span><br><span class="line"></span><br><span class="line">current_scene = self.dizhi.next_scene(self.next_scene_name)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class CentralCorridor(Scene):</span><br><span class="line">def enter(self):</span><br><span class="line"></span><br><span class="line">xiao = raw_input(&apos;&gt;&apos;)</span><br><span class="line">if xiao == &apos;1&apos;:</span><br><span class="line">print u&quot;(卫兵倒下，你成功进入下个房间。)&quot;</span><br><span class="line">return &apos;LaserWeaponArmony&apos;</span><br><span class="line">else:</span><br><span class="line">print u&quot;你是个没有幽默感的蠢货，哥顿人怒火中烧，把你打成了马蜂窝。&quot;</span><br><span class="line">return&apos;Death&apos;</span><br></pre></td></tr></table></figure><p>而变量xiao则不用。</p><h2 id="init"><a href="#init" class="headerlink" title="init()"></a><strong>init</strong>()</h2><p>直接实例化类，相当于直接调用其中的init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Map(object):</span><br><span class="line">def __init__(self,start_scene):</span><br><span class="line">self.dizhi = start_scene</span><br><span class="line">def next_scene(self,scene_name):</span><br><span class="line">return Map.scenes.get(scene_name)   #对获取的类进行实例化</span><br><span class="line">def opening_scene(self):</span><br><span class="line">return self.next_scene(self.dizhi)</span><br><span class="line"></span><br><span class="line">a_map = Map(&apos;central_corridor&apos;)</span><br></pre></td></tr></table></figure><p>a_map = Map(‘str’)<br>等价于<br>a_map = Map.<strong>init</strong>(‘str’)<br>就相当于<br>a_map.dizhi = str</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一个实战小项目&lt;br&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://linmushen.com/categories/life/"/>
    
    
  </entry>
  
</feed>
