<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林木深的个人博客</title>
  
  <subtitle>热爱技术，痴迷技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linmushen.com/"/>
  <updated>2019-10-16T13:36:39.790Z</updated>
  <id>http://linmushen.com/</id>
  
  <author>
    <name>林木深</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>K60学习笔记</title>
    <link href="http://linmushen.com/2019/09/18/K60%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/09/18/K60学习笔记/</id>
    <published>2019-09-18T05:22:43.000Z</published>
    <updated>2019-10-16T13:36:39.790Z</updated>
    
    <content type="html"><![CDATA[<p>好好学习K60单片机<br><a id="more"></a></p><h1 id="文件夹规定"><a href="#文件夹规定" class="headerlink" title="文件夹规定"></a>文件夹规定</h1><h2 id="一级文件夹"><a href="#一级文件夹" class="headerlink" title="一级文件夹"></a>一级文件夹</h2><p>App—–用户程序<br>Board—开发板驱动程序<br>Chip—-K60芯片驱动程序<br>Lib—–库代码<br>Prj—–工程文件</p><h2 id="二级文件夹"><a href="#二级文件夹" class="headerlink" title="二级文件夹"></a>二级文件夹</h2><p>Inc—–程序头文件<br>src—–驱动程序<br>IAR—–工程文件</p><h2 id="三级文件夹"><a href="#三级文件夹" class="headerlink" title="三级文件夹"></a>三级文件夹</h2><p>IAR—–与IAR编译器相关的头文件<br>kinetis-与MCU相关的头文件<br>IAR—–IAR驱动程序和编译器相关驱动程序</p><h1 id="正式开篇"><a href="#正式开篇" class="headerlink" title="正式开篇"></a>正式开篇</h1><p>经过几天的准备工作（环境搭建，编译设置）后，今天正式开始学习K60单片机。<br>山外的板子LED0~LED3对应PTB20~PTB23</p><h1 id="关于库"><a href="#关于库" class="headerlink" title="关于库"></a>关于库</h1><p>常用库文件说明：<br>MK60_conf.h—配置文件，包含printf函数，波特率设置，频率设置。<br>MK60_conf.c—断言函数，printf底层接口，默认中断等函数。<br>MK60_it.c—–中断函数库。<br>PORT_cfg.h—-管脚服用配置文件，用于配置默认复用管脚。</p><h2 id="快速复用管脚"><a href="#快速复用管脚" class="headerlink" title="快速复用管脚"></a>快速复用管脚</h2><p>只需在PORT_cfg.h中按照注释里写着的可选范围进行修改这里的宏定义，就能更改默认的复用管脚，不需要修改函数。 </p><h2 id="中断函数的编写"><a href="#中断函数的编写" class="headerlink" title="中断函数的编写"></a>中断函数的编写</h2><p>set_vector_handler(中断号的枚举类型,中断服务函数)<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_vector_handler(PORTD_VECTORn,PORTD_IRQHandler)</span><br><span class="line">//第一个参数是port模块的D端口的中断，第二个参数是编写好的中断服务函数</span><br><span class="line">//第一个参数详见C:\Users\树枝990\Desktop\K60单片机\fire_Kinetis\Chip\inc</span><br></pre></td></tr></table></figure></p><h2 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h2><p>跳过，暂时看不懂。</p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h1 id="K60-UD版的使用"><a href="#K60-UD版的使用" class="headerlink" title="K60 UD版的使用"></a>K60 UD版的使用</h1><h2 id="下载方式"><a href="#下载方式" class="headerlink" title="下载方式"></a>下载方式</h2><ol><li>使用下载器</li><li>使用USB线下载<blockquote><p>详细说明第二种方法：插入USB线的同时按住独立按键，然后按一下复位键，进入USB DOWNLOAD模式，最后将生成的BIN文件拷贝到这个文件夹中。完成时，LED0和LED2闪烁。按复位键即可运行程序。</p></blockquote></li></ol><h1 id="编码器的使用"><a href="#编码器的使用" class="headerlink" title="编码器的使用"></a>编码器的使用</h1><p>使用的是逐飞的mini1024z编码器，具有两相输出（步进脉冲，旋转方向）。<br>理解：应该是通过测量一段时间内的脉冲数来计算速度，通过测量旋转方向相的输出来判断方向。</p><h1 id="模块学习"><a href="#模块学习" class="headerlink" title="模块学习"></a>模块学习</h1><h2 id="中断函数的编写-1"><a href="#中断函数的编写-1" class="headerlink" title="中断函数的编写"></a>中断函数的编写</h2><p>中断里修改的参数，需要用volatile来修饰</p><h3 id="函数列表"><a href="#函数列表" class="headerlink" title="函数列表"></a>函数列表</h3><p>set_vector_handler(HardFault_VECTORn,HardFault_Handler)：设定中断函数入口<br>参数设置：第一个参数 在\CHIP\INC\COMMON.h中查找；第二个参数为编写的中断函数</p><p>enable_irq(X_IRQn):中断使能函数<br>参数设置：为上一个函数的前一部分+_IRQn</p><h2 id="PORT模块（管脚管理模块）"><a href="#PORT模块（管脚管理模块）" class="headerlink" title="PORT模块（管脚管理模块）"></a>PORT模块（管脚管理模块）</h2><p>PORT模块：K60的PORT模块是引脚控制和中断模块，控制每个管脚复用到各个不同的内部模块（GPIO,UART,I2C），配置每一个管脚的各种属性（上拉下拉电阻、无源滤波）。</p><h3 id="PORT库的使用"><a href="#PORT库的使用" class="headerlink" title="PORT库的使用"></a>PORT库的使用</h3><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>下降沿触发：就是说，当端口输入为低电平触发。<br>上拉电阻：当输入不确定信号时，上拉为高电平。</p><h3 id="形参命名列表"><a href="#形参命名列表" class="headerlink" title="形参命名列表"></a>形参命名列表</h3><p>PTXn_e:管脚编号。例:PTB0<br>PTX_e:端口模块。例:PTA<br>PTn_e:管脚位号。例:PT1</p><h3 id="函数列表-1"><a href="#函数列表-1" class="headerlink" title="函数列表"></a>函数列表</h3><p>port_init(PTXn_e,cfg)：PORT初始化（配置复用功能）</p><blockquote><p>例:port_init(PTA8,IRQ_RISING|PF|ALT1|PULLUP);  配置了复用功能ALT1。<br>port_init_NoALT(PTXn_e,cfg)：PORT初始化（不改变复用功能）<br>例:port_init_NoALT(PTA8,IRQ_RISING|PF|PULLUP)</p></blockquote><h3 id="宏定义列表"><a href="#宏定义列表" class="headerlink" title="宏定义列表"></a>宏定义列表</h3><p>PORT_FUNC(X,num,func)：中断函数中的宏定义，简化代码量。（据说可以不用清楚位标志）</p><blockquote><p>x:为端口号（A~E）。<br>num:为管脚位号（1~31）。<br>func:相应的中断处理函数。<br>例:PORT_FUNC(A,6,key)</p><blockquote><p>其中key为中断中需要执行的用户任务。</p></blockquote></blockquote><h3 id="实例使用"><a href="#实例使用" class="headerlink" title="实例使用"></a>实例使用</h3><p>使用独立按键控制两个小灯的亮灭。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">void ledb();</span><br><span class="line">void PORTD_IRQHandler(void);        //PORTD端口中断服务函数</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    led_init(LED0);                         //初始化LED0</span><br><span class="line">    led_init(LED1);                         //初始化LED1</span><br><span class="line">    set_vector_handler(PORTD_VECTORn ,PORTD_IRQHandler);    //设置PORTD的中断复位函数为 PORTD_IRQHandler</span><br><span class="line">    enable_irq (PORTD_IRQn);                                //使能PORTD中断</span><br><span class="line">    port_init(PTD7, ALT1 | IRQ_FALLING | PULLUP );          //初始化 PTD7 管脚，复用功能为GPIO ，下降沿触发中断，上拉电阻</span><br><span class="line">    led(LED0, LED_ON);</span><br><span class="line">    led(LED1, LED_ON);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ledb()</span><br><span class="line">&#123;</span><br><span class="line">    led_turn(LED0);                  //LED0 亮</span><br><span class="line">    led_turn(LED1);                  //LED1翻转</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PORTD_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">    PORT_FUNC(D,7,ledb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意要调整模式为DZ_10 DEBUG模式。<br>还要修改内存地址：linker–&gt;config—&gt;edit—&gt;Vector Table中改为(32<em>1024)<br>linker–&gt;config—&gt;edit—&gt;Memory Regions中第一行改为(32</em>1024)，(512*1024)</p><h2 id="GPIO模块"><a href="#GPIO模块" class="headerlink" title="GPIO模块"></a>GPIO模块</h2><h3 id="形参命名列表-1"><a href="#形参命名列表-1" class="headerlink" title="形参命名列表"></a>形参命名列表</h3><p>PTXn_e：管教编号 例如：PTA0<br>GPIO_CFG：输入输出配置 例如：GPI(输入方向),GPO(输出方向)<br>data：数据</p><h3 id="函数列表-2"><a href="#函数列表-2" class="headerlink" title="函数列表"></a>函数列表</h3><p>gpio_init:初始化GPIO<br>gpio_ddr:设置引脚数据方向<br>gpio_set:设置引脚状态<br>gpio_turn:反转引脚状态<br>gpio_get:获取引脚IO状态</p><h3 id="宏定义列表-1"><a href="#宏定义列表-1" class="headerlink" title="宏定义列表"></a>宏定义列表</h3><p>PTxn_OUT:设置引脚输出电平  例如：PTA0_OUT<br>PTxn_IN:读取引脚输入电平   例如：PTA0_IN<br>PTxn_DDR:设置引脚输入输出方向      例如：PTA0_DDR<br>PTxn_T:反转引脚状态   例如：PTA0_T</p><p><strong>B表示字节</strong><br>PTx_Bn:设置8位引脚<br>例如：<br>PTx_B0：代表对7~0位进行操作。<br>PTx_B1：代表对15~8位进行操作。<br>PTx_B2：代表对23~16位进行操作。<br>PTx_B3：代表对31~24位进行操作。<br>Bn结合gpio基本宏定义进行使用，实现对8位的同时操作</p><ol><li>PTx_Bn_OUT</li><li>PTx_Bn_IN</li><li>PTx_Bn_DDR</li><li>PTx_Bn_T</li></ol><p><strong> W表示字</strong><br>PTx_Wn:PTx_Bn:设置16位引脚<br>例如：<br>PTx_W0：代表对15~0位进行操作。<br>PTx_W1：代表对31~16位进行操作。<br>Wn结合gpio基本宏定义进行使用，实现对16位的同时操作</p><ol><li>PTx_Wn_OUT</li><li>PTx_Wn_IN</li><li>PTx_Wn_DDR</li><li>PTx_Wn_T</li></ol><p>GPIO_SET:设置引脚状态<br>GPIO_TURN:反转引脚状态<br>GPIO_GET:获取引脚IO状态<br>GPIO_DDR:输入输出状态</p><p>NBIT类型：传递参数：NBIT:位数,PTxn:最低位的管脚号,data:电平状态（二进制转为十进制表示）<br>GPIO_SET_NBIT:设置n位引脚状态<br>GPIO_T_NBIT:反转n位引脚状态<br>GPIO_GET_NBIT:获取n位引脚IO状态<br>GPIO_DDR_NBIT:设置n位输入输出状态</p><h3 id="函数的实际使用"><a href="#函数的实际使用" class="headerlink" title="函数的实际使用"></a>函数的实际使用</h3><ol><li>gpio_init(PTXn_e,GPIO_CFG,uint8 data)：初始化GPIO口，设置输入输出方向，输出数据（仅在输出模式下有效）</li><li>gpio_ddr(PTXn_e,GPIO_CFG)：设置引脚数据方向(GPIO_CFG的可选值为GPI,GPO)</li><li>gpio_set(PTXn_e,data)：设置引脚状态 例如：gpio_set(PTA8,1)  PTA8引脚输出1</li><li>gpio_turn(PTXn_e)：翻转IO口电平</li><li>gpio_get(PTXn_e)：读取引脚状态<h3 id="宏定义的实际使用"><a href="#宏定义的实际使用" class="headerlink" title="宏定义的实际使用"></a>宏定义的实际使用</h3>PTxn系列：将x换为A~E,n换为0~31<br>PTxn_OUT：参数为0，1；其中0代表输出高电平，1代表输出低电平。<br>PTxn_IN：读取电平输入。<br>PTxn_DDR：参数为0，1；其中0代表输入，1代表输出。<br>PTxn_T：参数为0，1；其中0代表保存当前电平状态，1代表翻转电平状态。</li></ol><p>PTx_Bn系列：将x换为A~E,n换为0~3。其余一样。<br>PTx_Wn系列：将x换为A~E,n换为0~1。其余一样。</p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><h4 id="gpio-init-和宏定义的使用"><a href="#gpio-init-和宏定义的使用" class="headerlink" title="gpio_init()和宏定义的使用"></a>gpio_init()和宏定义的使用</h4><p>效果：LED0与LED1闪烁。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gpio_init(PTB20,GPO,1);</span><br><span class="line">    gpio_init(PTB21,GPO,1);     //初始化两个led为灭。</span><br><span class="line">    </span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        PTB20_OUT=0;    //20输出低电平</span><br><span class="line">        PTB21_T=1;      //21输出翻转</span><br><span class="line">        </span><br><span class="line">        DELAY_MS(500);  //延时500ms</span><br><span class="line">        </span><br><span class="line">        PTB20_OUT=1;    //20输出高电平</span><br><span class="line">        PTB21_T=1;      //21再次翻转</span><br><span class="line">        </span><br><span class="line">        DELAY_MS(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="port与gpio结合使用"><a href="#port与gpio结合使用" class="headerlink" title="port与gpio结合使用"></a>port与gpio结合使用</h4><p>效果：按下独立按键时led0亮，弹起时熄灭。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//使用GPIO函数设置端口参数，使用port函数设置各种属性</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">   gpio_init(PTB20,GPO,1);      //初始化LED0为灭状态</span><br><span class="line">   gpio_init(PTD7,GPI,1);       //初始化按键端口为输入状态</span><br><span class="line">   port_init_NoALT(PTD7,PULLUP);//设置该端口为上拉电阻</span><br><span class="line">   </span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(PTD7_IN==1)          //案件弹起</span><br><span class="line">        &#123;</span><br><span class="line">          PTB20_OUT=1;          //LED0亮</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          PTB20_OUT=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="gpio-set-的使用"><a href="#gpio-set-的使用" class="headerlink" title="gpio_set()的使用"></a>gpio_set()的使用</h4><p>效果：LED0闪烁<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gpio_init(PTB20,GPO,1);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">       gpio_set(PTB20,0);</span><br><span class="line">       DELAY_MS(500);</span><br><span class="line">       gpio_set(PTB20,1);</span><br><span class="line">       DELAY_MS(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用NBIT进行并行设置"><a href="#使用NBIT进行并行设置" class="headerlink" title="使用NBIT进行并行设置"></a>使用NBIT进行并行设置</h4><p>效果：LED3和LED0一起闪烁，LED4和LED1一起闪烁。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//使用NBIT系列并行设置多个端口</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gpio_init(PTB20,GPO,1);</span><br><span class="line">    gpio_init(PTB21,GPO,1);</span><br><span class="line">    gpio_init(PTB22,GPO,1);</span><br><span class="line">    gpio_init(PTB23,GPO,1);     //初始化LED0~LED3为熄灭状态</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">       GPIO_SET_NBIT(4,PTB20,9);//同时设置由PTB20开始的四位的电平</span><br><span class="line">       DELAY_MS(500);</span><br><span class="line">       GPIO_SET_NBIT(4,PTB20,6);//同时设置为低电平</span><br><span class="line">       DELAY_MS(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="VCAN-LED模块"><a href="#VCAN-LED模块" class="headerlink" title="VCAN_LED模块"></a>VCAN_LED模块</h2><h3 id="形参变量列表"><a href="#形参变量列表" class="headerlink" title="形参变量列表"></a>形参变量列表</h3><ol><li>LEDn:led的号,取值：LED0,LED1,LED2,LED3,LED_MAX。</li><li>LED_status:led状态，取值：LED_ON,LED_OFF<h3 id="函数列表-3"><a href="#函数列表-3" class="headerlink" title="函数列表"></a>函数列表</h3>led_init():初始化LED。<br>led:设置LED状态。<br>led_turn:翻转LED状态。<h3 id="函数原型列表"><a href="#函数原型列表" class="headerlink" title="函数原型列表"></a>函数原型列表</h3>led_init(LED_e);    初始化led<br>led(LED_e,LED_status);    设置led亮灭<br>led_turn(led_e);    翻转led亮灭<h3 id="实际使用-1"><a href="#实际使用-1" class="headerlink" title="实际使用"></a>实际使用</h3>效果：使用LED系列函数实现闪烁 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    led_init(LED0);</span><br><span class="line">    led_init(LED1);     //初始化LED0和LED1</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">       led(LED0,LED_ON);</span><br><span class="line">       led_turn(LED1);</span><br><span class="line">       DELAY_MS(500);</span><br><span class="line">       led(LED0,LED_OFF);</span><br><span class="line">       led_turn(LED1);</span><br><span class="line">       DELAY_MS(500);   //两个led闪烁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="VCAN-KEY模块"><a href="#VCAN-KEY模块" class="headerlink" title="VCAN_KEY模块"></a>VCAN_KEY模块</h2><p>由于没有五轴按键暂时先不学。2019/10/5 16:06:02 </p><h2 id="K60-FTM模块"><a href="#K60-FTM模块" class="headerlink" title="K60_FTM模块"></a>K60_FTM模块</h2><p>PWM库的使用</p><h3 id="形参变量列表-1"><a href="#形参变量列表-1" class="headerlink" title="形参变量列表"></a>形参变量列表</h3><p>FTMn_e:模块名（常用）<br>FTM_CHn_e:通道号（常用）<br>Freq:频率<br>Duty:通道占空比<br>FTM_Input_cfg:FTM输入捕捉配置（输入）<br>FTM_PS_e:分频因子（常用）<br><em>关于各个通道的端口引脚，可以查询app/inc/port_cfg.h文件</em></p><h3 id="函数原型列表-1"><a href="#函数原型列表-1" class="headerlink" title="函数原型列表"></a>函数原型列表</h3><h4 id="pwm系列函数"><a href="#pwm系列函数" class="headerlink" title="pwm系列函数"></a>pwm系列函数</h4><p>ftm_pwm_init(FTMn_e,FTM_CHn_e,uint32 freq,uint32 duty);</p><blockquote><p>功能说明：初始化FTM的PWM，设置频率(freq)和占空比(duty/freq*100%)<br>调用例子：ftm_pwm_init(FTM0,FTM_CH6,200,10);</p></blockquote><p>ftm_pwm_duty(FTMn_e,FTM_CHn_e,uint32 duty);</p><blockquote><p>功能说明：设置通道占空比(duty/freq*100%)<br>调用例子：ftm_pwm_duty(FTM0,FTM_CH6,10);</p></blockquote><p>ftm_pwm_freq(FTMn_e,uint32 freq);</p><blockquote><p>功能说明：设置FTM的频率，设置后需要重新调用ftm_pwm_duty()设置占空比。<br>调用例子：ftm_pwm_freq(FTM0,200);</p></blockquote><h4 id="输入捕捉系列函数"><a href="#输入捕捉系列函数" class="headerlink" title="输入捕捉系列函数"></a>输入捕捉系列函数</h4><p>ftm_input_init(FTMn_e,FTM_CHn_e,FTM_Input_cfg,FTM_PS_e);</p><blockquote><p>功能说明：输入捕捉初始化函数，设置通道，触发模式和分频系数<br>调用例子：ftm_input_init(FTM0,FTM_CH2,FTM_Rising,FTM_PS_2);<br>例子说明：设置FTM0_CH2为上升沿触发捕捉，二分频</p></blockquote><p>ftm_input_get(FTMn_e,FTM_CHn_e);</p><blockquote><p>功能说明：输入捕捉模式下，读取捕捉事件发生时计数器值（根据两次捕捉之间的差值可以判断周期频率）<br>调用例子：uint 16 data = ftm_input_get(FTM0,FTM_CH0)<br>例子说明：获取FTM0_CH0输入捕捉事件触发时的计数值</p></blockquote><p>ftm_input_clean(FTMn_e);</p><blockquote><p>功能说明：清空计数器的值，计数器重新开始计数。</p></blockquote><h4 id="正交解码系列函数"><a href="#正交解码系列函数" class="headerlink" title="正交解码系列函数"></a>正交解码系列函数</h4><p>ftm_quad_init(FTMn_e);</p><blockquote><p>功能说明：初始化FTM的正交解码功能<br>调用例子：ftm_quad_init(FTM1);</p></blockquote><p>ftm_quad_get(FTMn_e);</p><blockquote><p>功能说明：获取FTM正交解码的脉冲数（负数表示反方向）<br>调用例子：int16 count = ftm_quad_get(FTM1);</p></blockquote><p>ftm_quad_clean(FTMn_e);</p><blockquote><p>功能说明：清空FTM正交解码的脉冲数<br>调用例子：ftm_quad_clean(FTM1);</p></blockquote><h3 id="宏定义一个"><a href="#宏定义一个" class="headerlink" title="宏定义一个"></a>宏定义一个</h3><p>FTMn_PRECISON</p><blockquote><p>功能说明：定义占空比精度。100代表精度为1%；1000代表精度为0.1%。<br>调用例子：#define FTM0_PRECISON 100U</p></blockquote><h1 id="程序备份"><a href="#程序备份" class="headerlink" title="程序备份"></a>程序备份</h1><p>新建新的工程文件之前一定要重新设置内存启动位置为32k。</p><h2 id="驱动电机实验"><a href="#驱动电机实验" class="headerlink" title="驱动电机实验"></a>驱动电机实验</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//该程序可以实现电机的前转、后转和停止；还可以控制电机的转速。</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">#define FTM_PRECISON 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MOTOR1_FTM   FTM0</span><br><span class="line">#define MOTOR2_FTM   FTM1</span><br><span class="line"></span><br><span class="line">#define MOTOR1_PWM  FTM_CH6</span><br><span class="line">#define MOTOR2_PWM  FTM_CH0</span><br><span class="line"></span><br><span class="line">#define MOTOR1_PWM_IO  FTM0_CH6</span><br><span class="line">#define MOTOR2_PWM_IO  FTM1_CH0</span><br><span class="line"></span><br><span class="line">//引脚选择</span><br><span class="line">//D6做PWM1，A12做PWM2</span><br><span class="line">//D6（FTM0_CH6   PTD6）和A12（FTM1_CH0      PTA12）</span><br><span class="line"></span><br><span class="line">//三个动作子函数</span><br><span class="line">//前进---D6高电平，A12低电平</span><br><span class="line">//后退---D6低电平，A12高电平</span><br><span class="line">//停止---都输出高电平或低电平</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void go(uint8 gduty);</span><br><span class="line">void back(uint8 bduty);</span><br><span class="line">void stop();</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    uint8 i=20;</span><br><span class="line">    FTM_PWM_init(MOTOR1_FTM, MOTOR1_PWM,10*1000,100);      </span><br><span class="line">    FTM_PWM_init(MOTOR2_FTM, MOTOR2_PWM,10*1000,0);      //初始化两个PWM通道，设置初始PWM值</span><br><span class="line">    </span><br><span class="line">    while(1)</span><br><span class="line">    &#123; </span><br><span class="line">        /***变速部分</span><br><span class="line">        for(i=80;i&gt;=10;i=i-10)</span><br><span class="line">        &#123;</span><br><span class="line">            go(i);</span><br><span class="line">            DELAY_MS(500);</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==10)  </span><br><span class="line">         i=100;</span><br><span class="line">        ***/</span><br><span class="line">        back(i);</span><br><span class="line">        DELAY_MS(3000);</span><br><span class="line">        go(i);</span><br><span class="line">        DELAY_MS(3000);</span><br><span class="line">        stop();</span><br><span class="line">        DELAY_MS(5000);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void go(uint8 gduty)</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,gduty);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void back(uint8 bduty)</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,0);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,bduty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stop()</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,0);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="驱动舵机实验"><a href="#驱动舵机实验" class="headerlink" title="驱动舵机实验"></a>驱动舵机实验</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//该程序实现每按一次独立按键，舵机转一点。</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">//使用A10引脚，设置周期为20ms，其中0~180度对应0.5~2.5ms（即占空比为0.5/20~2.5/20）</span><br><span class="line">//精度设置为1000，0.5ms时即设置为25，2.5ms时即设置为125.</span><br><span class="line">//实现功能：每按一次按键，占空比+1，同时LED0亮一些</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    uint8 i=13; </span><br><span class="line"></span><br><span class="line">    FTM_PWM_init(FTM2,FTM_CH0,100,13);          //初始化FTM1_CH1通道，设置频率为50（周期20ms），占空比为75（舵机归中）</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    gpio_init(PTD7,GPI,1);</span><br><span class="line">    port_init_NoALT(PTD7,PULLUP);</span><br><span class="line">    </span><br><span class="line">    while(1)</span><br><span class="line">    &#123; </span><br><span class="line">        if(PTD7_IN==0)</span><br><span class="line">        &#123;</span><br><span class="line">            i=i+2;</span><br><span class="line">            if(i&gt;=25)</span><br><span class="line">                i=13;</span><br><span class="line">            if(i&lt;=0)</span><br><span class="line">                i=13;</span><br><span class="line">            </span><br><span class="line">            FTM_PWM_Duty(FTM2,FTM_CH0,i);</span><br><span class="line">            DELAY_MS(400);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="Uart通信实验"><a href="#Uart通信实验" class="headerlink" title="Uart通信实验"></a>Uart通信实验</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">//Uart通信实验，按一下按键，上位机显示CET-8</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  gpio_init(PTD7,GPI,1);</span><br><span class="line">  port_init_NoALT(PTD7,PULLUP);</span><br><span class="line">    </span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    if(PTD7_IN==0)</span><br><span class="line">        &#123;</span><br><span class="line">          printf(&quot;\nCET-8&quot;);</span><br><span class="line">          DELAY_MS(500);</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="编码器测速实验"><a href="#编码器测速实验" class="headerlink" title="编码器测速实验"></a>编码器测速实验</h2><p>在上位机软件中显示速度。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">//编码器篇：需要一个引脚判断一定时间内脉冲个数；另一个引脚通过判断高低电平判断方向</span><br><span class="line">//其中PTA8测量方向；PTD8测量脉冲个数，需要有一个中断服务函数</span><br><span class="line"></span><br><span class="line">int16 count();              //计算转数的函数</span><br><span class="line">void PORTD_IRQHandler();   //中断服务函数</span><br><span class="line">void PIT0_IRQHandler();    //定时器的中断服务函数</span><br><span class="line"></span><br><span class="line">volatile uint8 cnt=0;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    port_init(PTA8,ALT1|PULLUP);                         //初始化PTA8端口为GPIO功能，上升沿触发，上拉电阻</span><br><span class="line">    gpio_init(PTA8,GPI,1);                               //设置为输入模式</span><br><span class="line">    </span><br><span class="line">    port_init(PTD8,IRQ_EITHER|ALT1|PULLUP);              //初始化PTA8端口为GPIO功能，跳变沿触发，上拉电阻</span><br><span class="line">    set_vector_handler(PORTD_VECTORn,PORTD_IRQHandler);  //设置中断函数入口</span><br><span class="line">    enable_irq(PORTD_IRQn);                              //使能中断服务函数</span><br><span class="line">    </span><br><span class="line">    pit_init_ms(PIT0,500);                               //定时500ms    </span><br><span class="line">    set_vector_handler(PIT0_VECTORn,PIT0_IRQHandler);    //设置定时器的中断服务函数</span><br><span class="line">    enable_irq(PIT0_IRQn);                               //使能</span><br><span class="line">    </span><br><span class="line">    while(1);</span><br><span class="line">    </span><br><span class="line">             </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int16 count()</span><br><span class="line">&#123;</span><br><span class="line">    cnt++;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PORTD_IRQHandler()</span><br><span class="line">&#123;</span><br><span class="line">    PORT_FUNC(D,8,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PIT0_IRQHandler()</span><br><span class="line">&#123;</span><br><span class="line">    int16 val;</span><br><span class="line">    val = cnt;</span><br><span class="line">    cnt=0;</span><br><span class="line">    printf(&quot;\n脉冲数为%d&quot;,val);</span><br><span class="line">    </span><br><span class="line">    if(PTA8_IN==1)</span><br><span class="line">       printf(&quot;\n正向旋转&quot;);</span><br><span class="line">    else</span><br><span class="line">       printf(&quot;\n反向旋转&quot;);  </span><br><span class="line">    </span><br><span class="line">    PIT_Flag_Clear(PIT0);       //清中断标志位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="电机与编码器测速结合"><a href="#电机与编码器测速结合" class="headerlink" title="电机与编码器测速结合"></a>电机与编码器测速结合</h2><p>驱动电机转动并测速<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">#define FTM_PRECISON 100        //配置PWM精度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MOTOR1_FTM   FTM0</span><br><span class="line">#define MOTOR2_FTM   FTM1</span><br><span class="line"></span><br><span class="line">#define MOTOR1_PWM  FTM_CH6</span><br><span class="line">#define MOTOR2_PWM  FTM_CH0</span><br><span class="line"></span><br><span class="line">#define MOTOR1_PWM_IO  FTM0_CH6</span><br><span class="line">#define MOTOR2_PWM_IO  FTM1_CH0</span><br><span class="line"></span><br><span class="line">//引脚选择</span><br><span class="line">//D6做PWM1，A12做PWM2</span><br><span class="line">//D6（FTM0_CH6   PTD6）和A12（FTM1_CH0      PTA12）</span><br><span class="line">//PTA8测量方向；PTD8测量脉冲个数，需要有一个中断服务函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void go(uint8 gduty);</span><br><span class="line">void back(uint8 bduty);</span><br><span class="line">void stop();</span><br><span class="line"></span><br><span class="line">int16 count();              //计算转数的函数</span><br><span class="line">void PORTD_IRQHandler();   //中断服务函数</span><br><span class="line">void PIT0_IRQHandler();    //定时器的中断服务函数</span><br><span class="line"></span><br><span class="line">volatile uint8 cnt=0;      //全局变量</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    uint8 i=20;</span><br><span class="line">    FTM_PWM_init(MOTOR1_FTM, MOTOR1_PWM,10*1000,50);      </span><br><span class="line">    FTM_PWM_init(MOTOR2_FTM, MOTOR2_PWM,10*1000,0);      //初始化两个PWM通道，设置初始PWM值</span><br><span class="line">    </span><br><span class="line">    port_init(PTA8,ALT1|PULLUP);                         //初始化PTA8端口为GPIO功能，上升沿触发，上拉电阻</span><br><span class="line">    gpio_init(PTA8,GPI,1);                               //设置为输入模式</span><br><span class="line">    </span><br><span class="line">    port_init(PTD8,IRQ_EITHER|ALT1|PULLUP);              //初始化PTA8端口为GPIO功能，跳变沿触发，上拉电阻</span><br><span class="line">    set_vector_handler(PORTD_VECTORn,PORTD_IRQHandler);  //设置中断函数入口</span><br><span class="line">    enable_irq(PORTD_IRQn);                              //使能中断服务函数</span><br><span class="line">    </span><br><span class="line">    pit_init_ms(PIT0,1000);                          //定时1000ms    </span><br><span class="line">    set_vector_handler(PIT0_VECTORn,PIT0_IRQHandler);    //设置定时器的中断服务函数</span><br><span class="line">    enable_irq(PIT0_IRQn);                               //使能</span><br><span class="line">    </span><br><span class="line">    while(1)</span><br><span class="line">    &#123; </span><br><span class="line">     /* 变速部分</span><br><span class="line">        for(i=50;i&gt;=10;i=i-10)</span><br><span class="line">        &#123;</span><br><span class="line">            go(i);</span><br><span class="line">            DELAY_MS(500);</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==10)  </span><br><span class="line">            i=50;</span><br><span class="line">       */ </span><br><span class="line">      </span><br><span class="line">//正转反转和停止</span><br><span class="line">        back(i);</span><br><span class="line">        DELAY_MS(3000);</span><br><span class="line">        go(i);</span><br><span class="line">        DELAY_MS(3000);</span><br><span class="line">        stop();</span><br><span class="line">        DELAY_MS(5000);</span><br><span class="line">      </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void go(uint8 gduty)            //前进函数</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,gduty);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void back(uint8 bduty)          //后退函数</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,0);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,bduty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stop()                     //停止函数</span><br><span class="line">&#123;</span><br><span class="line">    FTM_PWM_Duty(MOTOR1_FTM, MOTOR1_PWM,0);</span><br><span class="line">    FTM_PWM_Duty(MOTOR2_FTM, MOTOR2_PWM,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int16 count()                   //计数函数（计算每500ms产生脉冲数）</span><br><span class="line">&#123;</span><br><span class="line">    cnt++;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PORTD_IRQHandler()        //每当D8跳变（产生脉冲）调用该中断服务函数         </span><br><span class="line">&#123;</span><br><span class="line">    PORT_FUNC(D,8,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PIT0_IRQHandler()          //定时中断函数，每500ms调用一次</span><br><span class="line">&#123;</span><br><span class="line">    int16 val;</span><br><span class="line">    val = cnt;</span><br><span class="line">    cnt=0;</span><br><span class="line">    printf(&quot;\n脉冲数为%d&quot;,val);</span><br><span class="line">    </span><br><span class="line">    if(PTA8_IN==1)</span><br><span class="line">       printf(&quot;\n反向旋转&quot;);</span><br><span class="line">    else</span><br><span class="line">       printf(&quot;\n正向旋转&quot;);  </span><br><span class="line">    </span><br><span class="line">    PIT_Flag_Clear(PIT0);       //清中断标志位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好好学习K60单片机&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>破解论文2</title>
    <link href="http://linmushen.com/2019/09/10/%E7%A0%B4%E8%A7%A3%E8%AE%BA%E6%96%872/"/>
    <id>http://linmushen.com/2019/09/10/破解论文2/</id>
    <published>2019-09-10T14:46:37.000Z</published>
    <updated>2019-09-12T11:08:52.593Z</updated>
    
    <content type="html"><![CDATA[<p>按照模型分类的优秀论文。<br><a id="more"></a></p><h1 id="大量数据、灰色关联、优化、聚类、神经网络"><a href="#大量数据、灰色关联、优化、聚类、神经网络" class="headerlink" title="大量数据、灰色关联、优化、聚类、神经网络"></a>大量数据、灰色关联、优化、聚类、神经网络</h1><h2 id="原文位置"><a href="#原文位置" class="headerlink" title="原文位置"></a>原文位置</h2><p>C:/Users/树枝990/Desktop/数学建模/数学建模论文/30个常用模型对应的建模比赛获奖论文（中文）/灰色关联分析/[2017年国赛高教杯奖B题]华中科技大学-基于聚类分析的双目标优化定价模型</p><h2 id="大量数据"><a href="#大量数据" class="headerlink" title="大量数据"></a>大量数据</h2><p>此题有近两千组数据。</p><h3 id="定性分析"><a href="#定性分析" class="headerlink" title="定性分析"></a>定性分析</h3><p>根据题中经纬度数据、定价数据绘制三维立体图。<br>将三组数据进行拟合三维拟合图，将经纬度用坐标表示出来，将定价用颜色深浅表示出来。</p><h3 id="定量分析"><a href="#定量分析" class="headerlink" title="定量分析"></a>定量分析</h3><p>首先要剔除异常数据，利用拉依达准则。<br>对数据进行离散化处理：将范围分为相同大小的单元格。计算每个单元格的平均影响因子数据(任务数量、会员数量、平均完成能力)。<br>熵权法确定会员的得分。</p><blockquote><p>熵权法教程<br><a href="https://blog.csdn.net/qq_32942549/article/details/80019005" target="_blank" rel="noopener">https://blog.csdn.net/qq_32942549/article/details/80019005</a><br>计算表格里会员的平均得分。<br>进行K-means聚类分析，得到各聚类的中心位置，计算每个点距中心的距离(影响因子)<br>K-means教程<br><a href="https://www.cnblogs.com/niniya/p/8784947.html" target="_blank" rel="noopener">https://www.cnblogs.com/niniya/p/8784947.html</a></p></blockquote><h2 id="灰色关联"><a href="#灰色关联" class="headerlink" title="灰色关联"></a>灰色关联</h2><p>先分为两种情况(完成/未完成)<br>计算两种情况下影响因子的相关系数(影响程度)，计算两种情况下同一因子之间的差值，从而得到对未完成影响最大的因子(即未完成原因)。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照模型分类的优秀论文。&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>链接收藏</title>
    <link href="http://linmushen.com/2019/09/06/%E9%93%BE%E6%8E%A5%E6%94%B6%E8%97%8F/"/>
    <id>http://linmushen.com/2019/09/06/链接收藏/</id>
    <published>2019-09-06T15:46:52.000Z</published>
    <updated>2019-09-28T07:16:56.072Z</updated>
    
    <content type="html"><![CDATA[<p>几个链接，防止以后找不到<br><a id="more"></a></p><h1 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h1><p>关于论文侧重点的说明<br>&lt; <a href="https://www.zhihu.com/question/65256909/answer/365283612" target="_blank" rel="noopener">https://www.zhihu.com/question/65256909/answer/365283612</a><br>建模概述<br>&lt; <a href="https://zhuanlan.zhihu.com/p/32918281" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32918281</a></p><p>论文模板<br><a href="https://wenku.baidu.com/view/a3bd8763783e0912a2162a9e.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/a3bd8763783e0912a2162a9e.html</a></p><p>matlab文档查询</p><blockquote><p><a href="https://ww2.mathworks.cn/help/matlab/index.html" target="_blank" rel="noopener">https://ww2.mathworks.cn/help/matlab/index.html</a></p></blockquote><p>matlab统计概率分布</p><blockquote><p><a href="https://www.cnblogs.com/djcsch2001/archive/2012/02/05/2339193.html" target="_blank" rel="noopener">https://www.cnblogs.com/djcsch2001/archive/2012/02/05/2339193.html</a></p></blockquote><p>学校图书馆地址</p><blockquote><p><a href="http://lib.hrbust.edu.cn/" target="_blank" rel="noopener">http://lib.hrbust.edu.cn/</a></p></blockquote><p>数学建模的一般步骤</p><blockquote><p><a href="https://wenku.baidu.com/view/dc1712795acfa1c7aa00cc65.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/dc1712795acfa1c7aa00cc65.html</a></p></blockquote><p>数学建模算法大全</p><blockquote><p><a href="https://blog.csdn.net/weixin_43107805/article/details/89069182?utm_source=app" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43107805/article/details/89069182?utm_source=app</a><br><a href="https://blog.csdn.net/dyq1995/article/details/84426634" target="_blank" rel="noopener">https://blog.csdn.net/dyq1995/article/details/84426634</a></p></blockquote><p>数学建模模型资料</p><blockquote><p><a href="https://blog.csdn.net/qq_41149269/article/details/95755089" target="_blank" rel="noopener">https://blog.csdn.net/qq_41149269/article/details/95755089</a></p></blockquote><p>数学建模模型应用视频</p><blockquote><p><a href="https://www.bilibili.com/video/av39876234?from=search&amp;seid=12304942382843021294" target="_blank" rel="noopener">https://www.bilibili.com/video/av39876234?from=search&amp;seid=12304942382843021294</a></p></blockquote><h1 id="恩智浦"><a href="#恩智浦" class="headerlink" title="恩智浦"></a>恩智浦</h1><p>智能车基地论坛</p><blockquote><p><a href="http://www.daimxa.cn/forum.php" target="_blank" rel="noopener">http://www.daimxa.cn/forum.php</a></p></blockquote><p>山外论坛</p><blockquote><p><a href="http://www.vcan123.com/forum.php" target="_blank" rel="noopener">http://www.vcan123.com/forum.php</a></p></blockquote><p>智能车制作</p><blockquote><p><a href="http://www.znczz.com/" target="_blank" rel="noopener">http://www.znczz.com/</a></p></blockquote><p>pid学习链接</p><blockquote><p><a href="http://www.vcan123.com/forum.php?mod=viewthread&amp;tid=7726" target="_blank" rel="noopener">http://www.vcan123.com/forum.php?mod=viewthread&amp;tid=7726</a></p></blockquote><p>一个不错的资源贴</p><blockquote><p><a href="http://www.znczz.com/forum.php?mod=viewthread&amp;tid=79721&amp;extra=page%3D1" target="_blank" rel="noopener">http://www.znczz.com/forum.php?mod=viewthread&amp;tid=79721&amp;extra=page%3D1</a></p></blockquote><p>有关电子电路</p><blockquote><p><a href="http://www.vcan123.com/forum.php?mod=viewthread&amp;tid=6241" target="_blank" rel="noopener">http://www.vcan123.com/forum.php?mod=viewthread&amp;tid=6241</a></p></blockquote><p>很好的一个介绍贴</p><blockquote><p><a href="https://blog.csdn.net/lczdk/article/details/53891920" target="_blank" rel="noopener">https://blog.csdn.net/lczdk/article/details/53891920</a></p></blockquote><p>山外鹰眼相关的帖子</p><blockquote><p><a href="https://blog.csdn.net/weixin_30735391/article/details/97529786" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30735391/article/details/97529786</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个链接，防止以后找不到&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>c语言学习笔记</title>
    <link href="http://linmushen.com/2019/09/06/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/09/06/c语言学习笔记/</id>
    <published>2019-09-06T08:14:10.000Z</published>
    <updated>2019-09-27T03:39:50.075Z</updated>
    
    <content type="html"><![CDATA[<p>系统学习C语言，准备国二。<br><a id="more"></a></p><h1 id="乱记"><a href="#乱记" class="headerlink" title="乱记"></a>乱记</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=3,b=2,c=1,d,f;</span><br><span class="line">cout&lt;&lt;(f=a&gt;b&gt;c)&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>输出结果为0。<br>f= a&gt;b&gt;c  —&gt;  a&gt;b为真，a&gt;b这一串变为1，但1&gt;c为假，所以输出为0。</p><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=1,b=0,c=123;</span><br><span class="line">cout&lt;&lt;(a&amp;&amp;b&amp;&amp;c++)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&apos;\n&apos;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">while(1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>输出结果为0、123。<br>原因是b为0，该表达式被短路，下一句(c++)不再被执行，因此c=123。</p><h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h2><p>？：称为条件运算符，就是表示?前的表达式的值是否为真，是的话取冒号前的值，否则取冒号后的值。<br>z = x&gt;y?x:y 含义是如果x&gt;y为真，那么把x的值赋给Z，否则把Y的值赋给Z。</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="优先级记忆口诀"><a href="#优先级记忆口诀" class="headerlink" title="优先级记忆口诀"></a>优先级记忆口诀</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">括号成员第一;        //括号运算符[]() 成员运算符.  -&gt;</span><br><span class="line"></span><br><span class="line">全体单目第二;        //所有的单目运算符比如++、 --、 +(正)、 -(负) 、指针运算*、&amp;乘除余三,加减四;   //这个&quot;余&quot;是指取余运算即%</span><br><span class="line"></span><br><span class="line">移位五，关系六;    //移位运算符：&lt;&lt; &gt;&gt; ，关系：&gt; &lt; &gt;= &lt;= 等</span><br><span class="line"></span><br><span class="line">等于(与)不等排第七;    //即== 和!=</span><br><span class="line"></span><br><span class="line">位与异或和位或;    //这几个都是位运算: 位与(&amp;)异或(^)位或(|)    </span><br><span class="line"></span><br><span class="line">&quot;三分天下&quot;八九十;  </span><br><span class="line"></span><br><span class="line">逻辑或跟与;            //逻辑运算符:|| 和 &amp;&amp;</span><br><span class="line"></span><br><span class="line">十二和十一;            //注意顺序:优先级(||)  底于 优先级(&amp;&amp;) </span><br><span class="line"></span><br><span class="line">条件高于赋值,        //三目运算符优先级排到13 位只比赋值运算符和&quot;,&quot;高</span><br><span class="line"></span><br><span class="line">逗号运算级最低!    //逗号运算符优先级最低</span><br></pre></td></tr></table></figure></code></pre><p>贴一个非常好的关于优先级的帖子：<a href="https://blog.csdn.net/u013630349/article/details/47444939" target="_blank" rel="noopener">https://blog.csdn.net/u013630349/article/details/47444939</a></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h3><ol><li>基本类型—字符型(char)、整型(int)、逻辑型(bool)、浮点型(float(单精度)\double(双精度))</li><li>引申类型—枚举类型、数组、指针、引用</li><li>构造类型—结构体类型、共用体类型、类</li></ol><h3 id="数据的字节数"><a href="#数据的字节数" class="headerlink" title="数据的字节数"></a>数据的字节数</h3><p>short — 2 (字节)<br>int      — 4<br>long  — 4</p><p>char  — 1</p><p>float — 4；小数点后6~7位<br>double— 8；小数点后15~16位</p><p>bool  — 1</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>包括：符号常量名、变量名、函数名、类型名。<br>命名规则：以<strong>字母、下划线开头</strong>，后跟字母、数字或下划线的字符序列。<br>注：大小写有区别、不能是系统中的关键字。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>在程序运行过程中，其值不能被改变的量。</p><h3 id="整型常量"><a href="#整型常量" class="headerlink" title="整型常量"></a>整型常量</h3><p>指不带小数点的常量。<br>十进制：以0~9开头的数字。<br>八进制：以0开头后面跟八进制数字。<br>十六进制：以0x或0X开头后面跟十六进制数字。</p><h3 id="实型常量-浮点型常量"><a href="#实型常量-浮点型常量" class="headerlink" title="实型常量(浮点型常量)"></a>实型常量(浮点型常量)</h3><p>指带小数点的常量。<br>默认为double型，在数字后加f表示float型。</p><ol><li>小数形式表示。1.23、2.23</li><li><p>指数形式表示(当实数型超百万后，自动以指数形式输出)<br>e、E表示以10为底的指数。e、E的两边分别为实型常量和指数部分,其中指数部分必须是整数。1.23e2、1.23e+2。<br>通过下面的语句可以将指数形式表示的数据转化为小数形式表示。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iomanip&gt;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;setiosflags(ios::fixed);</span><br></pre></td></tr></table></figure></li></ol><h3 id="字符型常量"><a href="#字符型常量" class="headerlink" title="字符型常量"></a>字符型常量</h3><p>指用<strong>单引号</strong>括起来的一个字符或一个转义字符。<br>字符常量在内存中以一;<br>字节的ASCII值的形式进行存储。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//转义字符</span><br><span class="line">\a---响铃</span><br><span class="line">\n---换行(下一行行首)</span><br><span class="line">\r---回车(本行行首)</span><br><span class="line">\b---退格</span><br><span class="line">\t---横向跳到下一个制表位</span><br><span class="line">\0---字符串结束标志</span><br><span class="line">\\---输出字符&apos;\&apos;</span><br><span class="line">\&apos;---输出字符&apos;</span><br><span class="line">\&quot;---输出字符&quot;</span><br><span class="line">\ddd---输出八进制代表的字符(\101代表A)</span><br><span class="line">\xhh---输出十六进制代表的字符(\x41代表A)</span><br></pre></td></tr></table></figure></code></pre><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>指用<strong>双引号</strong>括起来的若干字符。<br>注：</p><ol><li>字符串常量在内存中顺序存放，以’\0’(一个字节)作为结束标志，因此字符串至少占一个字节的内存。</li><li>“”称为空字符，为’\0’。</li></ol><h3 id="布尔常量"><a href="#布尔常量" class="headerlink" title="布尔常量"></a>布尔常量</h3><p>只有真(true)与假(false)。输出时分别用1和0表示。</p><h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><p>类似变量的常量。<br>声明方式有：</p><ol><li><p>用预处理命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define 符号常量 值常量</span><br><span class="line">//如：</span><br><span class="line">#define PI 3.1415926//结尾不带分号;</span><br></pre></td></tr></table></figure></li><li><p>用常量定义符号</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const 类型声明 符号常量 = 值常量；</span><br><span class="line">//如：</span><br><span class="line">const double PI = 3.1415926;</span><br></pre></td></tr></table></figure></li></ol><p>二者区别：</p><ol><li>define是在预处理时执行完毕的，而const是在执行语句时执行的。</li><li>define赋值无类型，因此<strong>不占内存</strong>，而cinst有类型，因此占内存。</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在程序运行过程中可以被多次赋值的量。<br>值得注意的是，不论赋值还是初始化，都在编译时根据变量的类型为变量分配存储空间，运行时再进行赋值。</p><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//一般语句形式</span><br><span class="line">数据类型 变量名1，变量名2,···,变量名n;</span><br></pre></td></tr></table></figure></code></pre><p>注：</p><ol><li>变量名不能是关键字。</li><li>先定义后使用。</li><li>只定义没赋值时，变量的值是不确定的。</li><li>变量可被多次赋值，得到的是最后一次的值。</li></ol><h3 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h3><p>变量赋值是把相应类型的数据送到变量所指定的存储空间的操作。<br>通过’=’来实现</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//一般形式为</span><br><span class="line">变量名 = 其值;</span><br></pre></td></tr></table></figure></code></pre><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>在定义变量的同时给变量赋值。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//一般形式为</span><br><span class="line">数据类型 变量名 = 表达式；</span><br><span class="line">数据类型 变量名 (表达式)；</span><br></pre></td></tr></table></figure></code></pre><h2 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h2><p>C将除了控制语句和输入输出对象以外几乎所有的基本操作都当作运算符处理，有运算符连接起来的式子称为表达式，表达式要在同一行上书写。<br>运算符包括：</p><blockquote><ol><li>算术运算符</li><li>赋值运算符</li><li>逗号运算符</li></ol></blockquote><p>着重关注：</p><ol><li>操作数的个数(目数)</li><li><p>优先级：</p><blockquote><p>优先级的数字越小，优先级越高。</p></blockquote></li><li><p>结合性：</p><blockquote><p>右结合性：自右向左进行计算。<br>左结合性：自左向右进行计算。</p></blockquote></li></ol><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>右结合性(一般为单目)<br> 名字    含义        优先级</p><ol><li><ul><li>取负        2</li></ul></li><li><ul><li>取正        2</li></ul></li><li>++    自增1    2</li><li>–    自减1    2<br>左结合性(一般为双目)</li><li><ul><li>乘        3</li></ul></li><li>/    除        3</li><li>%    取余        3</li><li><ul><li>加        3</li></ul></li><li><ul><li>减        3</li></ul></li></ol><h3 id="关于除法、取余"><a href="#关于除法、取余" class="headerlink" title="关于除法、取余"></a>关于除法、取余</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;5/2=&quot;&lt;&lt;5/2&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;2/5=&quot;&lt;&lt;2/5&lt;&lt;endl;//整数相除时，结果为整数</span><br><span class="line">cout&lt;&lt;&quot;5.0/2=&quot;&lt;&lt;5.0/2&lt;&lt;endl;//两数之中有一个是实型数时，结果为double型。</span><br><span class="line">cout&lt;&lt;&quot;5%2=&quot;&lt;&lt;5%2&lt;&lt;endl;//取余两边必须是整型数</span><br><span class="line">cout&lt;&lt;&quot;-5%2=&quot;&lt;&lt;-5%2&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;5%-2=&quot;&lt;&lt;5%-2&lt;&lt;endl;//余数的符号同被除数</span><br><span class="line">while(1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>输出</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5/2=2</span><br><span class="line">2/5=0</span><br><span class="line">5.0/2=2.5</span><br><span class="line">5%2=1</span><br><span class="line">-5%2=-1</span><br><span class="line">5%-2=1</span><br></pre></td></tr></table></figure></code></pre><h3 id="关于自增、自减"><a href="#关于自增、自减" class="headerlink" title="关于自增、自减"></a>关于自增、自减</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int k=0,i=1,j=1;</span><br><span class="line">k=++i;</span><br><span class="line">cout&lt;&lt;&quot;k=++i=&quot;&lt;&lt;k&lt;&lt;endl;//先加，再输出；相当于：i=i+1;k=i;</span><br><span class="line">k=0;</span><br><span class="line">k=j++;</span><br><span class="line">cout&lt;&lt;&quot;k=j++=&quot;&lt;&lt;k&lt;&lt;endl;//先输出，再加；相当于：k=j;j=j+1;</span><br><span class="line">while(1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>输出</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k=++i=2</span><br><span class="line">k=j++=1</span><br></pre></td></tr></table></figure></code></pre><p>2019/9/9 20:12:46 暂停，明天继续 P23<br>明天隔的有点久，2019/9/27 9:51:25 才开始继续弄。</p><h3 id="复合运算符"><a href="#复合运算符" class="headerlink" title="复合运算符"></a>复合运算符</h3><p>在赋值运算符前加上其他的运算符构成符合运算符。如：+=、-=、*=、/=。<br>各个符合运算符的含义：</p><ol><li>a+=b—-&gt;  a=a+b</li><li>a-=b—-&gt;  a=a-b</li><li><p>a<em>=b+1–&gt;  a=a</em>(b+1)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">a+=a-=a*2;</span><br></pre></td></tr></table></figure></li></ol><p>最终a=-10。</p><p>C的计算不是将式子列出来然后带入a=5进行计算，而是每一步计算出一个a值。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a-=a*2---&gt;a=a-a*2;//得到a=-5</span><br><span class="line">a+=a-----&gt;a=a+a;  //得到a=-10</span><br></pre></td></tr></table></figure></p><h3 id="逗号运算符和逗号表达式"><a href="#逗号运算符和逗号表达式" class="headerlink" title="逗号运算符和逗号表达式"></a>逗号运算符和逗号表达式</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int sorce,number=10;</span><br><span class="line">cout&lt;&lt;&quot;现有&quot;&lt;&lt;number&lt;&lt;&quot;门课未修&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;输入分数：&quot;;</span><br><span class="line">cin&gt;&gt;sorce;</span><br><span class="line">if(sorce&gt;=60)</span><br><span class="line">&#123;</span><br><span class="line">number--,cout&lt;&lt;&quot;及格&quot;&lt;&lt;&quot;还剩&quot;&lt;&lt;number&lt;&lt;&quot;门课未修&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;该门课程未通过&quot;&lt;&lt;&quot;还剩&quot;&lt;&lt;number&lt;&lt;&quot;门课未修&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>C语言中的逗号运算符可以将多个表达式合并成为一个表达式。<br>如：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表达式1,表达式2,表达式3；//等价于</span><br><span class="line">表达式1;</span><br><span class="line">表达式2;</span><br><span class="line">表达式3;</span><br></pre></td></tr></table></figure></p><h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><ol><li>逗号运算符具有左结合性，并为最低优先级。</li><li>从左至右执行每一个表达式，最后一个表达式的值是整个逗号表达式的值,逗号表达式的值不影响单个表达式的值。</li><li>逗号表达式可以用于for()循环<blockquote><p>例如：for(i=0,j=0;i&lt;5;i++,j++)</p></blockquote></li></ol><h4 id="易错误区"><a href="#易错误区" class="headerlink" title="易错误区"></a>易错误区</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a,b</span><br><span class="line">x = (a=2,a++;b=a+1);//x=4,a++将值赋给了a，a=3，b=a+1，x=b=4</span><br><span class="line">y = (a=2,a+1,b=a+1);//x=3,a+1将值赋给了逗号表达式，a=2，y=b=a+1,y=3</span><br></pre></td></tr></table></figure></code></pre><h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><p>sizeof运算符用于计算数据类型(int,char等)、变量、数组或数组元素所占内存的字节数。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a,b[5];</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;&quot;整型数占内存字节数=&quot;&lt;&lt;sizeof(int)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;整型变量占内存字节数=&quot;&lt;&lt;sizeof(a)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;数组占内存字节数=&quot;&lt;&lt;sizeof(b)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;一个数组元素占内存字节数=&quot;&lt;&lt;sizeof(b[0])&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;数组元素的个数=&quot;&lt;&lt;sizeof(b)/sizeof(b[0])&lt;&lt;endl;//计算数组元素个数的方法。</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><p>C中数据转换可以分为自动转换、强制转换和复制转换。</p><h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><p>在进行运算时，不同类型的数据会西安自动转换成同一类型的数据，然后进行运算。<br>主要规则：</p><ol><li>低精度与高精度进行运算时，低精度转换为高精度的。</li><li>char\short型与不同类型的数据进行运算时，首先转换成int型。</li><li>float型与其他类型数据运算时，首先转换成double型。</li></ol><p>例程：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i=2;</span><br><span class="line">float f=3.14f;</span><br><span class="line">double d = 3.14;</span><br><span class="line">char c=&apos;A&apos;;</span><br><span class="line"> </span><br><span class="line">cout&lt;&lt;&quot;整型与字符型运算的结果=&quot;&lt;&lt;i+c&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;整型与单精度型运算的结果=&quot;&lt;&lt;i+f&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;整型与双精度型运算的结果=&quot;&lt;&lt;i+d&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;整型与单精度、双精度运算的结果=&quot;&lt;&lt;i+d+f&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;整型与单精度、双精度、字符型运算的结果=&quot;&lt;&lt;i+d+f+c&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">整型与字符型运算的结果=67</span><br><span class="line">整型与单精度型运算的结果=5.14</span><br><span class="line">整型与双精度型运算的结果=5.14</span><br><span class="line">整型与单精度、双精度运算的结果=8.28</span><br><span class="line">整型与单精度、双精度、字符型运算的结果=73.28</span><br></pre></td></tr></table></figure></p><p>只要由实型数据(带有小数的)数据参与，结果为双精度。</p><h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>可以将一个表达式的值强制转换为另一种类型。<br>格式如下：</p><ol><li>(类型名)表达式</li><li>类型名(表达式)<br><strong>值得注意的是，强制转换得到的是一个临时的值，表达式本身的值和类型并不改变。</strong><br>例程 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double a=1.5,b=2.5;</span><br><span class="line">c=(int)a%(int)b;//转换为int后，直接舍弃小数，1.5--&gt;1;  2.5--&gt;2</span><br><span class="line">//最终得c=1，而a，b的值并不改变</span><br></pre></td></tr></table></figure></li></ol><h3 id="赋值转换"><a href="#赋值转换" class="headerlink" title="赋值转换"></a>赋值转换</h3><p>复制转换是指等式两边类型不一致时的转换。<br>规则：<br>变量 = 表达式</p><ol><li>表达式类型转换为变量的类型。</li><li>将表达式的值转换为左侧变量类型后赋值给变量。</li><li>表达式的值超出变量类型范围则出错。</li><li>表达式本身的值和类型不变。<br>例程 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a,c=2;</span><br><span class="line">double b=3.14;</span><br><span class="line">a=b;//a=3，b还是3.14</span><br><span class="line">b=c;//b=2.0，c还是2</span><br><span class="line">a=&apos;A&apos;;//a=65(A的asc码)</span><br></pre></td></tr></table></figure></li></ol><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int num=5;//学号5</span><br><span class="line">int english,math,computer,sum;//各学科分数和总分</span><br><span class="line">double ping;//平均分</span><br><span class="line">cout&lt;&lt;&quot;输入英语分数&quot;;</span><br><span class="line">cin&gt;&gt;english;</span><br><span class="line">cout&lt;&lt;&quot;输入数学分数&quot;;</span><br><span class="line">cin&gt;&gt;math;</span><br><span class="line">cout&lt;&lt;&quot;输入计算机分数&quot;;</span><br><span class="line">cin&gt;&gt;computer;</span><br><span class="line">sum = english+math+computer;</span><br><span class="line">ping = sum/3.0;</span><br><span class="line">ping = int(ping*100)/100.0;//保留小数点后两位</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;num&lt;&lt;&quot;号学生总分为&quot;&lt;&lt;sum&lt;&lt;&quot;平均分为&quot;&lt;&lt;ping&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>#第二章习题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系统学习C语言，准备国二。&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://linmushen.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>模型模板</title>
    <link href="http://linmushen.com/2019/09/06/%E6%A8%A1%E5%9E%8B%E6%A8%A1%E6%9D%BF/"/>
    <id>http://linmushen.com/2019/09/06/模型模板/</id>
    <published>2019-09-06T06:54:24.000Z</published>
    <updated>2019-09-08T13:06:47.147Z</updated>
    
    <content type="html"><![CDATA[<p>方便比赛，做几个模板<br><a id="more"></a></p><h1 id="层次分析"><a href="#层次分析" class="headerlink" title="层次分析"></a>层次分析</h1><ol><li>选取指标</li><li>指标量化<br><img src="https://i.imgur.com/HlRPCXX.png" alt></li><li>计算权重(这一步既可以用来说明指标正确(都不为0，或不为可以忽略的数)也可以用来评价哪一个好)</li><li><h1 id="灰色预测"><a href="#灰色预测" class="headerlink" title="灰色预测"></a>灰色预测</h1><h2 id="GM-1-1"><a href="#GM-1-1" class="headerlink" title="GM(1,1)"></a>GM(1,1)</h2><p>需要输入需要预测的数据到data。<br>GM(1,1)只有一个自变量，因此他的预测自变量被默认为连续的、符合1，2，3，4….的。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line">%导入数据，并将数据转化为行向量,数据一定要用行向量</span><br><span class="line">[~,~,raw] = xlsread(&apos;表格名称&apos;,&apos;Sheet1&apos;); </span><br><span class="line">data = reshape([raw&#123;:&#125;],size(raw)); </span><br><span class="line">   n = size(data,2);%输出数据的列数</span><br><span class="line"></span><br><span class="line">%对数据进行处理</span><br><span class="line">   x1 = data&apos;;        </span><br><span class="line">   x2 = cumsum(data)&apos;;%进行累加</span><br><span class="line"></span><br><span class="line">   %求微分方程的系数</span><br><span class="line">   B = [-0.5*(x1(1:n-1)+x2(2:n)),ones(n-1,1)];</span><br><span class="line">   Y = data(2:n)&apos;;</span><br><span class="line">   u = B\Y;</span><br><span class="line"></span><br><span class="line">%构建微分方程</span><br><span class="line">   syms x(t)</span><br><span class="line">   x = dsolve(diff(x)+u(1)*x==u(2),x(0) == data(1));   %求得微分方程符号解</span><br><span class="line">   xt = vpa(x,n-1)   %以小数形式显示出来</span><br><span class="line"></span><br><span class="line">%检验部分</span><br><span class="line">   yuce = subs(xt,t,[0:n-1]);     %将已知值对应的序号带入，用来测试</span><br><span class="line">   yuce =double(yuce);          %转化为数值类型，便于进行差分（预测值）</span><br><span class="line">   yuce = [data(1),diff(yuce)]  %进行差分运算（得到预测值）</span><br><span class="line">   cancha = data-yuce; %计算残差</span><br><span class="line">   xiangduiwucha = abs(cancha./data)   %计算相对误差</span><br><span class="line"></span><br><span class="line">   %预测得值部分</span><br><span class="line">   yuce1 = subs(xt,t,[0:19]);</span><br><span class="line">   yuce1 =double(yuce1);</span><br><span class="line">   yuce1 = [data(1),diff(yuce1)]</span><br></pre></td></tr></table></figure></li></ol><h2 id="GM-1-N"><a href="#GM-1-N" class="headerlink" title="GM(1,N)"></a>GM(1,N)</h2><p>需要输入因变量数据、自变量1的数据、自变量2的数据。<br>需要输入预测值对应情况的自变量1的值、自变量2的值。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">%本例为GM(1,N)灰色预测模型</span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line">%导入数据，并将数据转化为行向量,数据一定要用行向量</span><br><span class="line">data = [];     %因变量，最终要进行预测的量</span><br><span class="line">x0 =[];   %自变量1</span><br><span class="line">x2 =[];   %自变量2</span><br><span class="line"></span><br><span class="line">n = size(data,2);  %计算因变量长度</span><br><span class="line"></span><br><span class="line">%检测数据是否可以进行灰色预测（可以省略）</span><br><span class="line">jibi = data(1:n-1)./data(2:n);    %计算需要预测的数据的级比</span><br><span class="line">%a = exp(-2/(n+1))</span><br><span class="line">%b = exp(2/(n+1))     %计算检验值</span><br><span class="line"></span><br><span class="line">%对数据进行处理部分</span><br><span class="line">data1 = cumsum(data);  </span><br><span class="line">x11 = cumsum(x0);</span><br><span class="line">x21 = cumsum(x2);        %进行三次累加，得到累加数据集</span><br><span class="line">for i = 1:4</span><br><span class="line">    data2(i) = (data1(i)+data1(i+1))/2;</span><br><span class="line">end          %生成一个临近数据集</span><br><span class="line">B = [-data2(1:n-1)&apos; x11(2:n)&apos; x21(2:n)&apos;]; %构造数据矩阵</span><br><span class="line">Y = data(2:n);</span><br><span class="line"></span><br><span class="line">u = B\Y&apos;;%微分方程的系数</span><br><span class="line"></span><br><span class="line">%构建微分方程部分</span><br><span class="line">syms x(t)</span><br><span class="line">x1 = dsolve(&apos;Dx1+a*x1 == b2*x2+b3*x3&apos;,&apos;x1(0)==x10&apos;);   %求得微分方程形式</span><br><span class="line">x1 = subs(x1,&#123;&apos;a&apos;,&apos;b2&apos;,&apos;b3&apos;,&apos;x10&apos;&#125;,&#123;u(1),u(2),u(3),data(1,1)&#125;);</span><br><span class="line">x1_s1 = vpa(x1,9)</span><br><span class="line">x1_s2 = vpa(simplify(x1),9)</span><br><span class="line">x1_s3 = vpa(expand(x1),9)       %时间响应方程</span><br><span class="line"></span><br><span class="line">%做带有预测数据的数据集</span><br><span class="line">x20 = [x0,预测情况对应的x1];</span><br><span class="line">x30 = [x2,预测情况对应的x2];%输入需要预测值的情况，比如x1 = 500,x2 = 400,写在对应位置</span><br><span class="line">x22 = cumsum(x20);</span><br><span class="line">x32 = cumsum(x30);%再创建一遍新累加数列</span><br><span class="line"></span><br><span class="line">%进行求解</span><br><span class="line">x1 = subs(x1,&#123;&apos;t&apos;,&apos;x2&apos;,&apos;x3&apos;&#125;,&#123;[0:n],x22,x32&#125;)</span><br><span class="line">x1 = double(x1)     %求出的是预测值的之间的差值，需要还原一步</span><br><span class="line">x10hat = [x1(1),diff(x1)]       %进行还原</span><br><span class="line"></span><br><span class="line">% 检验部分</span><br><span class="line">cancha = x0(1,:) - x10hat(1:end-1);    %计算残差</span><br><span class="line">disp(&quot;残差为&quot;)</span><br><span class="line">disp(cancha)</span><br><span class="line">xiangduiwucha = abs(cancha./x0(1,:));   %计算相对误差</span><br><span class="line">disp(&quot;相对误差为&quot;)</span><br><span class="line">disp(xiangduiwucha)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xhat = x10hat(end);      %给出最终预测结果</span><br><span class="line">disp(&quot;预测结果为&quot;)</span><br><span class="line">disp(xhat)</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;方便比赛，做几个模板&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>习题练习</title>
    <link href="http://linmushen.com/2019/08/31/%E4%B9%A0%E9%A2%98%E7%BB%83%E4%B9%A0/"/>
    <id>http://linmushen.com/2019/08/31/习题练习/</id>
    <published>2019-08-31T06:15:14.000Z</published>
    <updated>2019-09-06T06:53:25.797Z</updated>
    
    <content type="html"><![CDATA[<p>在大致学习了几类数学建模的模型和算法后，我决定开始做题试一试。<br>本节笔记例题均来自司守奎的算法与应用。<br><a id="more"></a></p><h1 id="第一章—线性规划"><a href="#第一章—线性规划" class="headerlink" title="第一章—线性规划"></a>第一章—线性规划</h1><p>线性规划问题是在一组线性约束条件限制下，求一线性目标函数最大或最小值的问题</p><h2 id="例题代码实现"><a href="#例题代码实现" class="headerlink" title="例题代码实现"></a>例题代码实现</h2><h3 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1.1"></a>例题1.1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">%习题1</span><br><span class="line"></span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">A1 = [1,-2,1;4,-1,-2];  %创建系数矩阵1(小于部分的系数)</span><br><span class="line">A2 = [-2,0,1];          %创建系数矩阵2(等于部分的系数)</span><br><span class="line">B1 = [11;-3];            %创建常数矩阵1</span><br><span class="line">B2 = [1];               %创建常数矩阵2</span><br><span class="line">f = [-3,1,1];           %目标函数系数矩阵</span><br><span class="line"></span><br><span class="line">%求解线性规划</span><br><span class="line">%[x,fval] = linprog(f,A,b,Aeq,Beq,lb,ub);</span><br><span class="line">%x为决策变量取值，fval为最优解；</span><br><span class="line">%f为目标函数的系数矩阵，A，b为不等式约束条件的系数矩阵、常数项矩阵；</span><br><span class="line">%Aeq,Beq为等式约束条件；</span><br><span class="line">%后面两个数为决策变量上下域</span><br><span class="line"></span><br><span class="line">[x,fval] = linprog(f,A1,B1,A2,B2,0);</span><br><span class="line"></span><br><span class="line">%由于Matlab算法解得的是最小值，所以需要进行一步转换</span><br><span class="line"></span><br><span class="line">fval = - fval;</span><br><span class="line">disp(&quot;当x为&quot;)</span><br><span class="line">disp(x)</span><br><span class="line">disp(&quot;时，取得最优解&quot;)</span><br><span class="line">disp(&quot;   &quot;)</span><br><span class="line">disp(&quot;最优解为&quot;)</span><br><span class="line">disp(fval)</span><br></pre></td></tr></table></figure><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当x为</span><br><span class="line">    4.0000</span><br><span class="line">    1.0000</span><br><span class="line">    9.0000</span><br><span class="line"></span><br><span class="line">时，取得最优解</span><br><span class="line">   </span><br><span class="line">最优解为</span><br><span class="line">    2.0000</span><br></pre></td></tr></table></figure></p><h3 id="例题1-2"><a href="#例题1-2" class="headerlink" title="例题1.2"></a>例题1.2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%习题2，转化为线性规划的问题</span><br><span class="line">%核心思想是将xi的绝对值进行转化---ui=(xi+|xi|)/2;vi=(xi-|xi|)/2</span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">f = 1:4;</span><br><span class="line">f = [f,f];      %目标函数系数矩阵，翻倍</span><br><span class="line">A1 = [1,-1,-1,1;1,-1,1,-3;1,-1,-2,3];</span><br><span class="line">%xi = ui-vi;因此vi的系数要取相反值</span><br><span class="line">A1 = [A1,-A1];   %等式部分的系数矩阵</span><br><span class="line">%常数项矩阵不变</span><br><span class="line">B = [0;1;-1/2]; %等使部分的常数项矩阵</span><br><span class="line">%分别求u，v的解，并将两个矩阵合并,其中xi，vi均大于0。</span><br><span class="line">[uv,fval] = linprog(f,[],[],A1,B,zeros(8,1))</span><br><span class="line">%依据xi = ui-vi来求得x。</span><br><span class="line">x = uv(1:4)-uv(5:8)</span><br></pre></td></tr></table></figure><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x =</span><br><span class="line"></span><br><span class="line">    0.2500         0         0   -0.2500</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fval =</span><br><span class="line"></span><br><span class="line">    1.2500</span><br></pre></td></tr></table></figure></p><h3 id="例题1-3"><a href="#例题1-3" class="headerlink" title="例题1.3"></a>例题1.3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%习题3</span><br><span class="line">%主要时系数比较难算，而且“设备有效台时”，“满负荷时的设备费用”等名词需要查阅确定其含义</span><br><span class="line"></span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">A1 = [5 0 0 0 0 10 0 0 0;0 7 0 0 0 0 9 0 12;0 0 6 0 0 0 0 8 0;0 0 0 4 0 0 0 0 11;0 0 0 0 7 0 0 0 0];</span><br><span class="line">A2 = [1 1 -1 -1 -1 0 0 0 0;0 0 0 0 0 1 1 -1 0];</span><br><span class="line">B1 = [6000;10000;4000;7000;4000];</span><br><span class="line">B2 = [0;0];</span><br><span class="line">F = [-0.75 -0.7753 0.375 0.4448 0.35 0.5 0.2889 -1.15 2.675];</span><br><span class="line">C = zeros(9,1);</span><br><span class="line">[x,fval] = linprog(F,A1,B1,A2,B2,C);</span><br><span class="line">x</span><br><span class="line">fval =-fval</span><br></pre></td></tr></table></figure><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x =</span><br><span class="line"></span><br><span class="line">   1.0e+03 *</span><br><span class="line"></span><br><span class="line">   1.2000    0.7857    0    1.4143    0.5714    0    0.5000    0.5000    0</span><br><span class="line"></span><br><span class="line">fval =</span><br><span class="line"></span><br><span class="line">   1.1106e+03</span><br></pre></td></tr></table></figure></p><p>2019/8/31 17:24:59 </p><h3 id="例题1-4"><a href="#例题1-4" class="headerlink" title="例题1.4"></a>例题1.4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">A1 = [</span><br><span class="line">    0 0 0 26.67 0 0 43.33 0 0 25.22 0 0 32.5 0 0;</span><br><span class="line">    0 0 0 0 26.67 0 0 43.33 0 0 25.22 0 0 32.5 0;</span><br><span class="line">    0 0 0 0 0 26.67 0 0 43.33 0 0 25.22 0 0 32.5;   %货舱对其体积的限制</span><br><span class="line">    0 0 0 1 0 0 1 0 0 1 0 0 1 0 0;</span><br><span class="line">    0 0 0 0 1 0 0 1 0 0 1 0 0 1 0;</span><br><span class="line">    0 0 0 0 0 1 0 0 1 0 0 1 0 0 1;      %货舱对其重量的限制</span><br><span class="line">    0 0 0 1 1 1 0 0 0 0 0 0 0 0 0;</span><br><span class="line">    0 0 0 0 0 0 1 1 1 0 0 0 0 0 0;</span><br><span class="line">    0 0 0 0 0 0 0 0 0 1 1 1 0 0 0;</span><br><span class="line">    0 0 0 0 0 0 0 0 0 0 0 0 1 1 1];%货物的重量约束</span><br><span class="line"></span><br><span class="line">B1 = [6800;8700;5300;</span><br><span class="line">    10;16;8;</span><br><span class="line">    18;15;23;12];</span><br><span class="line"></span><br><span class="line">A2 = [</span><br><span class="line">    -1 0 0 1 0 0 1 0 0 1 0 0 1 0 0;</span><br><span class="line">    0 -1 0 0 1 0 0 1 0 0 1 0 0 1 0;</span><br><span class="line">    0 0 -1 0 0 1 0 0 1 0 0 1 0 0 1;     %在i货舱的货物质量之和等于i货舱货物质量</span><br><span class="line">    8 -5 0 0 0 0 0 0 0 0 0 0 0 0 0;</span><br><span class="line">    4 0 -5 0 0 0 0 0 0 0 0 0 0 0 0;</span><br><span class="line">    0 4 -8 0 0 0 0 0 0 0 0 0 0 0 0];    %平衡条件</span><br><span class="line"></span><br><span class="line">B2 = [0;0;0;0;0;0];</span><br><span class="line"></span><br><span class="line">C = zeros(15,1);    %确保每一个数大于0</span><br><span class="line">%f = [0 0 0 172.22 172.22 172.22 253.33 253.33 253.33 152.17 152.17 152.17 237.5 237.5 237.5];</span><br><span class="line">f = [0 0 0 3100 3100 3100 3800 3800 3800 3500 3500 3500 2850 2850 2850];</span><br><span class="line">f = -f;</span><br><span class="line">[x,fval] = linprog(f,A1,B1,A2,B2,C);</span><br><span class="line">fval = -fval;</span><br><span class="line">disp(&quot;最大利润为&quot;)</span><br><span class="line">disp(fval)</span><br><span class="line">disp(&quot;货物1的质量&quot;);</span><br><span class="line">disp(x(4)+x(5)+x(6))</span><br><span class="line">disp(&quot;货物2的质量&quot;);</span><br><span class="line">disp(x(7)+x(8)+x(9))</span><br><span class="line">disp(&quot;货物3的质量&quot;);</span><br><span class="line">disp(x(10)+x(11)+x(12))</span><br><span class="line">disp(&quot;货物4的质量&quot;);</span><br><span class="line">disp(x(13)+x(14)+x(15))</span><br><span class="line">disp(&quot;货舱1的质量&quot;)</span><br><span class="line">disp(x(1))</span><br><span class="line">disp(&quot;货舱2的质量&quot;)</span><br><span class="line">disp(x(2))</span><br><span class="line">disp(&quot;货舱3的质量&quot;)</span><br><span class="line">disp(x(3))</span><br></pre></td></tr></table></figure><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">最大利润为</span><br><span class="line">   123500</span><br><span class="line"></span><br><span class="line">货物1的质量</span><br><span class="line">     0</span><br><span class="line"></span><br><span class="line">货物2的质量</span><br><span class="line">   15.0000</span><br><span class="line"></span><br><span class="line">货物3的质量</span><br><span class="line">   19.0000</span><br><span class="line"></span><br><span class="line">货物4的质量</span><br><span class="line">     0</span><br><span class="line"></span><br><span class="line">货舱1的质量</span><br><span class="line">    10</span><br><span class="line"></span><br><span class="line">货舱2的质量</span><br><span class="line">    16</span><br><span class="line"></span><br><span class="line">货舱3的质量</span><br><span class="line">     8</span><br></pre></td></tr></table></figure></p><p>不知道为啥，解出了一个比书上更优的解</p><h1 id="第二章—整数规划"><a href="#第二章—整数规划" class="headerlink" title="第二章—整数规划"></a>第二章—整数规划</h1><p>数学规划中的变量(全部或部分)限制为整数时，成为(纯或混合)整数规划。(求解得到的答案也要是整数的)</p><h2 id="0-1型整数规划"><a href="#0-1型整数规划" class="headerlink" title="0-1型整数规划"></a>0-1型整数规划</h2><p>主要难在判断有哪些0-1变量。<br>有多少种情况就要有多少个判断变量。</p><h3 id="习题2-1"><a href="#习题2-1" class="headerlink" title="习题2.1"></a>习题2.1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">f = [1 1 1 1 1 1];</span><br><span class="line">A = [</span><br><span class="line">    1 1 1 0 0 0;</span><br><span class="line">    0 1 0 1 0 0;</span><br><span class="line">    0 0 1 0 1 0;</span><br><span class="line">    0 0 0 1 0 1;</span><br><span class="line">    0 0 0 0 1 1;</span><br><span class="line">    1 0 0 0 0 0;</span><br><span class="line">    0 1 0 1 0 1];</span><br><span class="line">A1 = -A;</span><br><span class="line">B1 = [-1;-1;-1;-1;-1;-1;-1];</span><br><span class="line">C =zeros(1,6);</span><br><span class="line">D = ones(1,6);</span><br><span class="line">[x,fval] = linprog(f,A1,B1,[],[],C);</span><br><span class="line">disp(&quot;最少可修建&quot;)</span><br><span class="line">disp(fval)</span><br><span class="line">disp(&quot;座小学&quot;)</span><br><span class="line">disp(&quot;他们分别是&quot;)</span><br><span class="line">disp(x&apos;)</span><br></pre></td></tr></table></figure><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最少可修建</span><br><span class="line">     3</span><br><span class="line"></span><br><span class="line">座小学</span><br><span class="line">他们分别是B1,B4,B5</span><br></pre></td></tr></table></figure></p><p>可能是我这道题很简单，所以我觉得本质还是线性规划，只是限定了一下区间。</p><h3 id="习题2-2"><a href="#习题2-2" class="headerlink" title="习题2.2"></a>习题2.2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">%习题2.2</span><br><span class="line">%0-1规划</span><br><span class="line">%比较好算，没什么可注释的</span><br><span class="line">A1 = [</span><br><span class="line">    1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0;</span><br><span class="line">    0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0;</span><br><span class="line">    0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0;</span><br><span class="line">    0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1;</span><br><span class="line">    ];</span><br><span class="line">A1 = -A1;</span><br><span class="line">A2 = [</span><br><span class="line">    1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;</span><br><span class="line">    0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;    </span><br><span class="line">    0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0;</span><br><span class="line">    0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0;</span><br><span class="line">    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0;</span><br><span class="line">    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1;</span><br><span class="line">    ];</span><br><span class="line">B1 = [1;1;1;1];</span><br><span class="line">B2 = [1;1;1;1;1;1];</span><br><span class="line">C = zeros(24,1);</span><br><span class="line">D = ones(24,1);</span><br><span class="line">f = [4 2 3 4 6 4 5 5 7 6 7 6 7 8 8 6 7 9 8 6 7 10 8 6];</span><br><span class="line">f = -f</span><br><span class="line">[x,fval] = linprog(f,A1,B1,A2,B2,C,D);</span><br><span class="line">disp(&quot;最大利润为&quot;)</span><br><span class="line">fval = -fval</span><br><span class="line">disp(&quot;分配矩阵为&quot;)</span><br><span class="line">x&apos;</span><br></pre></td></tr></table></figure><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">最大利润为</span><br><span class="line"></span><br><span class="line">fval =</span><br><span class="line"></span><br><span class="line">    44</span><br><span class="line"></span><br><span class="line">分配矩阵为</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line">     0     0     0     1</span><br><span class="line">   1     0     0     0  </span><br><span class="line">  0     0 1     0</span><br><span class="line">     0     0     1     0</span><br><span class="line">     0     1     0     0</span><br><span class="line">     0     1     0     0</span><br></pre></td></tr></table></figure></p><h3 id="习题2-3"><a href="#习题2-3" class="headerlink" title="习题2.3"></a>习题2.3</h3><p>第一问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">f = [</span><br><span class="line">8.4 9.3 8.4 8.1 8.4 9.4 9.5 8.4 8.4 9.0</span><br><span class="line">8.4 8.4 8.1 8.7 9.0 8.7 8.4 8.8 8.4 8.1</span><br><span class="line">9.1 8.4 8.4 9.0 8.3 8.5 8.3 8.7 8.4 8.2</span><br><span class="line">8.7 8.9 9.5 8.4 9.4 8.4 8.4 8.2 9.3 9.1</span><br><span class="line">];  %系数矩阵</span><br><span class="line">A1 = [</span><br><span class="line">1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1</span><br><span class="line">];</span><br><span class="line">B1  = [</span><br><span class="line">6;6;6;6;3;3;3;3;3;3;3;3;3;3</span><br><span class="line">];</span><br><span class="line">A2 = [</span><br><span class="line">1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0;</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; %2</span><br><span class="line">0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 ; %3</span><br><span class="line">0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 ;%4</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;%5</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;%6</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;%7</span><br><span class="line">0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0;%8</span><br><span class="line">0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0;%9</span><br><span class="line">0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 %10</span><br><span class="line">];</span><br><span class="line">A3 =[</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; %1</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; %2</span><br><span class="line">0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 ; %3</span><br><span class="line">0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 ;%4</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;%5</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;%6</span><br><span class="line">0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0;%7</span><br><span class="line">0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0;%8</span><br><span class="line">0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0;%9</span><br><span class="line">0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 %10</span><br><span class="line">];</span><br><span class="line">a1 = [</span><br><span class="line">0 1 0 0 1 1 1 0 0 0 0 1 0 0 1 1 1 0 0 0 0 1 0 0 1 1 1 0 0 0 0 1 0 0 1 1 1 0 0 0];</span><br><span class="line">b1 = [16];</span><br><span class="line">A4 = [A1;A2];</span><br><span class="line">A5 = [A1;A3];</span><br><span class="line">[x,fval]=linprog(-f,A4,B1,a1 ,b1,zeros(40,1),ones(40,1));</span><br><span class="line">a = -fval</span><br><span class="line">%[x,fval] = linprog(-f,A5,B1,a1,b1,zeros(40,1),ones(40,1));</span><br><span class="line">%b = -fval</span><br></pre></td></tr></table></figure></p><p>解得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最优解为：212.0000</span><br></pre></td></tr></table></figure></p><p>第二问：</p><h1 id="第三章—非线性规划"><a href="#第三章—非线性规划" class="headerlink" title="第三章—非线性规划"></a>第三章—非线性规划</h1><p>目标函数或约束条件中包含非线性函数的规划问题叫非线性规划问题。</p><h1 id="第四章—预测方法"><a href="#第四章—预测方法" class="headerlink" title="第四章—预测方法"></a>第四章—预测方法</h1><h2 id="插值法"><a href="#插值法" class="headerlink" title="插值法"></a>插值法</h2><h3 id="习题4-1"><a href="#习题4-1" class="headerlink" title="习题4.1"></a>习题4.1</h3><p>本题通过插值法求出步长0.1下对应的每一个速度点，进而得出图像</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">% 第一段时间部分</span><br><span class="line">y1 = [9.68 9.48 9.31 9.13 8.98 8.81 8.69 8.52 8.39 8.22];   %第一个时间段水位的高度</span><br><span class="line">xce = [0:0.1:8.22]; %需要预测的时间段</span><br><span class="line">x1 = [0 0.92 1.84 2.95 3.87 4.98 5.9 7.01 7.93 8.97];   %已知的时刻</span><br><span class="line"></span><br><span class="line">%p1 = pchip(x1,y1,xce);</span><br><span class="line">y1 = y1*pi/4*302.76;    %每时刻对应水的体积</span><br><span class="line">v = gradient(y1&apos;,x1&apos;)   %每时刻对应的水流速度</span><br><span class="line">v1 = pchip(x1,v,xce);   %将所有时刻的速度计算出来</span><br><span class="line">figure(1)</span><br><span class="line">plot(xce,-v1,&apos;r&apos;)</span><br><span class="line"></span><br><span class="line">%第二段时间部分</span><br><span class="line">x2 = [10.95 12.03 12.95 13.88 14.98 15.9 16.83 17.93 19.04 19.96 20.84 ];   %第二段时间中的时刻</span><br><span class="line">y2 = [10.82 10.5 10.21 9.94 9.65 9.41 9.18 8.92 8.66 8.43 8.22];</span><br><span class="line">xce2 = [10.95:0.1:20.84];   %第二次的时间段</span><br><span class="line"></span><br><span class="line">y2 = y2*pi/4*302.76;    %每时刻对应水的体积</span><br><span class="line">v2 = gradient(y2&apos;,x2&apos;)   %每时刻对应的水流速度</span><br><span class="line">v2 = pchip(x2,v2,xce2);   %将所有时刻的速度计算出来</span><br><span class="line">figure(2)</span><br><span class="line">plot(xce2,-v2,&apos;g&apos;)</span><br><span class="line"></span><br><span class="line">%第三段时间部分</span><br><span class="line">x3 = [23.88 24.99 25.91];</span><br><span class="line">y3 = [10.59 10.35 10.18];</span><br><span class="line">xce3 = [23.88:0.1:25.91];</span><br><span class="line">y3 = y3*pi/4*302.76;    %每时刻对应水的体积</span><br><span class="line">v3 = gradient(y3&apos;,x3&apos;)   %每时刻对应的水流速度</span><br><span class="line">v3 = pchip(x3,v3,xce3);   %将所有时刻的速度计算出来</span><br><span class="line">figure(3)</span><br><span class="line">plot(xce3,-v3)</span><br><span class="line"></span><br><span class="line">%绘制总体图</span><br><span class="line">x = [xce xce2 xce3];</span><br><span class="line">V = [-v1 -v2 -v3];</span><br><span class="line">figure(4)</span><br><span class="line">plot(x,V,&apos;r&apos;)</span><br></pre></td></tr></table></figure></code></pre><p>解得图像<br><img src="https://i.imgur.com/pBMYPFs.png" alt></p><h2 id="拟合法"><a href="#拟合法" class="headerlink" title="拟合法"></a>拟合法</h2><h3 id="习题1-1"><a href="#习题1-1" class="headerlink" title="习题1.1"></a>习题1.1</h3><p>本题为插值法1.1的另一种解。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">% 第一段时间部分</span><br><span class="line">y1 = [9.68 9.48 9.31 9.13 8.98 8.81 8.69 8.52 8.39 8.22];   %第一个时间段水位的高度</span><br><span class="line">xce = [0:0.1:8.22]; %需要预测的时间段</span><br><span class="line">x1 = [0 0.92 1.84 2.95 3.87 4.98 5.9 7.01 7.93 8.97];   %已知的时刻</span><br><span class="line"></span><br><span class="line">y1 = y1*pi/4*302.76;    %每时刻对应水的体积</span><br><span class="line">v = gradient(y1&apos;,x1&apos;);  %每时刻对应的水流速度</span><br><span class="line">v = -v;</span><br><span class="line"></span><br><span class="line">a1 = polyfit(x1,v&apos;,3);</span><br><span class="line">Y1 = polyval(a1,xce);</span><br><span class="line"></span><br><span class="line">figure(1)</span><br><span class="line">plot(xce,Y1)</span><br><span class="line">%第二部分时间计算</span><br><span class="line">x2 = [10.95 12.03 12.95 13.88 14.98 15.9 16.83 17.93 19.04 19.96 20.84 ];   %第二段时间中的时刻</span><br><span class="line">y2 = [10.82 10.5 10.21 9.94 9.65 9.41 9.18 8.92 8.66 8.43 8.22];</span><br><span class="line">xce2 = [10.95:0.1:20.84];   %第二次的时间段</span><br><span class="line"></span><br><span class="line">y2 = y2*pi/4*302.76;    %每时刻对应水的体积</span><br><span class="line">v2 = gradient(y2&apos;,x2&apos;);  %每时刻对应的水流速度</span><br><span class="line">v2 = -v2;</span><br><span class="line"></span><br><span class="line">a2 = polyfit(x2,v2&apos;,3);</span><br><span class="line">Y2 = polyval(a2,xce2);</span><br><span class="line"></span><br><span class="line">figure(2)</span><br><span class="line">plot(xce2,Y2)</span><br><span class="line">% 第三段时间部分</span><br><span class="line">x3 = [23.88 24.99 25.91];</span><br><span class="line">y3 = [10.59 10.35 10.18];</span><br><span class="line">xce3 = [23.88:0.1:25.91];</span><br><span class="line">y3 = y3*pi/4*302.76;    %每时刻对应水的体积</span><br><span class="line">v3 = gradient(y3&apos;,x3&apos;)   %每时刻对应的水流速度</span><br><span class="line">v3 = -v3</span><br><span class="line"></span><br><span class="line">a3 = polyfit(x3,v3&apos;,3);</span><br><span class="line">Y3 = polyval(a3,xce3);</span><br><span class="line"></span><br><span class="line">figure(3)</span><br><span class="line">plot(xce3,Y3)</span><br><span class="line">%绘制总图</span><br><span class="line">x = [xce xce2 xce3];</span><br><span class="line">V = [Y1 Y2 Y3];</span><br><span class="line">figure(4)</span><br><span class="line">plot(x,V,&apos;r&apos;)</span><br></pre></td></tr></table></figure></code></pre><p>解得图像<br><img src="https://i.imgur.com/yeigMaS.png" alt></p><h2 id="灰色预测法"><a href="#灰色预测法" class="headerlink" title="灰色预测法"></a>灰色预测法</h2><p>###习题1.1<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">%本例为GM(1,2)灰色预测模型</span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">%导入数据，并将数据转化为行向量,数据一定要用行向量</span><br><span class="line">data = [4383 7625 10500 11316 17818];     %产品利润</span><br><span class="line">x0 =[83 131 180 195 306];   %甲原料</span><br><span class="line">x2 =[146 212 233 259 404];  %乙原料</span><br><span class="line">data2 = [0 0 0 0];</span><br><span class="line">n = size(data,2);</span><br><span class="line">jibi = data(1:n-1)./data(2:n);    %计算需要预测的数据的级比</span><br><span class="line">%a = exp(-2/(n+1))</span><br><span class="line">%b = exp(2/(n+1))   %计算检验值</span><br><span class="line">data1 = cumsum(data);  </span><br><span class="line">x11 = cumsum(x0);</span><br><span class="line">x21 = cumsum(x2);        %进行三次累加，得到数据集data1</span><br><span class="line"></span><br><span class="line">for i = 1:4</span><br><span class="line">    data2(i) = (data1(i)+data1(i+1))/2;</span><br><span class="line">end         %生成一个临近数据集</span><br><span class="line"></span><br><span class="line">B = [-data2(1:n-1)&apos; x11(2:n)&apos; x21(2:n)&apos;]; %构造数据矩阵</span><br><span class="line">Y = data(2:n);</span><br><span class="line"></span><br><span class="line">u = B\Y&apos;;</span><br><span class="line"></span><br><span class="line">syms x(t)</span><br><span class="line">x1 = dsolve(&apos;Dx1+a*x1 == b2*x2+b3*x3&apos;,&apos;x1(0)==x10&apos;);   %求得微分方程形式</span><br><span class="line">x1 = subs(x1,&#123;&apos;a&apos;,&apos;b2&apos;,&apos;b3&apos;,&apos;x10&apos;&#125;,&#123;u(1),u(2),u(3),data(1,1)&#125;);</span><br><span class="line">x1_s1 = vpa(x1,9)</span><br><span class="line">x1_s2 = vpa(simplify(x1),9)</span><br><span class="line">x1_s3 = vpa(expand(x1),9)       %时间响应方程</span><br><span class="line">x20 = [x0,400];</span><br><span class="line">x30 = [x2,500];</span><br><span class="line">x22 = cumsum(x20);</span><br><span class="line">x32 = cumsum(x30);</span><br><span class="line"></span><br><span class="line">x1 = subs(x1,&#123;&apos;t&apos;,&apos;x2&apos;,&apos;x3&apos;&#125;,&#123;[0:n],x22,x32&#125;)</span><br><span class="line">x1 = double(x1)     %求出的是预测值的之间的差值，需要还原一步</span><br><span class="line">x10hat = [x1(1),diff(x1)]       %进行还原</span><br><span class="line"></span><br><span class="line">% 检验部分</span><br><span class="line">cancha = x0(1,:) - x10hat(1:end-1)    %计算残差</span><br><span class="line">xiangduiwucha = abs(cancha./x0(1,:))   %计算相对误差</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xhat = x10hat(end)      %给出最终预测结果</span><br></pre></td></tr></table></figure></p><p>解得</p><pre><code>```残差为   1.0e+04 *   -0.4300   -0.6439   -1.0976   -1.1355   -1.7506相对误差为   51.8072   49.1555   60.9786   58.2315   57.2089预测结果为   2.3406e+04```    </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在大致学习了几类数学建模的模型和算法后，我决定开始做题试一试。&lt;br&gt;本节笔记例题均来自司守奎的算法与应用。&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>备忘录</title>
    <link href="http://linmushen.com/2019/08/30/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://linmushen.com/2019/08/30/备忘录/</id>
    <published>2019-08-30T03:28:19.000Z</published>
    <updated>2019-09-10T13:22:47.573Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>仔细阅读题目，仔细阅读规则。</em></strong></p><p><strong>模型求解在国赛中是最为重要的。评委不看重结果的准确性，但是评委看重对参数、误差的讨论，如果没有求解的话，何来误差分析。所以，无论求解正确与否，我们都必须给出结果。</strong></p><p><strong>能用彩色图的就不用黑白图，能用三维图的就不用二维图，漂亮的图对你的论文加分不少。</strong></p><p>看优秀论文时发现了一些好的方法、陈述。怕记在别的笔记中找不到。<br><a id="more"></a></p><h1 id="几个链接"><a href="#几个链接" class="headerlink" title="几个链接"></a>几个链接</h1><p>放几个链接，防止找不到<br>关于论文侧重点的说明<br>&lt; <a href="https://www.zhihu.com/question/65256909/answer/365283612" target="_blank" rel="noopener">https://www.zhihu.com/question/65256909/answer/365283612</a><br>建模概述<br>&lt; <a href="https://zhuanlan.zhihu.com/p/32918281" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32918281</a></p><p>论文模板<br><a href="https://wenku.baidu.com/view/a3bd8763783e0912a2162a9e.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/a3bd8763783e0912a2162a9e.html</a></p><p>matlab文档查询</p><blockquote><p><a href="https://ww2.mathworks.cn/help/matlab/index.html" target="_blank" rel="noopener">https://ww2.mathworks.cn/help/matlab/index.html</a></p></blockquote><p>matlab统计概率分布</p><blockquote><p><a href="https://www.cnblogs.com/djcsch2001/archive/2012/02/05/2339193.html" target="_blank" rel="noopener">https://www.cnblogs.com/djcsch2001/archive/2012/02/05/2339193.html</a></p></blockquote><p>学校图书馆地址</p><blockquote><p><a href="http://lib.hrbust.edu.cn/" target="_blank" rel="noopener">http://lib.hrbust.edu.cn/</a></p></blockquote><p>数学建模的一般步骤</p><blockquote><p><a href="https://wenku.baidu.com/view/dc1712795acfa1c7aa00cc65.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/dc1712795acfa1c7aa00cc65.html</a></p></blockquote><h1 id="层次分析法相关"><a href="#层次分析法相关" class="headerlink" title="层次分析法相关"></a>层次分析法相关</h1><ul><li>国家统计局：可以查找到许多数据（人口、学费、家庭收入等）</li><li>据简化的明瑟收益率[2]方程： Z4(p) = Wau−Wah+t× p </li><li>层次分析法是一种定性分析和定量计算相结合的方法，首先构造因素间的成对 比较矩阵 </li></ul><h1 id="实验室预约"><a href="#实验室预约" class="headerlink" title="实验室预约"></a>实验室预约</h1><p>一定要在用户预约里弄，会有一个选座位的才是。</p><h1 id="论文写作"><a href="#论文写作" class="headerlink" title="论文写作"></a>论文写作</h1><p>可以拿着一篇优秀的论文，对着写即可。</p><h1 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h1><p>摘要应该体现你用了什么方法，建立了什么模型，解决了什么问题，得出了什么结论，还可作那些推广。</p><p>摘要包括： a.模型的数学归类（在数学上属于什么类型）；b.建模的思想（思路）；c.算法思想（求解思路）；d.建模特点（模型优点，建模思想或方法，算法特点，结果检验，灵敏度分析，模型检验…….）；e.主要结果（数值结果，结论）（回答题目所问的全部“问题”）。</p><p>最好统计下每篇论文主要的思路和方法，如果不是明显现成的方法，就需要研究下他的参考论文主要是哪个方向的论文。</p><p>对于B题来说，比较容易出现使用常规方法，但是特色指标定义的办法。对于A题，比较容易出现固定方法，但是是参考文献当中才有，数模书当中没有的结果。</p><p>如果是B题，那么好办，学习的时候，结合数学建模教材，一点一点地啃，熟悉案例程序以及基本原理，这些内容在《数学建模算法与应用》这本书当中有着很好的体现。</p><p>对于A题，则更多地需要从参考文献当中获得一些信息，我前面也说到了硕博学位论文也是非常详细的，这一点和数学建模论文非常相似，可能给出了具体的软件操作甚至源代码，因此硕博论文是一个非常好的突破口。</p><p>最好多学习别人如何把自己的建模给程序化，如何设定变量，如何设定数据集，如何将解析的问题变成数值的问题，都是值得我们去考虑的。</p><h1 id="论文结果分析部分"><a href="#论文结果分析部分" class="headerlink" title="论文结果分析部分"></a>论文结果分析部分</h1><p>在我们的模型假设中，忽略了一些对问题影响的次要因素，使问题得到了简化，但必然会产生一些误差；另外解决问题的方法是很多的，在论文中可能只用了其中的一两种方法，思维可能显得比较局限；而模型本身也会有它的优势和缺陷。因此，我们在这部分应该做的工作主要有下面三点：</p><p>A． 是否能用其他方式或方法解决。</p><p>B． 模型的优缺点分析。</p><p>C． 模型的误差分析或灵敏度分析。</p><p>#关于绘图<br>设置线宽度(LineWidth)，标记点的边缘颜色(MarkerEdgeColor)，<br>填充颜色 (MarkerFaceColor)及标记点的大小(MarkerSize)</p><p>例:设置绘图线的线型,颜色,宽度,标记 点的颜色及大小：<br>t=0:pi/20:pi;<br>y=sin(4<em>t).</em>sin(t)/2;<br>plot(t,y,’-bs’,’LineWidth’,2,… %设置线的宽度为2<br>‘MarkerEdgeColor’,’k’,… %设置标记点边缘颜色为黑色<br>‘MarkerFaceColor’,’y’,… %设置标记点填充颜色为黄色<br>‘MarkerSize’,10) %设置标记点的尺寸为10</p><h1 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h1><p>怎样用matlab确定数据的分布<br>分布的正太性检验：<br>x为你要检验的数据。<br>load x<br>histfit(x);<br>normplot(x);<br>从这两个图中可以看出是否近似服从正太分布。<br>然后估计参数：<br>[muhat,sigmahat,muci,sigmaci]=normfit(x);<br>muhat , sigmahat,muci,sigmaci 分别表示均值、方差、均值的0.95置信区间、方差0.95置信区间。<br>现在可以用t检验法对其进行检验： </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;仔细阅读题目，仔细阅读规则。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模型求解在国赛中是最为重要的。评委不看重结果的准确性，但是评委看重对参数、误差的讨论，如果没有求解的话，何来误差分析。所以，无论求解正确与否，我们都必须给出结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;能用彩色图的就不用黑白图，能用三维图的就不用二维图，漂亮的图对你的论文加分不少。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看优秀论文时发现了一些好的方法、陈述。怕记在别的笔记中找不到。&lt;br&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://linmushen.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>Matlab学习笔记</title>
    <link href="http://linmushen.com/2019/08/16/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/08/16/Matlab学习笔记/</id>
    <published>2019-08-16T05:16:47.000Z</published>
    <updated>2019-08-31T07:45:22.690Z</updated>
    
    <content type="html"><![CDATA[<p>好好学习Matlab。<br><a id="more"></a></p><p>学习目标：基本常用拟合曲线形式及特点、线性拟合线性度。了解插值、回归。<br>微分、偏微分方程求解及数值解，了解数学意义及程序</p><p>知识积累：<br>运算：<br>1） .  ：矩阵中相同位置的元素进行.后的运算。</p><p>函数：<br>1）画图<br>x = linspace(起始点，终止点，点的个数)<br>y = sin(x)<br>沿sin(x)曲线生成点的个数（默认是100个）个等间距的点</p><p>2）数据拟合：<br>p = polyfit(x,y,n)；返回n+1阶拟合后函数的系数。<br>配合y = polyval(p,x)；计算对应点y的值。</p><p>3）读取Excel电子表格文件<br>xlsread(filename,sheetx,xlrange)<br>filename：文件名<br>sheetx：第几个表格（sheet1,sheet2…）<br>xlrange:矩阵范围A1：H99（从A行的第一列的元素到H行的第九十九的元素之间的矩阵）</p><p>4）清除临时变量<br>clearvars 临时变量1 临时变量2；</p><p>5）创建一个新的临时图像窗口<br>figure</p><p>6）datetick(变量1，变量2)<br>变量1：要改变的轴<br>变量2：日期转变的形式<br><img src="https://i.imgur.com/DGFnl7c.png" alt></p><p>7）xlabel(txt,name,value)</p><ul><li>txt-轴标签</li><li>name-变量的名称 如 fontsize</li><li>value-变量的值  如 fontsize对应的12</li></ul><p>8）mean(变量（一个向量）)<br>返回变量的均值</p><p>9）sum(变量（一个向量）)<br>将变量累加</p><p>10）subplot(m,n,p)<br>将窗口划分成m*n个区域，并在p区域画图。</p><p>11）axis([x1 x2 y1 y2])<br>用来确定x轴y轴范围的函数。</p><p>12）<br>grid on；%添加网格<br>grid off；%去掉网格</p><p>13）unifrnd(A,B,m,n)函数<br>生成被A和B指定上下端点[A,B]的连续均匀分布的随机数组。<br>当存在m，n时，数组大小为m*n；当没有m,n时，数组大小由A,B数组确定。<br>附上Matlab文档</p><blockquote><p>A和B可以是向量也可以是标量，若两个都是向量，则两者都是列向量或都是行向量，而且维数相等。从A到B产生一系列区间，若A和B均为向量，则区间个数等于他们的维数；若其中恰有一个是向量，假设A为向量，则区间个数等于A的维数；若两个均为标量，则A&lt;= B，区间个数为1，且区间为[A,B]。然后在这一系列区间中随机产生连续均匀分布的数组R并返回之。具体例子下述。<br>如：<br>执行指令</p></blockquote><blockquote><blockquote><p>x = [1:9];<br>y = [2:10];<br>unifrnd(x,y)</p></blockquote></blockquote><p>得到</p><p>ans =</p><pre><code>1.9595    2.6557    3.0357    4.8491    5.9340    6.6787    7.7577    8.7431    9.3922</code></pre><p>从x到y产生区间[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9.10].然后从每个区间产生一个随机数，得到R。</p><blockquote><p>执行指令</p></blockquote><blockquote><blockquote><p>x = [1:3];<br>R1 = unifrnd(x,1);<br>R2 = unifrnd(1,x);</p></blockquote></blockquote><p>得到</p><p>R1 =</p><pre><code>1   NaN   NaN</code></pre><p>R2 =</p><pre><code>1.0000    1.2769    1.0923</code></pre><p>NaN表示”not a number”即不是数字。观察语句R1 = unifrnd(x,1);“从x到1”产生区间[1,1],[2,1],[3,1]显然只有第一个区间可以取得“随机数”1，其余区间不符合规定，故而返回NaN。</p><p>观察R2 = unifrnd(1,x);从1到x产生区间[1,1],[1,2],[1,3],取得随机数组R2。</p><p>14） exp(X)：指数函数，返回X中每个元素的e^x。<br>15）legend(‘线条名称1’，···，‘线条名称n’，’Location’,’Sountheast’):最后一个变量用来指定说明的位置，前面是东南处。</p><p>16）匿名函数：NAME =@(参数列表) 实现功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = @(x,y) x^2+y^2;%定义匿名函数</span><br><span class="line">f(1,2);%使用； 1^2+2^2</span><br></pre></td></tr></table></figure></p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><h2 id="学习目录"><a href="#学习目录" class="headerlink" title="学习目录"></a>学习目录</h2><p>1）了解Matlab基本用法，常用的命令。<br>2）熟悉常见模型的求解算法和套路，如：连续模型、规划模型等。<br>3）将机理建模的过程模拟出来，能够建立和求解没有套路的模型。</p><h2 id="主要题型对应的模型"><a href="#主要题型对应的模型" class="headerlink" title="主要题型对应的模型"></a>主要题型对应的模型</h2><p><img src="https://i.imgur.com/3oIfAhp.png" alt><br><img src="https://i.imgur.com/mQt1xY1.png" alt></p><h1 id="第一篇—实战项目"><a href="#第一篇—实战项目" class="headerlink" title="第一篇—实战项目"></a>第一篇—实战项目</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>已知股票的交易数据：日期、开盘价、最高价、最低价、收盘价、成交量、换手率，用某种方法来评价这只股票的价值和风险。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>作为一个科学计算问题，典型的流程是：1.获取并导入数据；2.数据探索和建模；3.分享结果</p><h2 id="Matlab实现"><a href="#Matlab实现" class="headerlink" title="Matlab实现"></a>Matlab实现</h2><h3 id="第一步—从外部读取数据（获取省略，已下为导入部分）"><a href="#第一步—从外部读取数据（获取省略，已下为导入部分）" class="headerlink" title="第一步—从外部读取数据（获取省略，已下为导入部分）"></a>第一步—从外部读取数据（获取省略，已下为导入部分）</h3><p>1）在左侧窗口下找到需要读取的数据的位置<br><img src="https://i.imgur.com/gB5VTcr.png" alt><br>2）右击该文件，点击导入数据<br>3）出现一个导入引擎<br><img src="https://i.imgur.com/gUGdBnC.png" alt><br>4）点击导入所选内容（大绿色对号），点击之前可以选择导入的形式（默认是列向量的形式），之后Matlab工作区出现这些导入的数据。</p><h3 id="第二步—数据探索和建模"><a href="#第二步—数据探索和建模" class="headerlink" title="第二步—数据探索和建模"></a>第二步—数据探索和建模</h3><p>绘制图形：<br>首先双击变量名，然后选中变量，点击绘图建，选择想要绘制的图形，可视化查看数据。<br><img src="https://i.imgur.com/djqIzuE.jpg" alt><br><img src="https://i.imgur.com/xoddok0.png" alt><br>或者输入 plot(x轴：文件名.变量名,y轴：文件名.变量名)</p><p>创建脚本：<br>还是找到数据所在位置，然后右击导入数据，进入菜单，点击大绿对号下的小箭头，选择生成脚本，然后保存该脚本。<img src="https://i.imgur.com/lUzJTng.png" alt></p><p>知识积累：<br>1）画图<br>x = linspace(起始点，终止点，点的个数)<br>y = sin(x)<br>沿sin(x)曲线生成点的个数（默认是100个）个等间距的点</p><p>2）数据拟合：<br>p = polyfit(x,y,n)；返回n+1阶拟合后函数的系数。<br>配合y = polyval(p,x)；计算对应点y的值。</p><p>3）读取Excel电子表格文件<br>xlsread(filename,sheetx,xlrange)<br>filename：文件名<br>sheetx：第几个表格（sheet1,sheet2…）<br>xlrange:矩阵范围A1：H99（从A行的第一列的元素到H行的第九十九的元素之间的矩阵）</p><p>4）清除临时变量<br>clearvars 临时变量1 临时变量2；</p><p>5）创建一个新的临时图像窗口<br>figure</p><p>6）datetick(变量1，变量2)<br>变量1：要改变的轴<br>变量2：日期转变的形式<br><img src="https://i.imgur.com/DGFnl7c.png" alt></p><p>Matlab程序<br>写在了 C:\Users\树枝990\Matlab\Matlab学习1 下</p><h3 id="第三步—发布并转换成word形式"><a href="#第三步—发布并转换成word形式" class="headerlink" title="第三步—发布并转换成word形式"></a>第三步—发布并转换成word形式</h3><p>1）点击发布下的编辑发布内容<br><img src="https://i.imgur.com/YpTRybG.png" alt></p><p>2）改为word形式<br><img src="https://i.imgur.com/ednd6ng.png" alt><br>发布出来的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc,clear,close all</span><br><span class="line">[~,~,raw] = xlsread(&apos;sz000004.xlsx&apos;,&apos;Sheet1&apos;,&apos;A2:H99&apos;);   %读取sz000004.xls文件中的sheet表格中的A2到H99之间矩阵的所有元素</span><br><span class="line">data = reshape([raw&#123;:&#125;],size(raw));     %将raw&#123;:&#125;重构成原来尺寸的矩阵</span><br><span class="line"></span><br><span class="line">Date = data(:,1);</span><br><span class="line">DataNum = data(:,2);</span><br><span class="line">Popen = data(:,3);</span><br><span class="line">Phigh = data(:,4);</span><br><span class="line">Plow = data(:,5);</span><br><span class="line">Pclose = data(:,6);</span><br><span class="line">Volum = data(:,7);</span><br><span class="line">Turm = data(:,8);</span><br><span class="line"></span><br><span class="line">clearvars data raw;</span><br><span class="line"></span><br><span class="line">plot(DataNum,Pclose,&apos;k&apos;)</span><br><span class="line">datetick(&apos;x&apos;,&apos;dd&apos;);     %修改日期形式</span><br><span class="line">xlabel(&apos;日期&apos;);</span><br><span class="line">ylabel(&apos;收盘价格&apos;);</span><br><span class="line">figure %创建一个临时窗口</span><br><span class="line">bar(Pclose)</span><br><span class="line"></span><br><span class="line">p = polyfit(DataNum,Pclose,1);</span><br><span class="line">P1 = polyval(p,DataNum);    %进行拟合</span><br><span class="line">figure</span><br><span class="line">plot(DataNum,P1,DataNum,Pclose,&apos;*g&apos;)</span><br><span class="line">value = p(1);</span><br><span class="line"></span><br><span class="line">MaxDD = maxdrawdown(Pclose);</span><br><span class="line">risk = MaxDD;</span><br></pre></td></tr></table></figure><h1 id="第二篇—回归方法"><a href="#第二篇—回归方法" class="headerlink" title="第二篇—回归方法"></a>第二篇—回归方法</h1><p>数学建模有很多方法，数学建模常用方法包括：回归、统计、机器学习、深度学习、灰色预测、主成分分析、神经网络、时间序列分析。<br>本章介绍几种回归方法。<br>回归方法分为：一元线性、一元非线性、多元回归、逐步回归、Logistic回归。</p><h2 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h2><h3 id="最小二乘法进行拟合"><a href="#最小二乘法进行拟合" class="headerlink" title="最小二乘法进行拟合"></a>最小二乘法进行拟合</h3><p>公式：y=b1*x+b0<br>确定系数的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Lxx = sum((x-mean(x)).^2); %最小二乘法</span><br><span class="line">Lxy = sum((x-mean(x)).*(y-mean(y)));</span><br><span class="line">b1 = Lxy/Lxx;              %最小二乘法拟合出来的直线的斜率</span><br><span class="line">b0 = mean(y)-b1*mean(x);   %最小二乘法拟合出来的直线的截距</span><br></pre></td></tr></table></figure><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">close all;</span><br><span class="line">x = [23.80,27.60,31.60,32.40,33.70,34.90,43.20,52.80,63.80,73.40];</span><br><span class="line">y = [41.40,51.80,61.70,67.90,68.70,77.50,95.90,137.40,155.00,175.00];</span><br><span class="line"></span><br><span class="line">figure</span><br><span class="line">plot(x,y,&apos;r*&apos;)             %画出x,y的散点图</span><br><span class="line">xlabel(&apos;x(职工工资总额)&apos;,&apos;fontsize&apos;,12)   %为x轴标注，并将字体设置为12号</span><br><span class="line">ylabel(&apos;y(商品零售总额)&apos;,&apos;fontsize&apos;,12)   %为y轴标注，并将字体设置为12号</span><br><span class="line">set(gca,&apos;linewidth&apos;,2)     %为坐标轴设置线宽为2号</span><br><span class="line"></span><br><span class="line">Lxx = sum((x-mean(x)).^2); %最小二乘法</span><br><span class="line">Lxy = sum((x-mean(x)).*(y-mean(y)));</span><br><span class="line">b1 = Lxy/Lxx;              %最小二乘法拟合出来的直线的斜率</span><br><span class="line">b0 = mean(y)-b1*mean(x);   %最小二乘法拟合出来的直线的截距</span><br><span class="line">y1 = b1*x+b0;              %拟合后的直线</span><br><span class="line">hold on</span><br><span class="line">plot(x,y1,&apos;linewidth&apos;,2);</span><br></pre></td></tr></table></figure><p>最小二乘法是将散点拟合到一条直线上，得到的直线方程是y=k<em>x+b<br>其中k的公式为<img src="https://i.imgur.com/dDKeeNE.jpg" alt><br>b的公式为y的平均值-k</em>x的平均值。</p><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://i.imgur.com/nq2Xncm.png" alt></p><h2 id="非线性回归"><a href="#非线性回归" class="headerlink" title="非线性回归"></a>非线性回归</h2><p>变量的关系并不都是线性的，用非线性回归首先要解决的问题是回归方程中参数如何估计。</p><h3 id="对数方法进行拟合"><a href="#对数方法进行拟合" class="headerlink" title="对数方法进行拟合"></a>对数方法进行拟合</h3><p>公式：y=a+b*lnx<br>确定系数a,b的方法：调用 fitnlm(x,y,m1,[0.01;0.01])函数<br>具体代码：见最后，和指数方法的一起列出</p><h3 id="指数方法进行拟合"><a href="#指数方法进行拟合" class="headerlink" title="指数方法进行拟合"></a>指数方法进行拟合</h3><p>公式：y=a*x^b<br>确定系数a,b的方法：调用fitnlm(x,y,m2,[1;1])函数<br>具体代码：见最后</p><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">%输入数据</span><br><span class="line"></span><br><span class="line">x = [1.5,4.5,7.5,10.5,13.5,16.5,19.5,22.5,25.5];</span><br><span class="line">y = [7.0,4.8,3.6,3.1,2.7,2.5,2.4,2.3,2.2];</span><br><span class="line"></span><br><span class="line">%画散点图，标明xy轴，加粗坐标轴</span><br><span class="line"></span><br><span class="line">figure</span><br><span class="line">plot(x,y,&apos;b*&apos;);</span><br><span class="line">xlabel(&apos;x(销售额x/万元)&apos;,&apos;fontsize&apos;,12)</span><br><span class="line">ylabel(&apos;y(流通费率y/%)&apos;,&apos;fontsize&apos;,12)</span><br><span class="line">set(gca,&apos;linewidth&apos;,2)</span><br><span class="line"></span><br><span class="line">%进行拟合（对数方法）</span><br><span class="line"></span><br><span class="line">m1 = @(b,x)b(1) + b(2)*log(x);</span><br><span class="line">nonlinfit1 = fitnlm(x,y,m1,[0.01;0.01]);</span><br><span class="line">b = nonlinfit1.Coefficients.Estimate;</span><br><span class="line">Y1 = b(1,1) + b(2,1)*log(x);</span><br><span class="line">hold on</span><br><span class="line">plot(x,Y1,&apos;--k&apos;,&apos;linewidth&apos;,2)</span><br><span class="line"></span><br><span class="line">%再次进行拟合（指数方法）</span><br><span class="line"></span><br><span class="line">m2 = &apos;y~b1*x^b2&apos;;</span><br><span class="line">nonlinfit2 = fitnlm(x,y,m2,[1,1]);</span><br><span class="line">b1 = nonlinfit2.Coefficients.Estimate(1,1);</span><br><span class="line">b2 = nonlinfit2.Coefficients.Estimate(2,1);</span><br><span class="line">Y2 = b1*x.^b2;</span><br><span class="line">hold on</span><br><span class="line">plot(x,Y2,&apos;r&apos;,&apos;linewidth&apos;,2)</span><br><span class="line"></span><br><span class="line">%为每条线加注释</span><br><span class="line"></span><br><span class="line">legend(&apos;原始数据&apos;,&apos;a+b*lnx&apos;,&apos;a*x^b&apos;)</span><br></pre></td></tr></table></figure><h3 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://i.imgur.com/tJM98Lu.png" alt></p><h2 id="多元回归"><a href="#多元回归" class="headerlink" title="多元回归"></a>多元回归</h2><p>在拟合之前，应先通过数据可视化，判断问题能否应该多元线性拟合。</p><h3 id="regress-函数进行拟合"><a href="#regress-函数进行拟合" class="headerlink" title="regress()函数进行拟合"></a>regress()函数进行拟合</h3><h4 id="regress-函数"><a href="#regress-函数" class="headerlink" title="regress()函数"></a>regress()函数</h4><p>[回归系数字母B，回归系数置信区间左边界bint，回归系数（中值）b，回归系数置信区间右区间rint，统计变量s]=repress(Y,X,0.05)</p><p>回归系数:[1,2,3,4]—四个，分别对应b0,b1,b2,b3,<br>回归系数置信区间:[bint,rint]—四组，分别对应b0,b1,b2,b3<br>统计变量s:相关系数的平方R^2;假设检验统计量F;F对应的概率P;s^2的值。</p><p>最终得到方程y = b0 +b1<em>x1 +b2</em>x2 +b3*x3</p><h4 id="判断模型："><a href="#判断模型：" class="headerlink" title="判断模型："></a>判断模型：</h4><p>1）结果法：回归系数置信区间不包含零点的模型比较好。残差在零点附近比较好。<br>2）R法：R越靠近1，说明相关性越高。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>首先将y转置，再构建一个n+1列的矩阵X（x1,x2…,xn均转置，第一列为ones(n,1)）</p><h4 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">%输入数据</span><br><span class="line"></span><br><span class="line">x1 = [3.5,5.3,5.1,5.8,4.2,6.0,6.8,5.5,3.1,7.2,4.5,4.9,8.0,6.5,6.6,3.7,6.2,7.0,4.0,4.5,5.9,5.6,4.8,3.9];</span><br><span class="line">x2 = [9,20,18,33,31,13,25,30,5,47,25,11,23,35,39,21,7,40,35,23,33,27,34,15];</span><br><span class="line">x3 = [6.1,6.4,7.4,6.7,7.5,5.9,6.0,4.0,5.8,8.3,5.0,6.4,7.6,7.0,5.0,4.4,5.5,7.0,6.0,3.5,4.9,4.3,8.0,5.8];</span><br><span class="line">y = [33.2,40.3,38.7,46.8,41.4,37.5,39.0,40.7,30.1,52.9,38.2,31.8,43.3,44.1,42.5,33.6,34.2,48.0,38.0,35.9,40.4,36.8,45.2,35.1];</span><br><span class="line"></span><br><span class="line">%绘制散点图</span><br><span class="line"></span><br><span class="line">plot(x1,y,&apos;b*&apos;)</span><br><span class="line">hold on</span><br><span class="line">plot(x2,y,&apos;ro&apos;)</span><br><span class="line">hold on</span><br><span class="line">plot(x3,y,&apos;g+&apos;)</span><br><span class="line">hold on</span><br><span class="line"></span><br><span class="line">%进行拟合</span><br><span class="line"></span><br><span class="line">n = 24;</span><br><span class="line">X = [ones(n,1),x1&apos;,x2&apos;,x3&apos;];</span><br><span class="line">Y = y&apos;;</span><br><span class="line">[b,bint,r,rint,s] = regress(Y,X,0.05)</span><br><span class="line"></span><br><span class="line">%写出表达式</span><br><span class="line"></span><br><span class="line">y1 = b(1)+ b(2)*x1 +b(3)*x2 +b(4)*x3</span><br></pre></td></tr></table></figure><h2 id="逐步回归"><a href="#逐步回归" class="headerlink" title="逐步回归"></a>逐步回归</h2><p>调用stepwise(X,Y,0.05,0.1)函数<br>X是由x1，x2…xn组成的，x1，x2…xn的第一个元素组成第一行，第二个组成第二行…<br>然后得到逐步回归窗口点击 Next Step 直至变成灰色，表明逐步回归结束，得到最终的回归模型。</p><h2 id="logistic回归"><a href="#logistic回归" class="headerlink" title="logistic回归"></a>logistic回归</h2><p>搞不懂，大概是输入一组数据，判断是0是1。</p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">[~,~,raw] = xlsread(&apos;Logistic.xlsx&apos;,&apos;sheet1&apos;,&apos;A2:F26&apos;);</span><br><span class="line">data = reshape([raw&#123;:&#125;],size(raw));</span><br><span class="line"></span><br><span class="line">X0 = xlsread(&apos;Logistic.xlsx&apos;,&apos;B2:D21&apos;);</span><br><span class="line">Y0 = xlsread(&apos;Logistic.xlsx&apos;,&apos;E2:E21&apos;);</span><br><span class="line">X1 = xlsread(&apos;Logistic.xlsx&apos;,&apos;B2:D26&apos;);</span><br><span class="line">%logistic函数</span><br><span class="line">GM = fitglm(X0,Y0,&apos;Distribution&apos;,&apos;binomial&apos;);</span><br><span class="line">Y1 = predict(GM,X1);</span><br><span class="line">%模型评估</span><br><span class="line">N0 = 1:size(Y0,1);N1 = 1:size(Y1,1);</span><br><span class="line">hold on</span><br><span class="line">scatter(N1&apos;,Y1,&apos;b&apos;);</span><br><span class="line">plot(N0&apos;,Y0,&apos;-kd&apos;);</span><br><span class="line">xlabel(&apos;数据点编号&apos;);</span><br><span class="line">ylabel(&apos;输出值&apos;);</span><br></pre></td></tr></table></figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1）判断变量个数：一个用一元回归，超过两个用多元回归。<br>2）如果一元，判断是否线性；如果多元，先拟合，再检验效果。</p><h1 id="第三篇—全局最优解"><a href="#第三篇—全局最优解" class="headerlink" title="第三篇—全局最优解"></a>第三篇—全局最优解</h1><h2 id="蒙特卡洛算法"><a href="#蒙特卡洛算法" class="headerlink" title="蒙特卡洛算法"></a>蒙特卡洛算法</h2><ol><li>举个例子，假如筐里有100个苹果，让我每次闭眼拿1个，挑出最大的。于是我随机拿1个，再随机拿1个跟它比，留下大的，再随机拿1个……我每拿一次，留下的苹果都至少不比上次的小。拿的次数越多，挑出的苹果就越大，但我除非拿100次，否则无法肯定挑出了最大的。这个挑苹果的算法，就属于蒙特卡罗算法——尽量找好的，但不保证是最好的。</li><li>随机算法，在采样不全时，通常不能保证找到最优解，只能说是尽量找。</li><li>由此知：蒙特卡洛算法是一种尽量找最优解的方法。<br>数值计算方法<br>1）作用：</li><li>用于计算：<br>计算圆周率：<br>设有一个正方形，正方形中间有一个内切圆，他们的面积之比为Pi/4。<br>在这个正方形内部生成10000个点，计算他们与圆心之间的距离，从而判断点是否落在圆内。如果这些点均匀分布，则落在圆内的点应占所有点的pi/4，因此将圆内点/所有点的值乘4，就是pi的值。<br><img src="https://i.imgur.com/U8jmGs2.png" alt></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%蒙特卡洛算法估计圆周率</span><br><span class="line">n = input(&apos;请输入n:&apos;);</span><br><span class="line">m = 0;</span><br><span class="line">a = 2;      %半径为2</span><br><span class="line"></span><br><span class="line">for i=1:n</span><br><span class="line">    x = rand * a/2;</span><br><span class="line">    y = rand * a/2;</span><br><span class="line">    if(x^2+y^2&lt;=(a/2)^2)</span><br><span class="line">        m = m+1;        %落入圆中的点数</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">fprintf(&apos;pi = %d\n&apos;,4*m/n)</span><br></pre></td></tr></table></figure><ol start="2"><li>用于模拟系统内部的随机运动。<br>模拟单车道交通堵塞<br>根据 Nagel-Schreckenberg 模型，车辆的运动满足以下规则。</li></ol><ul><li>当前速度是 v 。</li><li>如果前面没车，它在下一秒的速度会提高到 v + 1 ，直到达到规定的最高限速。</li><li>如果前面有车，距离为d，且 d &lt; v，那么它在下一秒的速度会降低到 d - 1 。</li><li>此外，司机还会以概率 p 随机减速， 将下一秒的速度降低到 v - 1 。</li></ul><p>在一条直线上，随机产生100个点，代表道路上的100辆车，另取概率p为0.3 。<br>横轴代表距离（从左到右），纵轴代表时间（从上到下），因此每一行就表示下一秒的道路情况。<br>该模型会随机产生交通拥堵。这就证明了，单车道即使没有任何原因，也会产生交通堵塞。</p><h2 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h2><p>上述的蒙特卡洛算法为本节中实例的一小部分，因此提前简要介绍。一下。<br>模拟退火算法为一种现代优化算法，用来求解全局最小（最优）解<br>模拟退火法：<br>核心原理：当材料从状态i进入状态j时，若E(j)&lt;=E(i),状态会被转移（E(i)=E(j)）;若为其他情况，状态会以小概率被转移。也就是说，模拟退火法是一个不断寻找新解和缓慢降温交替的过程。<br>具体实现：</p><ol><li>优化函数 f(x)。</li><li>初始温度，初始解x0。</li><li>根据初始温度，初始解，生成下一个解x2。</li><li>判断f(x2)与f(x0)的关系，并根据核心原理进行判断、取值。、</li><li>根据规定的每一个温度结束的标志，判断是否需要降温</li><li>返回第三步</li></ol><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="https://i.imgur.com/2gw4akc.png" alt></p><h3 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h3><p>求解TSP问题<br>例:有100个目标，需要找出巡航最优路径。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">clc,clear</span><br><span class="line"></span><br><span class="line">%导入数据部分</span><br><span class="line"></span><br><span class="line">[~,~,raw] = xlsread(&apos;sj.xlsx&apos;,&apos;Sheet1&apos;,&apos;A2:H26&apos;);</span><br><span class="line">sj0 = reshape([raw&#123;:&#125;],size(raw)); %将raw&#123;:&#125;重构成原来尺寸的矩阵</span><br><span class="line">x = sj0(:,[1:2:8]);     %将数据中的经度部分存储在x矩阵中</span><br><span class="line">x = x(:);               %将x（四列）转为一列</span><br><span class="line">y = sj0(:,[2:2:8]);     %将数据中的纬度部分存储在y矩阵中</span><br><span class="line">y = y(:);               %将y（四列）转为一列</span><br><span class="line"></span><br><span class="line">%对数据进行处理的部分</span><br><span class="line"></span><br><span class="line">sj = [x y];             %将xy矩阵合成，sj中第一列为x；sj中第二列为y</span><br><span class="line">d1 = [70,40];           %将基地位置存储进去</span><br><span class="line">sj = [d1;sj;d1];        %将基地存储入数据中,都整合成两列</span><br><span class="line">sj = sj*pi/180;         %将角度转为弧度制（计算距离时，位置坐标被当作角度计算）</span><br><span class="line"></span><br><span class="line">%创建距离公式，距离存储矩阵（用于存储两个点之间的距离）</span><br><span class="line"></span><br><span class="line">d = zeros(102);         %创建距离矩阵</span><br><span class="line">for i = 1:101</span><br><span class="line">    for j = i+1:102</span><br><span class="line">        d(i,j) = 6370*acos(cos(sj(i,1)-sj(j,1))*cos(sj(i,2))*cos(sj(j,2))+sin(sj(i,2))*sin(sj(i,2))*sin(sj(j,2)));</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">d =d +d&apos;;</span><br><span class="line"></span><br><span class="line">path = [];              %创建用于存储路径的矩阵</span><br><span class="line">long = inf;             %初始化距离变量（inf为正无穷）</span><br><span class="line">rand(&apos;state&apos;,sum(clock));           %初始化随机数发生器，这种写法的作用：是每一次初始值不同，避免出现相同数字</span><br><span class="line"></span><br><span class="line">%蒙特卡洛算法部分，为了得到更好的初始值，先用蒙特卡洛法求解相对较好的解</span><br><span class="line"></span><br><span class="line">for j=1:1000            %随机产生一千种解</span><br><span class="line">    path0 = [1,1+randperm(100),102];%解的情况</span><br><span class="line">    temp =0;</span><br><span class="line">    %求解每种情况对应的距离值</span><br><span class="line"></span><br><span class="line">    for i=1:101         %通过循环，解得该情况下的距离</span><br><span class="line">        temp = temp + d(path0(i)+path0(i+1));</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %对每种情况进行比较，得到最优（小）解</span><br><span class="line"></span><br><span class="line">    if temp&lt;long</span><br><span class="line">        path = path0;</span><br><span class="line">        long =temp;</span><br><span class="line">        long</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%模拟退火法部分</span><br><span class="line">e = 0.1^30;     %结束条件</span><br><span class="line">L = 20000;      %迭代次数（解空间的大小）</span><br><span class="line">at = 0.999;     %执行一次的降温比例</span><br><span class="line">T = 1;          %初始温度</span><br><span class="line">for k =1:L</span><br><span class="line">    c = 2+floor(100*rand(1,2));</span><br><span class="line">    %另c取20000次大于2的值；其中c是一个一行二列的矩阵，rand产生一行二列的元素大于0小于1的随机数矩阵</span><br><span class="line">    c = sort(c);        %对c的元素进行升序排列</span><br><span class="line">    c1 = c(1);c2=c(2);</span><br><span class="line">    df = d(path(c1-1),path(c2))+d(path(c1),path(c2+1)) - d(path(c1-1),path(c1))-d(path(c2),path(c2+1));</span><br><span class="line">    %判断两组不相邻的两个点的具体是否小于两组相邻两个点之间的距离</span><br><span class="line">    if df&lt;0</span><br><span class="line">        path = [path(1:c1-1),path(c2:-1:c1),path(c2+1:102)]; long = long+df;</span><br><span class="line">        %如果新解距离小于原来解，则进行替换</span><br><span class="line">    elseif exp(-df/T) &gt;= rand</span><br><span class="line">        path = [path(1:c1-1),path(c2:-1:c1),path(c2+1:102)]; long = long+df;</span><br><span class="line">        %以这个极小的概率，进行替换</span><br><span class="line">    end</span><br><span class="line">    T = T*at;</span><br><span class="line">    if T&lt;e</span><br><span class="line">        break;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%输出部分</span><br><span class="line"></span><br><span class="line">path;</span><br><span class="line">long;</span><br><span class="line">xx = sj(path,1);</span><br><span class="line">yy = sj(path,2);</span><br><span class="line">figure</span><br><span class="line">plot(xx,yy,&apos;- *&apos;)</span><br><span class="line">legend(&apos;巡航最优路径&apos;)</span><br><span class="line">figure</span><br><span class="line">plot(xx,yy,&apos;ro&apos;)</span><br><span class="line">legend(&apos;巡航点位置&apos;)</span><br></pre></td></tr></table></figure><h3 id="实现效果-2"><a href="#实现效果-2" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://i.imgur.com/Fe8WKHJ.jpg" alt></p><h3 id="模拟退火法模板"><a href="#模拟退火法模板" class="headerlink" title="模拟退火法模板"></a>模拟退火法模板</h3><p>依据上述程序改动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">%模拟退火法部分</span><br><span class="line">e =   ;     %结束条件（到该温度终止）</span><br><span class="line">L =   ;     %迭代次数（解空间的大小）</span><br><span class="line">at =  ;     %执行一次的降温比例</span><br><span class="line">T =   ;     %初始温度</span><br><span class="line">for k =1:L</span><br><span class="line">%&#123;</span><br><span class="line"></span><br><span class="line">计算新解的代价</span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line">    </span><br><span class="line">    if %取新解的条件（新解的代价需要满足的条件）</span><br><span class="line">        </span><br><span class="line">    %&#123;</span><br><span class="line">满足条件，进行替换</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">    elseif exp(-df/T) &gt;= rand%不满足条件且被替换的概率</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">发生这个概率的事件，进行替换</span><br><span class="line">&#125;%</span><br><span class="line">    </span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    T = T*at;%每次进行降温</span><br><span class="line">    if T&lt;e%达到目标温度，结束模拟退火法</span><br><span class="line">        break;</span><br><span class="line">    end</span><br></pre></td></tr></table></figure></p><h1 id="第三篇—评价类问题"><a href="#第三篇—评价类问题" class="headerlink" title="第三篇—评价类问题"></a>第三篇—评价类问题</h1><h2 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h2><h3 id="确定指标"><a href="#确定指标" class="headerlink" title="确定指标"></a>确定指标</h3><p>根据别人的文章，确定指标   [比如评价旅游目的地，首先应该在知网、万方数据、虫部落-快搜 等平台查找评价一个旅游目的地是否优秀的指标。（通过引用别人的指标，显得专业 1.只引用他的指标，注明引用的文章。2.引用他判断该指标的依据。）如果没有找到，则要自己思考+找别人的看法。]</p><h3 id="求指标权重"><a href="#求指标权重" class="headerlink" title="求指标权重"></a>求指标权重</h3><h4 id="绘制图表"><a href="#绘制图表" class="headerlink" title="绘制图表"></a>绘制图表</h4><ol><li>绘制权重表格。<img src="https://i.imgur.com/FnaF6hi.png" alt></li><li>二步骤带来的问题—容易考虑不周。解决方案：两个两个指标进行比较，根据两两比较的结果推算权重。   重要度表格<br><img src="https://i.imgur.com/OCMW70S.png" alt><br>重要度矩阵<br><img src="https://i.imgur.com/xyqLHyC.png" alt><h4 id="判断矩阵"><a href="#判断矩阵" class="headerlink" title="判断矩阵"></a>判断矩阵</h4><img src="https://i.imgur.com/xyqLHyC.png" alt><br>其中a11为针对的元素（苏杭、北戴河、桂林）<br>对角线两侧的数据互相呈倒数。A12=3;A21=1/3。<br>根据重要度表格，填写重要度矩阵，根据矩阵算权重。<br>记表中的元素为aij,其含义是：与j相比i的重要程度。<h4 id="一致矩阵"><a href="#一致矩阵" class="headerlink" title="一致矩阵"></a>一致矩阵</h4><img src="https://i.imgur.com/o0xa0M7.png" alt><br>一致矩阵：不发生矛盾（矛盾：A&gt;B,A=C,B&gt;C）。特点：各行各列成倍数关系。<strong>使用矩阵求权重前，一定要验证一致性；当不一致时，要判断该矩阵与一致矩阵差别是否太大</strong>验证办法：一直矩阵秩为1，特征值为n，特征向量为k*第一行元素的倒数。若矩阵非一致时，特征值&gt;n（和n的差距等于该矩阵与一致矩阵的差距）。<h4 id="一致性矩阵的验证"><a href="#一致性矩阵的验证" class="headerlink" title="一致性矩阵的验证"></a>一致性矩阵的验证</h4></li><li>一致性指标CI： CI = 最大特征值-n/n-1</li><li>查找平均随机一致性指标RI</li><li>计算一致性比例CR：CR = CI/RI</li><li>判断一致性：CR&lt;0.1,则认为该矩阵的一致性可以接受；否则需要修正。<h4 id="权重计算（算术平均法）"><a href="#权重计算（算术平均法）" class="headerlink" title="权重计算（算术平均法）"></a>权重计算（算术平均法）</h4></li><li>由一直矩阵进行归一化处理：<br><img src="https://i.imgur.com/wewwN9l.png" alt><br>以上图为例进行归一化：<br>苏杭 = 1/（1+1/2+1/4）<br>北戴河 = 1/（2+1+1/2）<br>桂林 = 1/（4+2+1）</li><li>由不一致矩阵进行归一化：<br><img src="https://i.imgur.com/jfP4t1g.png" alt><br>分别按照上述方法计算三列的（按列进行归一化），进行取平均值。<br>还有三种方法，见第一个视频的40-46分钟。</li></ol><p><strong>然后还要求几种条件的权重（景色、花费、交通等等）</strong>（用上述的方法：先填写比较程度，然后一致性处理，然后计算权重等等）</p><h3 id="指标填入"><a href="#指标填入" class="headerlink" title="指标填入"></a>指标填入</h3><p>将  地方的权重值、指标的权重值  分别填入重要度表格中。</p><h3 id="计算得分"><a href="#计算得分" class="headerlink" title="计算得分"></a>计算得分</h3><p>计算三个地方的得分，将指标权重与对应的地方的权重相乘，然后将五个指标乘后结果相加。<br><img src="https://i.imgur.com/ByTdLiZ.png" alt><br>比如：苏杭得分 = 0.5954<em>0.2636+0.0819</em>0.4758+0.4286<em>0.0538+0.6337</em>0.0981+0.1667*0.1087<br>用excel可以计算。方法：在另一个格子按=，然后选格，然后选择加减乘除就可以了。F4锁定表格，可以选不相邻的。</p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>分别用平均值法、几何法、特征值法求处权重；然后计算一致性指标、判断一致性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目标：需要评价的目标<br>方案：可以选择的方案<br>准则：评价的指标、准则<br><img src="https://i.imgur.com/zyTIcqR.png" alt><br>比较表格，通过这八个表格来填写。右边的五个小的，得到五个权重指标。左边三个大的得到每一个目的地五个指标的得分，然后对应指标的权重与得分相乘。<br>50分钟后，教制图。</p><h2 id="Mtalb实现"><a href="#Mtalb实现" class="headerlink" title="Mtalb实现"></a>Mtalb实现</h2><p>假设已知变量：6*6的矩阵A</p><ol><li>算术平均法求权重</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">%首先标准化矩阵</span><br><span class="line"></span><br><span class="line">n = 6;</span><br><span class="line">SUMA = sum(A);%对A按列求和，得到一个一行六列的矩阵</span><br><span class="line">SUMA = repmat(SUMA,n,1);  %将A平铺产生一个新矩阵，新矩阵的行数为第一个数字乘A的行数；新矩阵的列数为第二个数字乘是A的列数。得到一个六行六列的矩阵</span><br><span class="line">Stand_A = A./SUMA;%每个元素除以每一列之和，得到标准化矩阵。得到一个六行六列矩阵</span><br><span class="line"></span><br><span class="line">%然后求权重</span><br><span class="line"></span><br><span class="line">SUM1 = sum(Stand_A,2)%对标准矩阵按行求和，得到一个列向量</span><br><span class="line">SUM1 = SUM1./n%最终得到的权重</span><br></pre></td></tr></table></figure><ol start="2"><li><p>几何平均法求权重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = 6;%矩阵阶数 </span><br><span class="line">ProductA = prod(A,2);%矩阵每行种所有元素相乘，生成一个列向量（1*6）</span><br><span class="line">ProductA = ProductA.^(1/n);%将矩阵种每个元素开n次方</span><br><span class="line">ProductA = ProductA./sum(ProductA);%得到最终结果</span><br></pre></td></tr></table></figure></li><li><p>特征值法求权重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = 6;</span><br><span class="line">[V,D] =eig(A);%V是特征向量做列向量构成的矩阵；D是特征值构成的对角矩阵。</span><br><span class="line">Max_eig = max(max(D));%里面的max返回最大列向量；外面的max返回列向量中最大的数。</span><br><span class="line">[R,C] = find(D == Max_eig,1);%找到D中第一个与Max_eig相等的元素，并记录位置。</span><br><span class="line">ans = V(:,c) ./ sum(V(:,c))%最终结果</span><br></pre></td></tr></table></figure></li></ol><h1 id="第四篇—预测类问题-插值算法"><a href="#第四篇—预测类问题-插值算法" class="headerlink" title="第四篇—预测类问题(插值算法)"></a>第四篇—预测类问题(插值算法)</h1><p>当数据较少的时候，这时通过一些数学方法，模拟数据的产生一些新的有比较准确的值。<br>样本量多，用拟合；样本量少，用插值。</p><h2 id="一维数据插值的概念"><a href="#一维数据插值的概念" class="headerlink" title="一维数据插值的概念"></a>一维数据插值的概念</h2><ol><li>有n+1个点。</li><li>要有插值区间[a,b] 。</li><li>有一个函数f(x)过这n+1个点。</li><li>求f(x)的过程叫<strong>插值法</strong>。<h2 id="几种一维数据的插值形式"><a href="#几种一维数据的插值形式" class="headerlink" title="几种一维数据的插值形式"></a>几种一维数据的插值形式</h2></li><li>插值多项式：f(x)为次数不超过n的代数多项式。</li><li>分段插值：P(x)为分段多项式。</li><li>三角插值：P(x)为三角多项式。<br>前两种，尤其是第二种比较常见。<h2 id="一维数据插值"><a href="#一维数据插值" class="headerlink" title="一维数据插值"></a>一维数据插值</h2><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3></li><li>三次埃米特插值：直接调用Matlab函数：pchip(x,y,new_x);x是点横坐标；y是点纵坐标；new_x是要插入的点的横坐标。</li><li>三次样条插值：直接调用Matlab函数：splin((x,y,new_x);用法同上。<h3 id="Matlab实现-1"><a href="#Matlab实现-1" class="headerlink" title="Matlab实现"></a>Matlab实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%三次埃米特插值</span><br><span class="line">x = -pi:pi; %以1为间距生成-pi到pi的等差数列。</span><br><span class="line">y = sin(x);</span><br><span class="line">new_x = -pi:0.1:pi;%以0.1为间距生成-pi到pi的等差数列。</span><br><span class="line">p = pchip(x,y,new_x);%埃米特插值法计算p。</span><br><span class="line">plot(x,y,&apos;bo&apos;,new_x,p,&apos;r-&apos;)%绘制图像。</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%三次样条插值</span><br><span class="line">x = -pi:pi;</span><br><span class="line">y = sin(x);</span><br><span class="line">new_x = -pi:0.1:pi;</span><br><span class="line">p = pchip(x,y,new_x);</span><br><span class="line">p1 = spline(x,y,new_x);</span><br><span class="line">plot(x,y,&apos;bo&apos;,new_x,p,&apos;r--&apos;,new_x,p1,&apos;g--&apos;)</span><br></pre></td></tr></table></figure><h2 id="n维数据插值"><a href="#n维数据插值" class="headerlink" title="n维数据插值"></a>n维数据插值</h2><h2 id="实际使用-1"><a href="#实际使用-1" class="headerlink" title="实际使用"></a>实际使用</h2><p>p = interpn(x1,x2,···,xn,y,new_x1,new_x2,···,new_xn,method):method为要使用的插值方法，包括</p><ol><li>‘linear’：线条插值</li><li>‘cubic’：三次插值</li><li>‘spline’：三次样条插值（最为准确）</li><li>‘nearest’：最邻近插值</li></ol><h2 id="预测实例–人口预测"><a href="#预测实例–人口预测" class="headerlink" title="预测实例–人口预测"></a>预测实例–人口预测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%人口预测</span><br><span class="line">pop = [133126,133770,134413,135069,135738,136427,137122,137866,138639,139538];</span><br><span class="line">%过去几年人口的数据</span><br><span class="line">year = 2009:2018;%已知年份</span><br><span class="line">new_x = 2019:2021%要预测的年份</span><br><span class="line">p1 = pchip(year,pop,new_x);%埃米特插值法</span><br><span class="line">p2 = spline(year,pop,new_x);%样条插值法</span><br><span class="line">plot(year,pop,&apos;ro&apos;,new_x,p1,&apos;r-&apos;,new_x,p2,&apos;g--&apos;)</span><br></pre></td></tr></table></figure><p><strong><em>插值和拟合的区别：n&gt;30时，数据量比较大，则需要用拟合。</em></strong></p><h2 id="拟合算法"><a href="#拟合算法" class="headerlink" title="拟合算法"></a>拟合算法</h2><p>拟合算法的思想：拟合问题不需要曲线一定过给定的点。你和问题的目标是寻求一个函数（曲线），使得该曲线在某种准则下与所有的数据点距离最为接近。<br>由于多样本点时次数过高，造成龙格现象，因此出现了拟合。</p><h1 id="第五篇—多元分析法"><a href="#第五篇—多元分析法" class="headerlink" title="第五篇—多元分析法"></a>第五篇—多元分析法</h1><p>可用于聚类分析(方便画图)、回归分析，但不可用于评价类问题。</p><h2 id="主成分分析法"><a href="#主成分分析法" class="headerlink" title="主成分分析法"></a>主成分分析法</h2><p>当研究问题涉及到多变量且变量之间存在很强的相关性时，通过主成分分析法对数据进行简化。<br>主成分分析法是一种降维算法，能够将多个指标转化为少数几个主成分。<br>原则：用较少变量替代原来较多的变量，且尽量保存之前的信息。</p><h3 id="主成分分析-PCA-的思想"><a href="#主成分分析-PCA-的思想" class="headerlink" title="主成分分析(PCA)的思想"></a>主成分分析(PCA)的思想</h3><ol><li><p>根据n个样本、p个指标，<strong>构成样本矩阵x</strong></p></li><li><p>首先对样本矩阵标准化处理(调用zscore(x)函数)：<br>&lt; 按列计算均值和按列计算标准差。<br>&lt; 标准化数据为：<img src="https://i.imgur.com/4htW40V.png" alt></p></li><li>计算标准化矩阵的协方差矩阵(就是相关系数矩阵)R。<br>&lt;公式是：<blockquote><p><img src="https://i.imgur.com/DQmJppl.png" alt><br>注：以上两步可以合并为一步，直接求相关系数矩阵<br>公式为：<img src="https://i.imgur.com/UVmT5UR.png" alt><br><strong>直接调用corrcoef()函数来得到相关系数矩阵。</strong></p></blockquote></li><li>计算R的特征值(n1,n2,n3…)和特征向量，调用eig()函数可以得到。</li><li>计算主成分贡献率(ni/特征值之和)和累计贡献率(从1到该成分贡献率之和)（ni为该成分的特征值）。</li><li>写出主成分（解释主成分代表的含义）（判断条件为：累计率超过80%的特征值对应的主成分）。</li><li>主成分(F)：F1 =特征向量1<em>样本1+···+特征向量n</em>样本n</li><li>使用F进行相关操作（聚类、回归）<h3 id="实际使用-2"><a href="#实际使用-2" class="headerlink" title="实际使用"></a>实际使用</h3></li></ol><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>题目如下：<br><img src="https://i.imgur.com/Z8tCzHs.jpg" alt></p><ol><li>题中给了相关系数矩阵(实际使用中，要自己列出样本矩阵，然后调用corrvef函数求相关系数矩阵)。<br>还可以通过excel将数据可视化（相关系数越大，颜色越重）<br>&lt; 方法：通过格式设置—&gt;行高—&gt;改为50—&gt;条件格式—&gt;色阶—&gt;管理规则。</li><li>计算得到特征向量、特征值。<br><img src="https://i.imgur.com/zT65ary.jpg" alt></li><li>根据贡献率求得主成分，并根据特征向量为三个主成分命名<br>&lt; 命名的依据与xi系数的正负，大小有关。</li></ol><h4 id="Matlab实现-2"><a href="#Matlab实现-2" class="headerlink" title="Matlab实现"></a>Matlab实现</h4><p>代码和题不一致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">load data.xlxs;% 1.导入数据后默认存储为x</span><br><span class="line">[n,p] = size(x);% 2.计算样本数量、指标数量</span><br><span class="line">X = zscore(x);% 3.将x标准化处理</span><br><span class="line">R = COV(X);% 4.计算样本协方差(相关系数矩阵)矩阵</span><br><span class="line">% 前两步可以合并为: R = corrcoef(x)</span><br><span class="line">[V,D] = eig(R);% 5.计算得到V特征向量；D特征值的对角矩阵</span><br><span class="line">D = diag(D);%将D转为列向量(从小到大，不符合要求，要求为从大到小)</span><br><span class="line">D = D(end:-1:1);%从大到小，重新排列</span><br><span class="line">G = D/sum(D);%计算贡献率</span><br><span class="line">LG = cumsum(D)/sum(D);%计算累计贡献率</span><br><span class="line">V = rot90(V)&apos;;%将V逆时针旋转90度,然后转置，实现列颠倒(V的每一列与D一一对应D颠倒后V也要颠倒)</span><br><span class="line">%以上部分为用来展示在论文中的特征值、特征向量、贡献率、累计贡献率</span><br><span class="line">%以下为根据累计贡献率计算需要的主成分的值</span><br><span class="line">m = input(&apos;输入需要的主成份值&apos;)；%输出主成分指标矩阵</span><br><span class="line">F = zeros(n,m);%初始化主成分指标矩阵，行数为样本数，列数为主指标数</span><br><span class="line">for i = 1:m</span><br><span class="line">ai = V(:,i)&apos;;%将第i个指标对应的特征向量取出并转置为行向量</span><br><span class="line">Ai = repmat(ai,n,1);</span><br><span class="line">F(:,i) = sum(Ai.*X,2);%sum(  ,2)包含每一行总和的列向量</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h2 id="主成分聚类"><a href="#主成分聚类" class="headerlink" title="主成分聚类"></a>主成分聚类</h2><p>得到的主成分指标的特征向量，用它来进行Spss聚类，绘制出聚类效果图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">第一主成分第二主成分</span><br><span class="line">5.4264428242.466610071</span><br><span class="line">2.0064021720.044897784</span><br><span class="line">-0.7695772080.580486019</span><br><span class="line">-1.8487218310.404449961</span><br><span class="line">-1.8267260620.509910414</span><br><span class="line">-1.3135558720.844834476</span><br><span class="line">-1.8597657660.15135913</span><br><span class="line">-1.9275746390.636691716</span><br><span class="line">5.866580082-0.195590149</span><br><span class="line">0.407206443-0.311959647</span><br><span class="line">3.5839360230.531841117</span><br><span class="line">-1.796734483-0.519304406</span><br><span class="line">0.201157205-1.337538882</span><br><span class="line">-2.234432278-1.867172919</span><br><span class="line">-0.1474639770.983842797</span><br><span class="line">-1.947265673-0.388124368</span><br><span class="line">0.219021415-0.203553132</span><br><span class="line">-0.717010904-0.247235911</span><br><span class="line">5.583541617-3.071999293</span><br><span class="line">-0.251547629-2.058477339</span><br><span class="line">-1.15751891-1.913072019</span><br><span class="line">1.1156184440.409970592</span><br><span class="line">-0.5336503850.041788916</span><br><span class="line">-1.298147689-0.341976439</span><br><span class="line">0.4357335240.479094465</span><br><span class="line">0.4373180482.36499945</span><br><span class="line">-0.859474363-0.501061268</span><br><span class="line">-1.5494234840.526219683</span><br><span class="line">-1.0451919360.426094042</span><br><span class="line">-1.5017110160.906911419</span><br><span class="line">-0.6974636910.64706372</span><br></pre></td></tr></table></figure></p><h2 id="主成分回归"><a href="#主成分回归" class="headerlink" title="主成分回归"></a>主成分回归</h2><p>在视频主成分分析的后面，没有看。</p><h1 id="第六篇—预测类问题"><a href="#第六篇—预测类问题" class="headerlink" title="第六篇—预测类问题"></a>第六篇—预测类问题</h1><h2 id="灰色预测模型"><a href="#灰色预测模型" class="headerlink" title="灰色预测模型"></a>灰色预测模型</h2><p>灰色系统(数据集)：部分信息已知，部分信息位置。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>对原始数据进行生成处理来寻找系统变动的规律，并生成有较强规律性的数据序列，然后建立相应的微分方程模型，从而预测事物未来发展的状况。</p><h3 id="最简单的灰色预测模型GM-1-1-模型"><a href="#最简单的灰色预测模型GM-1-1-模型" class="headerlink" title="最简单的灰色预测模型GM(1,1)模型"></a>最简单的灰色预测模型GM(1,1)模型</h3><p>一阶微分方程，一个变量<br>GM(1,1)使用原始的<strong>离散非负数据列</strong>，通过依次累加生成削弱随机性的较有规律的新的离散数据列，然后通过建立微分方程模型，得到在离散处的解经过累减生成的原始数据的近似估计值，从而预测原始数据的后续发展。</p><h4 id="数据的准备"><a href="#数据的准备" class="headerlink" title="数据的准备"></a>数据的准备</h4><p>原始数据列：x(0) = x(0)(1),x(0)(2),···,x(0)(n)<br>累加数据列：x(1) = x(1)(1),x(1)(2),···,x(1)(n)[其中:x(1)(n)=x(0)(1)+···+x(0)(n)]<br>紧邻均值生成数据列：z = z(1),z(2),···,z(n)[其中:z(m) = 0.5<em> x(1)(m)+0.5</em> x(m-1)]</p><h4 id="模型的基本形式"><a href="#模型的基本形式" class="headerlink" title="模型的基本形式"></a>模型的基本形式</h4><p>x(0)(k)+a*z(k) = b   【便于理解的形式：y-kx = b】<br>b:灰作用量<br>-a:发展系数</p><h3 id="应用步骤"><a href="#应用步骤" class="headerlink" title="应用步骤"></a>应用步骤</h3><p>见司守奎类似的算法与应用P400。</p><h3 id="Matlab实现-3"><a href="#Matlab实现-3" class="headerlink" title="Matlab实现"></a>Matlab实现</h3><p>具体实现预测城市噪声。<br>参见算法与应用–灰色预测例1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">%导入数据，并将数据转化为行向量</span><br><span class="line">[~,~,raw] = xlsread(&apos;GM.xlsx&apos;,&apos;Sheet1&apos;,&apos;A2:C8&apos;);</span><br><span class="line">data = reshape([raw&#123;:&#125;],size(raw));</span><br><span class="line">data = data(:,3)&apos;;</span><br><span class="line"></span><br><span class="line">jibi = data(1:6)./data(2:7);    %计算级比</span><br><span class="line">for i = 1:6         %判断级比有没有问题</span><br><span class="line">    if(jibi(i)&gt;=0.982)</span><br><span class="line">        if(jibi(i)&lt;=1.0098)</span><br><span class="line">            a = 1;  %没问题</span><br><span class="line">        else</span><br><span class="line">            a = 0;  %有问题</span><br><span class="line">        end</span><br><span class="line">    else</span><br><span class="line">        a = 0;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">if(a==0)        %如果有问题则显示出错</span><br><span class="line">    disp(&quot;错误&quot;)</span><br><span class="line">end</span><br><span class="line">if(a==1)        %没有问题则继续进行</span><br><span class="line">    x1 = data&apos;;        %取后六位数据</span><br><span class="line">    x2 = cumsum(data)&apos;;%进行累加</span><br><span class="line">    %求微分方程的系数</span><br><span class="line">    B = [-0.5*(x1(1:6)+x2(2:7)),ones(6,1)];</span><br><span class="line">    Y = data(2:7)&apos;;</span><br><span class="line">    u = B\Y;</span><br><span class="line">    syms x(t)</span><br><span class="line">    x = dsolve(diff(x)+u(1)*x==u(2),x(0) == data(1));   %求得微分方程符号解</span><br><span class="line">    xt = vpa(x,6)   %以小数形式显示出来</span><br><span class="line">    yuce = subs(xt,t,[0:6]);     %将已知值对应的序号带入，用来测试</span><br><span class="line">    yuce =double(yuce);          %转化为数值类型，便于进行差分（预测值）</span><br><span class="line">    yuce = [data(1),diff(yuce)]  %进行差分运算（得到预测值）</span><br><span class="line">    cancha = data-yuce;</span><br><span class="line">    cancha = abs(cancha./data)   %计算残差</span><br><span class="line">    piancha = 1 - (1 - 0.5*u(1))/(1+0.5*u(1))*jibi%计算级比偏差</span><br><span class="line">    %使用 --- 预测四个未知数</span><br><span class="line">    yuce1 = subs(xt,t,[0:10]);</span><br><span class="line">    yuce1 =double(yuce1);</span><br><span class="line">    yuce1 = [data(1),diff(yuce1)]</span><br><span class="line">end</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><h1 id="第七篇—回归分析"><a href="#第七篇—回归分析" class="headerlink" title="第七篇—回归分析"></a>第七篇—回归分析</h1><p>## </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好好学习Matlab。&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>PID学习笔记</title>
    <link href="http://linmushen.com/2019/08/13/PID%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/08/13/PID学习笔记/</id>
    <published>2019-08-13T06:38:03.000Z</published>
    <updated>2019-08-18T16:13:04.306Z</updated>
    
    <content type="html"><![CDATA[<p>潜心学习技术，最近发现了一篇比较好的介绍PID的文章。学习并记录一下。<br><a id="more"></a><br>PID控制是对偏差进行比例，积分和微分的控制。PID由三个单元组成，分别是比例单元，积分单元，微分单元。</p><h1 id="位置闭环控制"><a href="#位置闭环控制" class="headerlink" title="位置闭环控制"></a>位置闭环控制</h1><h2 id="PID简介"><a href="#PID简介" class="headerlink" title="PID简介"></a>PID简介</h2><p>位置闭环控制是根据编码器的脉冲累加测量电机的位置信息，并与目标值进行比较，进而得到控制偏差，然后对偏差进行比例、积分、微分进行控制。使偏差趋近于0。</p><h2 id="PID理论知识"><a href="#PID理论知识" class="headerlink" title="PID理论知识"></a>PID理论知识</h2><p>1）PID公式<br><img src="https://i.imgur.com/j5YKEuO.png" alt><br>2）符号含义<br><img src="https://i.imgur.com/ICGUcUc.png" alt></p><h2 id="控制原理"><a href="#控制原理" class="headerlink" title="控制原理"></a>控制原理</h2><p><img src="https://i.imgur.com/JJfTRfg.png" alt><br>其中PID控制器，是一个软件实现过程（比如程序里的一个函数）。</p><h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><p>通过改变KP,KI,KD的值实现调参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int Position_PID(int Encoder,int Targe)//入口参数为位置测量值和位置目标值</span><br><span class="line">&#123;</span><br><span class="line">Static float Bias,Pwm,Integral_bias,Last_Bias;  </span><br><span class="line">Bias = Encoder-Target;//计算偏差</span><br><span class="line">Interal_bias+=Bias;//用累加法，求出偏差的积分</span><br><span class="line">Pwm=Position_KP*Bias+Position_KI*Integral_bias+Position_KD*(Bias-Last_Bias);//根据PID计算Pwm输出值</span><br><span class="line">Last_Bias=Bias;//保存上一次偏差</span><br><span class="line">return Pwm;//返回Pwm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在中断服务函数中调用这个函数并将输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PWM = Position_PID(Encoder,Targe)</span><br></pre></td></tr></table></figure></p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>1）稳定性：主要评估指标为最大超调量，最大超调量是指响应曲线的最大峰值与稳态值的差。<br>2）快速性：主要评估指标为上升时间，上升时间是指响应工作状态从原始工作状态出发，第一次到达输出稳定值所需要的时间，是评估系统快速性的一个重要指标。<br>3）准确性：主要评估指标为静差，静差是被控制量与给定值之差，一般用于衡量系统的准确性。<img src="https://i.imgur.com/5tp9brf.png" alt></p><h2 id="调参注意事项"><a href="#调参注意事项" class="headerlink" title="调参注意事项"></a>调参注意事项</h2><p>P：用于提高响应速度。<br>I：用于减小静差。<br>D：用于抑制震荡。<br>一般调参时，先将I值和D值设置为0，然后把P值从0逐渐增大，直到系统震荡。<br>静差一般是在P值较小，且I值为0的时候出现的。所以增大P值可以一定程度上的消除静差，提高响应速度，但会导致系统震荡。<br>加入D值后，震荡得到抑制，但响应速度变慢了。<br>所以一般调节经验可以总结为：先只P控制，增大P直至系统震荡之后加入D控制，消除一点震荡后，再次调节P和I参数。<br>控制难度取决于系统转动惯量和对相应速度的要求。转动惯量越小，对相应速度要求越低，PID参数就越不敏感。</p><h1 id="速度闭环控制"><a href="#速度闭环控制" class="headerlink" title="速度闭环控制"></a>速度闭环控制</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;潜心学习技术，最近发现了一篇比较好的介绍PID的文章。学习并记录一下。&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>破解论文</title>
    <link href="http://linmushen.com/2019/08/12/%E7%A0%B4%E8%A7%A3%E8%AE%BA%E6%96%87/"/>
    <id>http://linmushen.com/2019/08/12/破解论文/</id>
    <published>2019-08-12T01:58:55.000Z</published>
    <updated>2019-09-08T13:29:28.438Z</updated>
    
    <content type="html"><![CDATA[<p>为了准备数学建模竞赛，力求在假期剩余的十几天中，破解七篇优秀论文。<br><a id="more"></a></p><p>使用软件：Excel、作图软件origin、Visio、SPSS、matlab</p><p>论文写作：</p><ol><li>论文在20-25页左右，加上附录也不要超过40页。</li><li>用专业的visio绘图，效果更好。</li></ol><p>题型分布：</p><ol><li>A题需要强大的工科、物理学背景，需要比较好的数学基础、查阅论文能力。一般考察建模同学实力，完全自主建模，然后matlab实现</li><li>B题社会性比较强，偏于统计学方法，相对入手简单，好做。</li></ol><h1 id="第一篇优秀论文"><a href="#第一篇优秀论文" class="headerlink" title="第一篇优秀论文"></a>第一篇优秀论文</h1><h2 id="模型一部分"><a href="#模型一部分" class="headerlink" title="模型一部分"></a>模型一部分</h2><h3 id="模型准备"><a href="#模型准备" class="headerlink" title="模型准备"></a>模型准备</h3><p>建立坐标系，为各个结构件命名。<br>（以锚和锚链的交点为原点，建立坐标系；将各个结构件从上至下命名为P1~P267）</p><h3 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h3><p>1）对有关结构件进行受力分析，得到各个力之间的方程（模型）。<br>2）确定约束条件（水的深度；吃水深与各个结构件的投影之和等于水的深度）。<br>3）最后要将所有的到的方程汇总写在一起。<br><img src="https://i.imgur.com/HAsNEAC.png" alt></p><h3 id="模型修正"><a href="#模型修正" class="headerlink" title="模型修正"></a>模型修正</h3><p>对特殊情况予以考虑，并得到修正方程（修正模型）。<br>（是否有铁链沉底）。</p><h3 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h3><p>共有两个变量吃水深h以及各个角度Ai。<br>1）将多目标非线性方程（在第二步中汇总的方程）转换为单目标非线性方程（利用角度与吃水深之间的递推关系）。<br>2）将连续型的变量h转化为离散型的（通过规定步长（步长就是累加的数））。<br>3）计算每一个解，由于最优解等于最大的h（h&lt;=2），计算出满足h&lt;=2的最大h即为最优解。<br><img src="https://i.imgur.com/dRzGAao.png" alt><br>4）算法精度检验（暂时不懂）。</p><h2 id="Matlab程序"><a href="#Matlab程序" class="headerlink" title="Matlab程序"></a>Matlab程序</h2><p>当存在一个变量在多个地方有意义时，应该使用矩阵<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">mq = 1200;%重物球质量</span><br><span class="line">n = 210;%锚链数量（22.5/锚链直径）</span><br><span class="line">min = inf;%实际水深和计算得到的水的深度的差值</span><br><span class="line">minh = 0;%修正时目前的计算得到的吃水深</span><br><span class="line">minH = 0;%修正时目前得到的水深（由吃水深度+投影得到的，但不到18m，因此需要修正）</span><br><span class="line">minbeta = 0;%修正时目前的铁桶与竖直方向的夹角。</span><br><span class="line">minthital1 = zeros(1,4);%修正时目前的钢管与竖直方向的夹角。</span><br><span class="line">minthital2 = zeros(1,n)+pi/2;%修正时目前的锚链与竖直方向的夹角的修正办法。</span><br><span class="line">minFt2 = zeros(1,n+1);%创建一个一行211列的零矩阵（）</span><br><span class="line"></span><br><span class="line">for h= 0 : 0.0001 : 2%h从0开始，每次运行完结构内容后加0.0001，一直到2。</span><br><span class="line"></span><br><span class="line">Ft = zeros(1,5);%各钢管、浮标之间的拉力</span><br><span class="line">alpha = zeros(1,5);%各钢管、浮标之间的角度</span><br><span class="line">thital1 = zeros(1,4);%各钢管与竖直方向的夹角</span><br><span class="line">beta = 0；%钢桶与竖直方向夹角</span><br><span class="line">Ft2 = zeros(1,n+1); %各锚链之间的力</span><br><span class="line">gama = zeros(1,n+1);%各锚链之间的夹角</span><br><span class="line">thital2 = zeros(1,n);%各锚链与竖直方向的夹角</span><br><span class="line"></span><br><span class="line">%&#123;以下为浮标部分&#125;%</span><br><span class="line"></span><br><span class="line">v = 24;%风速=24</span><br><span class="line">S = 2*(2-h);%浮标没有没入水中部分的横截面积</span><br><span class="line">m = 1000;%浮标质量为1000kg</span><br><span class="line">rou = 1025; %水的密度</span><br><span class="line">g = 9.8；%重力加速度</span><br><span class="line">V = pi*1^2*h;%体积 = (pi*d^2*h)/4;d^2 = 4</span><br><span class="line">Ffeng = 0.625*S*v^2;%由公式：Ffeng = 0.625*横截面积*风速^2</span><br><span class="line">Ffu = rou*g*V;%浮标浮力</span><br><span class="line">G = m*g;%浮标重力</span><br><span class="line"></span><br><span class="line">if Ffu - G &lt; 0</span><br><span class="line">continue;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">alpha(1) = atan(Ffeng/(Ffu-G));%根据建立的模型，解得浮标与第一个钢管之间的角度</span><br><span class="line">Ft(1) = sqrt(Ffeng^2+(Ffu-Gfu)^2);%根据之前建立的模型，解得浮标与第一个钢管之间的拉力</span><br><span class="line"></span><br><span class="line">%&#123;以下为钢管部分&#125;%</span><br><span class="line"></span><br><span class="line">Vg = 1*pi*0.025^2;%钢管的体积</span><br><span class="line">Ggang = 10*g;%钢管的质量</span><br><span class="line">Fgfu = rou*g*Vg;%钢管的浮力</span><br><span class="line">for i=1:4</span><br><span class="line">alpha(i+1) = atan(Ft(i)*sin(alpha(i))/(Ft(i)*cos(alpha(i))+Fgfu-Ggang));%根据之前得到的模型，分别计算出四个钢管的之间的角度</span><br><span class="line">Ft(i+1) = Ft(i)*sin(alpha(i+1));thital1(i) = atan(Ft(i)*sin(alpha(i))*1/(Fgfu-Ggang)*1/2+Ft(i)*cos(alpha(i))));%根据之前建立的模型，分别计算出来四个钢管之间的作用力</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%&#123;以下是钢桶部分&#125;%</span><br><span class="line"></span><br><span class="line">Vt = 1*pi*0.15^2;%钢桶的体积（钢桶直径为30cm）</span><br><span class="line">Vq = mq/7800;%重物球的体积（由于本题中球的半径没有给出，因此，用铁道密度代指球的密度，用球的质量比球的体积，进而得到球的体积）</span><br><span class="line">Gt = 100*g;%钢桶的重量</span><br><span class="line">Gq = mq*g;%重物球的重量</span><br><span class="line">Ftfu = rou*g*Vt;%桶收到的浮力</span><br><span class="line">Fqfu = rpu*g*Vq;%球受到的浮力</span><br><span class="line"></span><br><span class="line">gama(1) = atan(Ft(5)*sin(alpha(5))/(Ftfu+Ft(5)*cos(alpha(5))-Gt-Gq+Fqfu));</span><br><span class="line">%根据之前得到的模型，计算第一个锚链与钢桶的夹角</span><br><span class="line">bata = atan(Ft(5)*sin(alpha(5)*1/(Ftfu-Gt)*1/2+Ft(5)*cos(alpha(5))*1));%根据之前得到的模型，计算出钢桶与竖直夹角</span><br><span class="line"></span><br><span class="line">%&#123;以下是锚链部分&#125;%</span><br><span class="line"></span><br><span class="line">mm = 0.735;%锚链的质量（查阅资料得到）</span><br><span class="line">roum = 6450;%锚链的密度（查阅资料得到）</span><br><span class="line">Vm = mm/roum;%锚链的体积</span><br><span class="line">Fmfu = rou*g*Vm;%锚链收到的浮力</span><br><span class="line">Gm = mm*g;%锚链受到的重力</span><br><span class="line">Lm = 0.105;%一节锚链的长度（22.05/210得到）</span><br><span class="line"></span><br><span class="line">for i=1:n</span><br><span class="line">gama(i+1)=atan(Ft2(i)*sin(gama(i))/(Ft(i)*cos(gama(i))+Fmfu - Gm));%根据之前得到的模型，计算出每个锚链之间的夹角。</span><br><span class="line"></span><br><span class="line">if gama(i+1)&lt;0%如果夹角小于0，则加派。</span><br><span class="line"></span><br><span class="line">gama(i+1) = gama(i+1)+pi</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Ft2(i+1) = Ft2(i)*sin(gama(i))/sin(gama(i+1));%根据模型，得到各个锚链之间的作用力。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thital2(i) = atan(Ft2(i)*sin(gama(i))*Lm/((Fmfu-Gm)*Lm/2+Ft2(i)*cos(gama(i))*Lm));%根据模型，计算得到每个锚链与竖直方向的夹角。</span><br><span class="line"></span><br><span class="line">if thital2(i)&lt;0%如果夹角小于0，则加派</span><br><span class="line"></span><br><span class="line">thital=thital+pi;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">H = h+1*sum(cos(thital1))+1*cos(beta)+Lm*sum(cos(thital2))%构建几何约束条件，其中sum()为求和函数。</span><br><span class="line"></span><br><span class="line">%&#123;当出现有铁链沉底的情况，需要进行修正&#125;%</span><br><span class="line"></span><br><span class="line">if abs(H-18)&lt;min</span><br><span class="line">minh = h;</span><br><span class="line">min = abs(H-18);</span><br><span class="line">minH = H ;</span><br><span class="line">minthita1 = thita1;</span><br><span class="line">minthita2 = thita2;</span><br><span class="line">minbeta = beta;</span><br><span class="line">minFt2 = Ft2;</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h2 id="模型二部分"><a href="#模型二部分" class="headerlink" title="模型二部分"></a>模型二部分</h2><h3 id="模型准备-1"><a href="#模型准备-1" class="headerlink" title="模型准备"></a>模型准备</h3><p>根据问题一的模型，求解当前风速（36m/s）时的各系统参数（钢管、浮标、吃水深度）。<br>然后根据问题一的模型，将钢桶倾斜角和锚链在锚点处的夹角，计算得到重物球重量范围。</p><h3 id="模型建立-1"><a href="#模型建立-1" class="headerlink" title="模型建立"></a>模型建立</h3><p>1）确定决策变量（决策变量等同于因变量，这个因变量有一定范围）—-本题中的重物球重量。<br>2）确定目标变量（目标变量等同于要求解的变量，等同于自变量）—-本题中有三个自变量（钢桶倾斜角、浮标吃水深度、浮标游动区域）。<br>3）确定约束变量（约束条件一般由题目已知条件）—-本题中锚点210与竖直方向夹角小于16度和钢桶倾斜角小于5度。</p><h3 id="模型建立-2"><a href="#模型建立-2" class="headerlink" title="模型建立"></a>模型建立</h3><p><img src="https://i.imgur.com/7Ns9n2x.png" alt></p><h3 id="模型求解-1"><a href="#模型求解-1" class="headerlink" title="模型求解"></a>模型求解</h3><p>求解方法还是循环搜索算法，但重物球有重量上下范围，同样需要设置步长。<br>先将最开始计算得到参数值带入，从重量球最小值开始带入，计算得到U，每次计算重量球重量球加步长，最后当达到最大值时，输出U。</p><h3 id="灵敏性分析"><a href="#灵敏性分析" class="headerlink" title="灵敏性分析"></a>灵敏性分析</h3><p>灵敏性—决策变量对每一个优化目标的影响（画图），最终得到结论，重量球重量对浮标游动、吃水深影响较小；对钢桶倾角影响大。<br><img src="https://i.imgur.com/FaUHj7H.png" alt></p><h2 id="Matlab程序-1"><a href="#Matlab程序-1" class="headerlink" title="Matlab程序"></a>Matlab程序</h2><p>function [y1,…,yN] = myfun(x1,…,xM) 声明名为 myfun 的函数，该函数接受输入 x1,…,xM 并返回输出 y1,…,yN。此声明语句必须是函数的第一个可执行代码行。有效的函数名称以字母字符开头，并且可以包含字母、数字或下划线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">n=210;%锚链数目</span><br><span class="line"></span><br><span class="line">%&#123;创建几个用于存放数据的矩阵&#125;%</span><br><span class="line"></span><br><span class="line">kxmq=[];</span><br><span class="line">kxh=[];</span><br><span class="line">kxr=[];</span><br><span class="line">kxbeta=[];</span><br><span class="line">zfenshu=[];</span><br><span class="line"></span><br><span class="line">%&#123;开始搜索法，求出每一个mq对应的值&#125;%</span><br><span class="line"></span><br><span class="line">for mq=1800:4100</span><br><span class="line">mq%输出mq</span><br><span class="line">min = inf;%最小值，用于存放实际水深（18m）和计算得到的水深的差值。</span><br><span class="line">minh = 0;%得到的最小吃水深度。</span><br><span class="line">minH = 0;%根据最小吃水深度得到的计算水深。</span><br><span class="line">minbeta = 0;%得到的钢桶最小夹角。</span><br><span class="line">minthita1 = zeros(1,4);%浮标、钢管之间的夹角。</span><br><span class="line">minthita2 = zeros(1,n);%锚链、铁桶之间的夹角。</span><br><span class="line">minFt2 = zeros(1,n+1);%锚链、铁桶、锚之间的拉力。</span><br><span class="line"></span><br><span class="line">for h= 0 : 0.0001 : 2       %h从0开始，每次运行完结构内容后加0.0001，一直到2。</span><br><span class="line"></span><br><span class="line">    Ft = zeros(1,5);    %各钢管、浮标之间的拉力</span><br><span class="line">    alpha = zeros(1,5); %各钢管、浮标之间的角度</span><br><span class="line">    thital1 = zeros(1,4);   %各钢管与竖直方向的夹角</span><br><span class="line">    beta = 0；           %钢桶与竖直方向夹角</span><br><span class="line">    Ft2 = zeros(1,n+1); %各锚链之间的力</span><br><span class="line">    gama = zeros(1,n+1);%各锚链之间的夹角</span><br><span class="line">    thital2 = zeros(1,n);   %各锚链与竖直方向的夹角</span><br><span class="line"></span><br><span class="line">    %&#123;以下为浮标部分&#125;%</span><br><span class="line"></span><br><span class="line">    v = 24;     %风速=24</span><br><span class="line">    S = 2*(2-h);%浮标没有没入水中部分的横截面积</span><br><span class="line">    m = 1000;   %浮标质量为1000kg</span><br><span class="line">    rou = 1025; %水的密度</span><br><span class="line">    g = 9.8；    %重力加速度</span><br><span class="line">    V = pi*1^2*h;   %体积 = (pi*d^2*h)/4;d^2 = 4</span><br><span class="line">    Ffeng = 0.625*S*v^2;    %由公式：Ffeng = 0.625*横截面积*风速^2</span><br><span class="line">    Ffu = rou*g*V;  %浮标浮力</span><br><span class="line">    G = m*g;        %浮标重力</span><br><span class="line"></span><br><span class="line">    if Ffu - G &lt; 0</span><br><span class="line">        continue;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    alpha(1) = atan(Ffeng/(Ffu-G));     %根据建立的模型，解得浮标与第一个钢管之间的角度</span><br><span class="line">    Ft(1) = sqrt(Ffeng^2+(Ffu-Gfu)^2);  %根据之前建立的模型，解得浮标与第一个钢管之间的拉力</span><br><span class="line"></span><br><span class="line">    %&#123;以下为钢管部分&#125;%</span><br><span class="line"></span><br><span class="line">    Vg = 1*pi*0.025^2;  %钢管的体积</span><br><span class="line">    Ggang = 10*g;       %钢管的质量</span><br><span class="line">    Fgfu = rou*g*Vg;    %钢管的浮力</span><br><span class="line">    for i=1:4</span><br><span class="line">        alpha(i+1) = atan(Ft(i)*sin(alpha(i))/(Ft(i)*cos(alpha(i))+Fgfu-Ggang));    %根据之前得到的模型，分别计算出四个钢管的之间的角度</span><br><span class="line">        Ft(i+1) = Ft(i)*sin(alpha(i+1));thital1(i) = atan(Ft(i)*sin(alpha(i))*1/(Fgfu-Ggang)*1/2+Ft(i)*cos(alpha(i))));     %根据之前建立的模型，分别计算出来四个钢管之间的作用力</span><br><span class="line">    end </span><br><span class="line"></span><br><span class="line">    %&#123;以下是钢桶部分&#125;%</span><br><span class="line"></span><br><span class="line">    Vt = 1*pi*0.15^2;   %钢桶的体积（钢桶直径为30cm）</span><br><span class="line">    Vq = mq/7800;       %重物球的体积（由于本题中球的半径没有给出，因此，用铁道密度代指球的密度，用球的质量比球的体积，进而得到球的体积）</span><br><span class="line">    Gt = 100*g;         %钢桶的重量</span><br><span class="line">    Gq = mq*g;          %重物球的重量</span><br><span class="line">    Ftfu = rou*g*Vt;    %桶收到的浮力</span><br><span class="line">    Fqfu = rpu*g*Vq;    %球受到的浮力</span><br><span class="line"></span><br><span class="line">    gama(1) = atan(Ft(5)*sin(alpha(5))/(Ftfu+Ft(5)*cos(alpha(5))-Gt-Gq+Fqfu));</span><br><span class="line">    %根据之前得到的模型，计算第一个锚链与钢桶的夹角</span><br><span class="line">    bata = atan(Ft(5)*sin(alpha(5)*1/(Ftfu-Gt)*1/2+Ft(5)*cos(alpha(5))*1)); %根据之前得到的模型，计算出钢桶与竖直夹角</span><br><span class="line"></span><br><span class="line">    %&#123;以下是锚链部分&#125;%</span><br><span class="line"></span><br><span class="line">    mm = 0.735;     %锚链的质量（查阅资料得到）</span><br><span class="line">    roum = 6450;    %锚链的密度（查阅资料得到）</span><br><span class="line">    Vm = mm/roum;   %锚链的体积</span><br><span class="line">    Fmfu = rou*g*Vm;%锚链收到的浮力</span><br><span class="line">    Gm = mm*g;      %锚链受到的重力</span><br><span class="line">    Lm = 0.105;     %一节锚链的长度（22.05/210得到）</span><br><span class="line"></span><br><span class="line">    for i=1:n</span><br><span class="line">        gama(i+1)=atan(Ft2(i)*sin(gama(i))/(Ft(i)*cos(gama(i))+Fmfu - Gm)); %根据之前得到的模型，计算出每个锚链之间的夹角。</span><br><span class="line"></span><br><span class="line">        if gama(i+1)&lt;0      %如果夹角小于0，则加派。</span><br><span class="line"></span><br><span class="line">            gama(i+1) = gama(i+1)+pi</span><br><span class="line"></span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        Ft2(i+1) = Ft2(i)*sin(gama(i))/sin(gama(i+1));  %根据模型，得到各个锚链之间的作用力。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thital2(i) = atan(Ft2(i)*sin(gama(i))*Lm/((Fmfu-Gm)*Lm/2+Ft2(i)*cos(gama(i))*Lm));      %根据模型，计算得到每个锚链与竖直方向的夹角。</span><br><span class="line"></span><br><span class="line">        if thital2(i)&lt;0     %如果夹角小于0，则加派</span><br><span class="line"></span><br><span class="line">            thital=thital+pi;</span><br><span class="line"></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    H = h+1*sum(cos(thital1))+1*cos(beta)+Lm*sum(cos(thital2))  %构建几何约束条件，其中sum()为求和函数。</span><br><span class="line"></span><br><span class="line">    %&#123;当出现有铁链沉底的情况，需要进行修正&#125;%</span><br><span class="line"></span><br><span class="line">    if abs(H-18)&lt;min    </span><br><span class="line">        minh = h;</span><br><span class="line">        min = abs(H-18);</span><br><span class="line">        minH = H ;</span><br><span class="line">        minthita1 = thita1;</span><br><span class="line">        minthita2 = thita2;</span><br><span class="line">        minbeta = beta;</span><br><span class="line">        minFt2 = Ft2;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%&#123;验证是否满足水深约束，不满足则调用修正函数&#125;%</span><br><span class="line"></span><br><span class="line">if minthia2(n)&gt;pi/2%大于90度，则说明沉底</span><br><span class="line"></span><br><span class="line">[r,minh,minbeta,minthita1,minthita2,minH] = tuodir(n,mq);%调用修正函数，得到新值</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">r = Lm*sum(sin(minthia2))+sum(sin(minbeta))+sum(sin(minthia1));</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%&#123;验证是否满足约束条件，不满足直接结束本次循环，进行下一次&#125;%</span><br><span class="line"></span><br><span class="line">if minthia*180/pi&gt;5</span><br><span class="line">continue;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if (90-minthia2(n)*180/pi)&gt;16;</span><br><span class="line">cintinue;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if abs(minH-18)&gt;0.2</span><br><span class="line">continue;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">kxmq = [kxmq,mq];</span><br><span class="line">kxh = [kxh,minh];</span><br><span class="line">kxbeta = [kxbeta,minbeta];</span><br><span class="line">kxr = [kxr,r];</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">[fenshu,i] = max(-zfenshu);%将矩阵中最优（U最大）的拿出来</span><br><span class="line">fenshu%打印出来</span><br><span class="line">kxmq(i)</span><br></pre></td></tr></table></figure></p><h1 id="第二遍优秀论文"><a href="#第二遍优秀论文" class="headerlink" title="第二遍优秀论文"></a>第二遍优秀论文</h1><p>除去摘要和问题重述，第一部分为问题分析。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="问题一分析"><a href="#问题一分析" class="headerlink" title="问题一分析"></a>问题一分析</h3><p>1）阐述问题：要求建立合理的指标，并分析出租车资源的匹配程度。<br>2）简述述解决问题的答案：建立了两个指标—里程利用率、供求比。<br>3）详述解决问题的方法：得到平衡点N(K<em>,n</em>)和实际点M(K,n)；通过归一化处理后，计算实际点与平衡点之间的距离，距离越大供求匹配度越低。</p><h3 id="问题二分析"><a href="#问题二分析" class="headerlink" title="问题二分析"></a>问题二分析</h3><p>1）阐述问题：要求分析各公司补贴办法是否有用。<br>2）简述解决问题的步骤：</p><ol><li>计算各公司对乘客、对司机的补贴金额。</li><li>设计意愿半径、软件使用人数来计算人均车辆占有率（有多少使用软件的人在司机的意愿半径内）。</li><li>通过人均车辆占有率来检测不同补贴效果。<h3 id="问题三分析"><a href="#问题三分析" class="headerlink" title="问题三分析"></a>问题三分析</h3>1）阐述问题：设计补贴方案并论证合理性。<br>2）简述解决办法</li></ol><h2 id="模型一部分-1"><a href="#模型一部分-1" class="headerlink" title="模型一部分"></a>模型一部分</h2><h3 id="模型准备—指标确立"><a href="#模型准备—指标确立" class="headerlink" title="模型准备—指标确立"></a>模型准备—指标确立</h3><p>1）里程利用率<br>公式：里程利用率K = 载客里程/行驶里程 *100%<br>指标意义：<br>K大—对司机：空驶率较低；对乘客—可供打的车不多。<br>K小—对司机：空驶率较高；对乘客—可供打的车较多。<br>因此，K存在一个平衡值。</p><p>2）供求比率<br>公式：供求比率n = 一定时间内某市场可供额的总和/相应的需求额总和 *100%<br>指标意义：<br>n&gt;1：供大于求。<br>n&lt;1：供小于求。<br>n=1：供等于求。<br>因此，n存在一个平衡值。</p><h3 id="模型建立—指标理想值确定"><a href="#模型建立—指标理想值确定" class="headerlink" title="模型建立—指标理想值确定"></a>模型建立—指标理想值确定</h3><p>1）里程利用率理想值<br>出租车总里程L；出租车载客总里程Ls；乘客需求里程Ld。<br>K = L/Ls；当Ls = Ld时，得到K的平衡值K*。</p><p>本题将L细分为：</p><ul><li>出租车保有量—N</li><li>主要时间段平均运营时间—T</li><li>出租车平均行驶速度—v</li><li>出租车出车率—a</li><li>主要时间段占全天运营时间的比例—b<br>L = TvNa/b</li></ul><p>本题将Ld细分为：</p><ul><li>人口总量—n</li><li>人均出行—o</li><li>出租车出行占所有出行方式的比例—p</li><li>每次出行的平均距离—d</li><li>出租车承担的人民出行周转量（旅客人数与其距离的乘积）—Q</li><li>平均每天乘出租车总人数—s<br>Ld = nopd/s</li></ul><p>得到理想值<br>Ld = Ls<br>最终得到 K* = nopdb/TNsva</p><p>2）供求比率理想值<br>需求订单量D，出租车数量S，n = S/D。<br>以每个人（每个订单）为圆心，以司机的意愿半径为半径，画圆。由于不同地方n的值差异较大，因此将大区域划分为n个小区域。<br>小区域分为三种</p><ul><li>供大于求,D1,n1</li><li>供小于求,D2,n2</li><li>供等于求,D3,n3<br>n = (D1/D)<em>n1+(D2/D)</em>n2+D3/(D*n3)—不是打错了，n3&lt;1，所以n3越大表示供求越平衡，所以需要改动。<br>n1&gt;1，所以n1越大表示供求越不平衡。</li></ul><p>得到理想值n = 1。</p><h3 id="模型建立-3"><a href="#模型建立-3" class="headerlink" title="模型建立"></a>模型建立</h3><p>此时得到了平衡点坐标N(K<em>,n</em>)和实际点M(K,n)，但不是关于原点的情况，不易于求解，因此通过<strong>归一化处理</strong>转化为关于原点的数据，点Q。<br>Q = (K-K<em>/K</em>,n<em>-n/n</em>)<br>综合不平衡度—Q到原点的距离r。</p><p><img src="https://i.imgur.com/vYLHcff.png" alt></p><h3 id="模型求解-2"><a href="#模型求解-2" class="headerlink" title="模型求解"></a>模型求解</h3><p>带入理想值需要的数据，求解得到K<em>，n</em>。<br>利用matlab仿真，得到K，n<br>并分别在时间角度、空间角度下，解得r。</p><h1 id="2016B题"><a href="#2016B题" class="headerlink" title="2016B题"></a>2016B题</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>建立评价指标体系</p><ol><li>选取评价指标</li><li>层次分析法求权重</li><li>根据权重判断指标的可行性</li></ol><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><ol><li>TOPSOS模型求得排序指标值(影响力度)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了准备数学建模竞赛，力求在假期剩余的十几天中，破解七篇优秀论文。&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>OPENMV学习笔记</title>
    <link href="http://linmushen.com/2019/07/29/OPENMV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/07/29/OPENMV学习笔记/</id>
    <published>2019-07-29T11:07:59.000Z</published>
    <updated>2019-08-18T15:15:28.590Z</updated>
    
    <content type="html"><![CDATA[<p>本节根据星瞳科技的OPENMV<br><a id="more"></a></p><h1 id="OPENMV图像处理方法"><a href="#OPENMV图像处理方法" class="headerlink" title="OPENMV图像处理方法"></a>OPENMV图像处理方法</h1><h2 id="感光元件"><a href="#感光元件" class="headerlink" title="感光元件"></a>感光元件</h2><p>sensor模块，用于设置感光元件的参数。</p><blockquote><p>初始化：.resert()–初始化感光元件。<br>设置彩色/黑白：.set_pixformat(sensor.RGB565[彩色]/sensor.GARYSCALE[灰度])<br>设置图像大小：.set_framesize([A])</p><blockquote><p>其中A：sensor.QQVGA: 160x120<br>sensor.QQVGA2: 128x160 (用于 lcd 扩展板)<br>sensor.HQVGA: 240x160<br>sensor.QVGA: 320x240<br>sensor.VGA: 640x480 (只用于OpenMV Cam M7 的灰度图处理图像，或者彩图采集图像)<br>sensor.QQCIF: 88x72<br>sensor.QCIF: 176x144<br>sensor.CIF: 352x288</p></blockquote></blockquote><blockquote><p>跳过一些帧：.skip_frames(n=需要跳过的帧数,time=需要跳过的ms数)。<br>获取一张图象：.snapshot()，拍摄一张照片并返回一个image对象。<br>自动增益：.set_auto_gain(True/False)，使用颜色追踪时，需要关闭(False)自动增益。<br>白平衡：.set_auto_whitebat(True/False)，使用颜色追踪时，需要关闭(False)白平衡。<br>设置窗口ROI：.set_windowing(roi)，roi的格式是(x,y)，取中间的x*y区域。ROI为感兴趣区。<br>设置翻转：.set_hmirror(True)—水平方向翻转；.set_vflip(True)—垂直方向翻转。</p></blockquote><h1 id="图像的基本运算"><a href="#图像的基本运算" class="headerlink" title="图像的基本运算"></a>图像的基本运算</h1><h2 id="获取设置像素点-pixel"><a href="#获取设置像素点-pixel" class="headerlink" title="获取设置像素点(pixel)"></a>获取设置像素点(pixel)</h2><ol><li>image.get_pixel(x,y):返回image中(x,y)处的像素值（若为灰度图，返回灰度值；若为彩色图，返回RGB 的元组）。</li><li>image.set_pixel(x,y):设置image中(x,y)处的像素值（若为灰度图，设置灰度值；若为彩色图，设置(R,G,B)的值。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节根据星瞳科技的OPENMV&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>数学建模</title>
    <link href="http://linmushen.com/2019/07/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    <id>http://linmushen.com/2019/07/21/数学建模/</id>
    <published>2019-07-21T13:14:50.000Z</published>
    <updated>2019-08-21T09:08:46.060Z</updated>
    
    <content type="html"><![CDATA[<p>一些有关数学建模的知识及matlab算法<br><a id="more"></a></p><h1 id="线性规划问题"><a href="#线性规划问题" class="headerlink" title="线性规划问题"></a>线性规划问题</h1><h2 id="纯线性规划问题"><a href="#纯线性规划问题" class="headerlink" title="纯线性规划问题"></a>纯线性规划问题</h2><p>（例程：px1.m 和 px2.m)<br>1.线性规划概念：在一组线性约束条件限制下，求一组线性目标最大或最小的<br>题<br>1）目标函数： max z=4x+3y<br>2) 约束条件(s.t.)：{2x+y&lt;=10,x+y&lt;=8,0&lt;y&lt;=7,x&gt;0<br>3）决策变量：x,y<br>4）可行解：满足约束条件的解X=[x,y,z…]称为可行解<br>5）可行域：所有可行解的集合X…称为可行域<br>注：难点在于选择合适的决策变量</p><p>2.线性规划的Matlab的标准形式及软件求解<br>1）将问题转换成Matlab标准形式：1.其中目标函数应为求最小值。2.目标函数中不等式应为小于等于的形式<br>2）然后根据转换得到的形式列出要创建的列向量f（价值向量）,X,b（资源向量）,beq,lb,ub。<br>3）然后创建矩阵A,Aeq。<br>4）通过[X,fval]=linprog(f,A,b)或<br>[X,fval]=linprog(f,A,b,Aeq,beq)或<br>[X,fval]=linprog(f,A,b,Aeq,beq,lb,nb)求解出最优解(X)和最有解对应的值(fval)<br>注：1.f列向量是目标函数的系数，是一个列向量。<br>2.b是各约束条件（小于等于形式的不等式）所对应的常数构成的列向量。<br>3.A是约束条件（小于等于形式的不等式）系数构成的矩阵。<br>4.lb,ub（列向量）:  lb&lt;=X&lt;=ub.   lb,ub的行数与X的行数相同。如： x1,x2,x3&gt;=0  则lb=[0;0;0]<br>5.当存在lb而没有Aeq，beq时，对应缺失的矩阵用[]代替。如：linprog(f,A,b,[],[],lb)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些有关数学建模的知识及matlab算法&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>stm32学习笔记</title>
    <link href="http://linmushen.com/2019/07/18/stm32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/07/18/stm32学习笔记/</id>
    <published>2019-07-18T13:22:17.000Z</published>
    <updated>2019-08-18T16:13:04.307Z</updated>
    
    <content type="html"><![CDATA[<p>有关STM32知识的笔记<br><a id="more"></a></p><h1 id="关于MDK5的几个使用技巧"><a href="#关于MDK5的几个使用技巧" class="headerlink" title="关于MDK5的几个使用技巧"></a>关于MDK5的几个使用技巧</h1><p>1）TAB键的妙用。首先要介绍的就是TAB键的使用，这个键在很多编译器里面都是用来空位的，每按一下移 空几个位。如果你是经常编写程序的对这个键一定再熟悉不过了。但是 MDK 的 TAB 键和一般 编译器的 TAB 键有不同的地方，和 C++的 TAB 键差不多。MDK 的 TAB 键支持块操作。也就 是可以让一片代码整体右移固定的几个位，也可以通过 SHIFT+TAB 键整体左移固定的几个位。</p><p>2）快速查看一个函数或者变量所定义的地方的功能。 也可能想看看某个变量或数组是在哪个地方定义的等。MDK提供了这样的快速定位的功能只要你把光标放到这个函数/变量的上面，然后右键，弹出菜单栏，我们找到Go to Definition Of‘名字’ 这个地方，然后单击左键就可以快速跳到该函数的定义处（注意要先在 Options for Target 的 Output 选项卡里面勾选 Browse Information 选项，再编译，再定位，否则无法定位！）</p><p>3）快速注释与快速消注释功能。在调试代码的时候，你可能会想注释某一片的代码，来看看执行的情况，MDK提供了这样的快速注释/消注释块代码的功能。也是通过右键实现的。这个操作比较简单，就是先选中你要注释的代码区，然后右键，选择Advanced-&gt;Comment Selection 就可以了。</p><p>4）快速打开头文件功能。在将光标放到要打开的引用头文件上，然后右键选择 Open Document“XXX”，就可以快速打开这个文件了（XXX 是你要打开的头文件名字）</p><p>5）查找替换功能。这个和WORD等很多文档操作的替换功能是差不多的， 在MDK5里面查找替换的快捷键是“CTRL+H”，只要你按下该按钮就会调出查找替换功能。这个和WORD等很多文档操作的替换功能是差不多的。</p><p>6）跨文件查找功能，先双击你要找的函数/变量名，然后再点击IDE上面的左数第九个按键，然后再点击find。</p><h1 id="MDk下C语言基础复习"><a href="#MDk下C语言基础复习" class="headerlink" title="MDk下C语言基础复习"></a>MDk下C语言基础复习</h1><h2 id="六种位操作"><a href="#六种位操作" class="headerlink" title="六种位操作"></a>六种位操作</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li>&amp;：按位与，全1为1，有0为0。</li><li>|：按位或，全0为0，有1为1。</li><li>^：按位异或，相同为0，不同为1。</li><li>~：取反，按位取反，1变0，0变1。（由于是对其本身进行变换，所以~为单目运算符。</li><li>&lt;&lt;：左移，用来将一个数的各位全部向左移N位，右边补零（a=a&lt;&lt;N)</li><li><blockquote><blockquote><p>：右移，与左移作用一样只是方向不同。<br>注：复合运算：a&amp;=1—&gt;a=a&amp;1（其他符号同理）</p></blockquote></blockquote><h3 id="位操作的使用"><a href="#位操作的使用" class="headerlink" title="位操作的使用"></a>位操作的使用</h3>1）与操作的清零作用：如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOA-&gt;CRL&amp;=0XFFFFFF0F;//将4-7位清零</span><br></pre></td></tr></table></figure></li></ol><p>2）或运算设置相应值：如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOA-&gt;CRL|=0X00000040;//设置相应位，不改变其他位</span><br></pre></td></tr></table></figure></p><p>3）提高可读性：如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOx-&gt;BSRR=(((uint32_t)0x01)&lt;&lt;pinpos);//将GPIOx-&gt;BSRR寄存器的第PINPOS位设置为1</span><br></pre></td></tr></table></figure></p><p>其中(uint32_t)0x01是将0x01转换为32位。（因为该寄存器32位）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPIOA-&gt;ODR|=1&lt;&lt;5;</span><br><span class="line">= GPIOA-&gt;ODR=GPIOA-&gt;ODR|(00000001&lt;&lt;5);</span><br><span class="line">= GPIOA-&gt;ODR=GPIOA-&gt;ODR|0100000;//将第二位置1，其余位不变</span><br></pre></td></tr></table></figure></p><h2 id="define宏定义"><a href="#define宏定义" class="headerlink" title="define宏定义"></a>define宏定义</h2><p>常见格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define 标识符 字符串</span><br></pre></td></tr></table></figure></p><p>标识符为所定义宏名，字符串可以是常数，表达式，格式串等。<br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SYSCLK_FREQ_72MHZ 72000000</span><br></pre></td></tr></table></figure><p>此时，SYSCLK_FREQ_72MHZ = 72000000</p><h2 id="ifdef条件编译"><a href="#ifdef条件编译" class="headerlink" title="ifdef条件编译"></a>ifdef条件编译</h2><p>当满足某条件时，对一组语句进行编译；不满足某条件时，则编译另一组语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 标识符</span><br><span class="line">程序段 1</span><br><span class="line">#else</span><br><span class="line">程序段2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>作用是：当标识符用#define定义过，则对程序段1 进行编译，否则编译程序段2。（#else部分可以没有）</p><h2 id="extern变量声明"><a href="#extern变量声明" class="headerlink" title="extern变量声明"></a>extern变量声明</h2><p>extern置于变量或函数前时，表示变量在别的文件中。</p><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>为下文注：子优先级又叫做响应优先级。</p><h2 id="中断寄存器"><a href="#中断寄存器" class="headerlink" title="中断寄存器"></a>中断寄存器</h2><ul><li>ISER[8]：中断使能寄存器，ISER[0]的bit0~bit31对应中断0~31，ISER[1]的bit0~bit27对应中断0~27。通过将对应中断的ISER位置1，使该中断使能。</li><li>ICER[8]：中断除能寄存器，与ISER功能相反（对相应位置1，清除相应中断使能）。</li><li>ISPR[8]：中断挂起寄存器，通过将与中断对应的位置1，可以将正在进行的中断挂起。</li><li>ICPR[8]：中断解挂寄存器，通过将与中断对应的位置1，可以将挂起的中断解挂。</li><li>IABR[8]：中断激活标志位寄存器组，与相应中断对应的位如果为1，则表示该中断正在进行。</li><li>IP[240]：中断优先级控制寄存器组，IP[0]~IP[59]分别对应中断0~59。每个IP[]为8bit（共240个），叫做一个寄存器，该寄存器只用了高四位，分别为抢占优先级和子优先级（抢占优先级在前，子优先级在后）。</li></ul><h2 id="中断分组"><a href="#中断分组" class="headerlink" title="中断分组"></a>中断分组</h2><p>STM32中断分为五组（0~4），其中的不同是不同组中抢占优先级和子优先级对应的位不同。<br>如0组：则0位抢占优先级，4位子优先级；<br>1组：1位抢占优先级，3位子优先级。<br>以此类推。<br>高优先级的中断可以打断低优先级的中断，优先级对应的数字越小，优先级越高。</p><h2 id="优先级的概念"><a href="#优先级的概念" class="headerlink" title="优先级的概念"></a>优先级的概念</h2><p>抢占优先级：抢占优先级大的，可以打断抢占优先级小的。<br>响应优先级：同时触发两个中断时，先响应抢占优先级大的。但抢占优先级相同时，响应优先极大的不能打断抢占优先级小的。</p><h2 id="库函数使用"><a href="#库函数使用" class="headerlink" title="库函数使用"></a>库函数使用</h2><h3 id="中断优先级分组函数"><a href="#中断优先级分组函数" class="headerlink" title="中断优先级分组函数"></a>中断优先级分组函数</h3><p>原型：void NVIC_PriorityGroupConfig(u32_tNVIC_PriorityGroup)<br>作用：对中断优先级进行分组。<br>注意：该函数在只可以被调用一次。<br>使用：NVIC_PriorityGroupConfig(NVIC_PriorityGroup_x)<br>x的范围为0-4。x对应为上述对应x组。</p><h3 id="设置优先级函数"><a href="#设置优先级函数" class="headerlink" title="设置优先级函数"></a>设置优先级函数</h3><p>原型：void NVIC_Init(NVIC_InitTypeDef*InitStruct)<br>作用：1.选定需要确定优先级的中断；2.为中断确定响应优先极大和抢占优先级。<br>使用：1.首先定义一个NVIC_InitTypeDef类型的指针；2.用指针设置结构体内的几个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123; </span><br><span class="line">uint8_t NVIC_IRQChannel;//选定中断</span><br><span class="line">    uint8_t NVIC_IRQChannelPreemptionPriority;   //设置抢占优先级</span><br><span class="line">uint8_t NVIC_IRQChannelSubPriority;    //设置响应优先级</span><br><span class="line">FunctionalState NVIC_IRQChannelCmd;   //使能</span><br><span class="line">&#125; NVIC_InitTypeDef;</span><br></pre></td></tr></table></figure></p><p>调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitTypeDef   NVIC_InitStructure;  </span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;//串口 1 中断  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1 ;// 抢占优先级 1</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; // 子优先级位 2  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;   //IRQ 通道使能  </span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure); //根据上面指定的参数初始化 NVIC 寄存器</span><br></pre></td></tr></table></figure></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>在程序最开始的地方，进行中断分组（调用void NVIC_PriorityGroupConfig(u32_tNVIC_PriorityGroup)）。</li><li>设置用到的中断的优先级。</li></ol><h1 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h1><p>STM32F103共有19个外部中断，0~15对应着GPIOx.0~GPIOx.15（x：A~G。A~G等价)；16中断-&gt;PVD输出；17中断-&gt;RTC闹钟事件；18中断-&gt;USB唤醒事件。</p><h2 id="库函数使用-1"><a href="#库函数使用-1" class="headerlink" title="库函数使用"></a>库函数使用</h2><h3 id="GPIO与外部中断的映射关系的函数"><a href="#GPIO与外部中断的映射关系的函数" class="headerlink" title="GPIO与外部中断的映射关系的函数"></a>GPIO与外部中断的映射关系的函数</h3><p>原型：void GPIO_EXTILineConfig(uint8_t GPIO_PortSource,uint8_t GPIO_PinSource2)<br>参数意义：参数1，GPIOx；参数2，中断x（相当于pin）<br>使用：GPIO_EXTILINEConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2)<br>作用：将端口GPIO_PortSource与中断GPIO_PinSource2来连接起来。</p><h3 id="中断初始化函数"><a href="#中断初始化函数" class="headerlink" title="中断初始化函数"></a>中断初始化函数</h3><p>原型：void EXTI_Init(EXTI_InitTypeDef*EXTI_InitStruct)<br>参数意义：设置结构体成员的结构体指针。<br>作用：设置需要设置的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;</span><br><span class="line">uint32_t EXTI_Line;//设置需要初始化的中断</span><br><span class="line">EXTIMode_TypeDef EXTI_Mode;      //设置模式--&gt;中断\事件（Interrupt\Event）</span><br><span class="line">EXTITrigger_TypeDef EXTI_Trigger;    //设置触发边沿--&gt;下降沿\上升沿\上升和下降（Falling\Rising\Rising_Falling)</span><br><span class="line">FunctionalState EXTI_LineCmd;   //使能(ENABLE)或失能(DISABLE)</span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTI_InitTypeDef  EXTI_InitStructure;</span><br><span class="line">   EXTI_InitStructure.EXTI_Line=EXTI_Line4;    </span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;     </span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; </span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;    </span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br></pre></td></tr></table></figure></p><h3 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h3><p>原型：NVIC_Init(&amp;NVIC_InitStructure)<br>参数意义：与上一章相同。（此处需将变量NVIC_InitStructure.NVIC_IRQChannel设置为EXTIx_IRQn;x代表外部中断x）。<br>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel=EXTI2_IRQn;         //使能按键外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级 2，  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;  //子优先级 2 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;   //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure);                          //中断优先级分组初始化</span><br></pre></td></tr></table></figure></p><h3 id="检查状态函数"><a href="#检查状态函数" class="headerlink" title="检查状态函数"></a>检查状态函数</h3><p>原型：FlagStatus ITStatus EXTI_GetITStauts(uint32_t EXTI_Line)<br>参数意义：指定中断（EXTI_LINEx）<br>使用：EXTIStatus = EXTI_GetFlagStatus(EXTI_Linex)<br>作用：返回指定中断的状态（SET/RESET)</p><h3 id="清除中断标志函数"><a href="#清除中断标志函数" class="headerlink" title="清除中断标志函数"></a>清除中断标志函数</h3><p>原型：void EXTI_ClearITPendingBit(u32_t EXTI_Line)<br>参数意义：指定中断<br>使用EXTI_ClearITPendingBit（EXTI_Linex）<br>作用：一般在中断函数结束之前，清除中断标志位</p><h3 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h3><p>注意：所有中断函数都有固定名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPORT  EXTI0_IRQHandler           </span><br><span class="line">EXPORT  EXTI1_IRQHandler        </span><br><span class="line">EXPORT  EXTI2_IRQHandler          </span><br><span class="line">EXPORT  EXTI3_IRQHandler         </span><br><span class="line">EXPORT  EXTI4_IRQHandler//0~4中断分别对应这几个函数           </span><br><span class="line">EXPORT  EXTI9_5_IRQHandler  //5~9中断公用这一个函数</span><br><span class="line">EXPORT  EXTI15_10_IRQHandler//10~15中断公用这一个函数</span><br></pre></td></tr></table></figure></p><h3 id="一般中断函数的形式"><a href="#一般中断函数的形式" class="headerlink" title="一般中断函数的形式"></a>一般中断函数的形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void EXTIx_IRQHandler()</span><br><span class="line">&#123;</span><br><span class="line">if(EXTI_GetITStatus(EXTI_Linex)!=RESET)//判断终端是否发生</span><br><span class="line">&#123;</span><br><span class="line">函数主体···</span><br><span class="line">EXTI_ClearITPendingBit（EXTI_Line3）；//清除中断标志位</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外部中断使用步骤"><a href="#外部中断使用步骤" class="headerlink" title="外部中断使用步骤"></a>外部中断使用步骤</h2><p>1）初始化GPIO口为输入（要开启的中断所对应的GPIO口）<br>2）开启AFIO时钟</p><blockquote><p>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //②使能 AFIO 时钟 </p></blockquote><p>3）设置IO口与中断的映射关系</p><blockquote><p>如：GPIO_EXTILINEConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2);</p></blockquote><p>4）初始化中断</p><blockquote><p>EXTI_Init(&amp;EXTI_InitStructure);</p></blockquote><p>5）配置中断分组，并且使能该中断<br>6）编写中断服务函数</p><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>自动重装载周期A；cpu时钟频率B；预分频系数C；需要的时间：T<br>(B/C)/A = T<br>//如：时钟频率72M，预分频系数为7200，则：1s对应10000个时钟周期；所需时间T=（1/10000）*A</p><h2 id="定时器种类"><a href="#定时器种类" class="headerlink" title="定时器种类"></a>定时器种类</h2><p>STM32F103共有11个定时器[2个高级定时器（TIM1,TIM8)，4个普通定时器(TIM2-TIM5)，2个基本定时器(TIM6,TIM7)，2个看门狗定时器，1个系统滴答定时器]</p><h2 id="3种计数模式"><a href="#3种计数模式" class="headerlink" title="3种计数模式"></a>3种计数模式</h2><ol><li>向上计数模式：从0开始，计到预设值，产生溢出事件，返回重新计数。</li><li>向下计数模式：从预设值开始，计到0，产生溢出事件，返回重新计时。</li><li>中央对齐模式：从0开始向上计数，计到预设值产生溢出事件，然后从预设值开始向下计数，计数到1后产生溢出事件，然后再从0开始向上计数。</li></ol><h2 id="3种定时器主要功能"><a href="#3种定时器主要功能" class="headerlink" title="3种定时器主要功能"></a>3种定时器主要功能</h2><ol><li>基本定时器主要功能(TIM6,TIM7)：只有基本定定时功能。</li><li>普通定时器主要功能(TIM2-TIM5)：除基本的定时器功能外，可以测量输入信号的脉冲长度或者产生输出波形（PWM和输出比较）。</li><li>高级定时器主要功能(TIM1,TIM8)：除上述功能，还可以控制交直流电机的所有功能。</li></ol><h1 id="普通定时器"><a href="#普通定时器" class="headerlink" title="普通定时器"></a>普通定时器</h1><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ol><li>16位自动装载计数器（向上，向下，向上\向下）</li><li>16位可编程预分频器（分频系数：1~65535）</li><li>4个独立通道（TIMx_CH1~4)，通道作用：A.输入捕获；B。输出比较；C.PWM生成；D.单脉冲模式输出。</li><li>可实现一个定时器控制另一个定时器的同步电路</li></ol><h2 id="触发中断"><a href="#触发中断" class="headerlink" title="触发中断"></a>触发中断</h2><ol><li>中断触发条件：A.计数器溢出或计数器初始化。</li><li>触发事件：计数器启动、停止、初始化或者有内部/外部触发计数。</li><li>输入捕获</li><li>输出比较</li><li>增量编码器或霍尔传感器电路</li><li>触发输入作为外部时钟或者按周期的电路管理</li></ol><h2 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h2><ul><li>TIM_CR1：控制寄存器，功能有：使能定时器，设置计数方向（向上\向下），设置计数对齐方式，设置时钟分频因子。</li><li>TIMx_DIER：中断使能寄存器，功能有：顾名思义，用来允许更新事件所产生的中断。</li><li>TIMx_PSC：预分频寄存器，功能有：对时钟进行分频，作为定时器的时钟。</li><li>TIMx_CNT：定时器的计数器，功能有：存储当前定时器的计数值。</li><li>TIMx_ARR：自动重装载寄存器，功能有：用来设置自动重装载的值（值为空时，寄存器不起作用）。</li><li>TIMx_SR：状态寄存器，功能是：标记当前与定时器相关的中断是否发生。</li></ul><h2 id="库函数使用-2"><a href="#库函数使用-2" class="headerlink" title="库函数使用"></a>库函数使用</h2><h3 id="定时器时钟使能"><a href="#定时器时钟使能" class="headerlink" title="定时器时钟使能"></a>定时器时钟使能</h3><p>原型：void RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIMx,ENABLE)<br>参数意义：指明是使能哪一个定时器。x范围是2~5（普通定时器）<br>使用：RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIMx,ENABLE)；使能TIMx定时器。</p><h3 id="初始化定时器"><a href="#初始化定时器" class="headerlink" title="初始化定时器"></a>初始化定时器</h3><p>原型：void TIM_TimeBaseInit(TIM_TypeDef<em>TIMx,TIM_TimeBaseInitTypeDef</em>TIM_TimeBaseInitStruct)<br>参数意义：第一个参数：指定定时器；第二个参数：用于设置初始值的结构体指针。<br>结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;   </span><br><span class="line">uint16_t TIM_Prescaler;//设置分频系数</span><br><span class="line">uint16_t TIM_CounterMode;//设置计数方式(向上计数模式TIM_CounterMode_Up；向下计数模式：TIM_CounterMode_Down)</span><br><span class="line">uint16_t TIM_Period;//设置自动重载计数周期值</span><br><span class="line">uint16_t TIM_ClockDivision; //设置时钟分频因子</span><br><span class="line">uint8_t TIM_RepetitionCounter;//高级定时器使用</span><br><span class="line">&#125; TIM_TimeBaseInitTypeDef;</span><br></pre></td></tr></table></figure></p><p>使用：以TIM3为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">TIM_TimeBaseStructure.TIM_Period = 5000;//自动装载周期：5000</span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =7199;//分频系数：7199</span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision =TIM_CKD_DIV1;//设置时间分频因子</span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数方式：向上计数模式</span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure);</span><br></pre></td></tr></table></figure></p><h3 id="设置允许更新"><a href="#设置允许更新" class="headerlink" title="设置允许更新"></a>设置允许更新</h3><p>原型：void TIM_ITConfig(TIMx,TIM_IT,ENABLE/DISABLE)<br>参数意义：第一个参数：指明定时器；第二个参数指明中断类型（由什么触发中断；如，更新中断，输入捕获中断）；第三个参数：使能/失能<br>使用：以TIM3为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_ITConfig(TIM3,TIM_IT_Updata,ENABLE);//设置为更新中断</span><br></pre></td></tr></table></figure></p><h3 id="使能TIMx函数"><a href="#使能TIMx函数" class="headerlink" title="使能TIMx函数"></a>使能TIMx函数</h3><p>原型：void TIM_Cmd(TIM_TypeDef*TIMx,ENABLE/DISABLE)<br>参数意义：第一个参数：指明定时器；第二个参数：使能/失能。<br>使用：TIM_Cmd(TIMx,enable/disable)</p><h3 id="检查状态函数-1"><a href="#检查状态函数-1" class="headerlink" title="检查状态函数"></a>检查状态函数</h3><p>原型：ITStatus TIM_GetITStatus(TIM_TypeDef*TIMx,中断类型)<br>参数意义：第一个参数：指明定时器；第二个参数：指明中断类型。<br>作用：返回状态值SET/RESET.<br>使用：TIM_GetStatus(TIMx,TIM_IT_Upadata)        //更新类型中断</p><h3 id="清除标志位函数"><a href="#清除标志位函数" class="headerlink" title="清除标志位函数"></a>清除标志位函数</h3><p>原型：void TIM_ClearITPendingBit(TIM_TypeDef*TIMx,中断类型)<br>参数意义：与上相同<br>使用：TIM_ClearITPendingBit(TIM3,TIM_IT_Upadata)</p><h2 id="定时器使用步骤"><a href="#定时器使用步骤" class="headerlink" title="定时器使用步骤"></a>定时器使用步骤</h2><p>1）时钟使能<br>2）初始化定时器（计数模式，自动装载周期，分频因子等）<br>3）允许中断并配置中断类型<br>4）中断优先级设置（调用NVIC库实现）<br>5）使能TIMx<br>6）编写中断服务函数<br>注意：中断服务函数：void TIMx_IRQHandler()<br>设置中断初始化的中断频道：TIMx_IRQn</p><h1 id="PWM输出"><a href="#PWM输出" class="headerlink" title="PWM输出"></a>PWM输出</h1><p>实现：使用TIMx的一个通道，把该通道重映射到GPIO端口，产生PWM。<br>默认：CH1–PA6;CH2–PA7;CH3–PB0;CH4–PB1。<br>部分重映射：CH1–PB4;CH2–PB5;CH3–PB0;CH4–PB1。<br>重映射：CH1–PC6;CH2–PC7;CH3–PC8;CH4–PC9。</p><h2 id="STM32与PWM"><a href="#STM32与PWM" class="headerlink" title="STM32与PWM"></a>STM32与PWM</h2><p>基本定时器（TIM6;TIM7)无法产生PWM。<br>不同定时器（TIM2~TIM5）可以产生四路PWM输出。<br>高级定时器（TIM1;TIM8）可以产生七路PWM输出。</p><h2 id="相关寄存器-1"><a href="#相关寄存器-1" class="headerlink" title="相关寄存器"></a>相关寄存器</h2><p>TIMx_CCMR1/2：捕获/比较模式寄存器，TIMx_CCMR1控制CH1,CH2;TIMx_CCMR2控制CH3，CH4。主要使用其模式设置功能。<br>TIMx_CCER:捕获/比较使能寄存器，顾名思义：使能PWM波。<br>TIMx_CCR1~4：捕获/比较寄存器，输出模式下，该寄存器的值与CNT寄存器的值比较，根据结果产生相应动作。<br>实际使用中，通过修改这个寄存器的值来控制PWM的输出脉宽。（ccr1~4分别对应CH1~4）</p><h2 id="硬件相关"><a href="#硬件相关" class="headerlink" title="硬件相关"></a>硬件相关</h2><p>由于STM32每个通道连接固定的GPIO口，因此，需要用到GPIO的重映射。<br>STM32的重映射是由复用重映射和IP配置寄存器（AFIO_MAPR）控制的。该寄存器的各位描述见STM32开发指南（库函数版）P217。<br>重映射实现</p><h2 id="库函数使用-3"><a href="#库函数使用-3" class="headerlink" title="库函数使用"></a>库函数使用</h2><p>关于极性的问题：<br>如果是PWM1模式 :<br>如果设置TIM_OCPolarity_High     TIMx_CNT&lt;TIMx_CCR输出为高电平   TIMx_CNT&gt;TIMx_CCR输出为低电平<br>如果设置TIM_OCPolarity_Low      TIMx_CNT&lt;TIMx_CCR输出就为低电平  TIMx_CNT&gt;&lt;TIMx_CCR输出就为高电平<br>如果是PWM2模式 :<br>如果设置TIM_OCPolarity_High     TIMx_CNT&gt;TIMx_CCR输出为低电平   TIMx_CNT&lt;TIMx_CCR输出为高电平<br>如果设置TIM_OCPolarity_Low      TIMx_CNT&gt;TIMx_CCR输出就为高电平  TIMx_CNT&lt;TIMx_CCR输出就为低电平</p><h3 id="开启TIM3时钟以及【复用功能时钟（AFIO）】（如果需要的话）"><a href="#开启TIM3时钟以及【复用功能时钟（AFIO）】（如果需要的话）" class="headerlink" title="开启TIM3时钟以及【复用功能时钟（AFIO）】（如果需要的话）"></a>开启TIM3时钟以及【复用功能时钟（AFIO）】（如果需要的话）</h3><p>RCC_APB1PeriphClockCmd(RCC_PAB1Periph_TIM3,ENABLE)    //TIM3时钟使能<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIP,ENABLE)    //使能复用时钟</p><h3 id="设置重映射（如果有需要的话）"><a href="#设置重映射（如果有需要的话）" class="headerlink" title="设置重映射（如果有需要的话）"></a>设置重映射（如果有需要的话）</h3><p>原型：void GPIO_PinRemapConfig(u32_t GPIO_Remap,FunctionalState NewState)<br>参数：第一个参数：GPIO_FullRenmap_TIMx;(重映射)；GPIO_PartialRenmap_TIMx;(部分重映射)；第二个参数：使能/失能<br>使用：GPIO_PinRemapConfig(GPIO_PinRemap_TIM3,ENABLE);TIM3重映射使能</p><h3 id="初始化定时器-1"><a href="#初始化定时器-1" class="headerlink" title="初始化定时器"></a>初始化定时器</h3><p>设置重装值，预分频系数，时钟分割（此时该参数设为0），计数模式</p><h3 id="设置TIMx-CHx的PWM模式"><a href="#设置TIMx-CHx的PWM模式" class="headerlink" title="设置TIMx_CHx的PWM模式"></a>设置TIMx_CHx的PWM模式</h3><p>原型：void TIM_OCxInit(TIM_TypeDef<em>TIMx,TIM_OCInitTypeDef</em>TIM_OCInitStruct)【x代表选中的通道】<br>参数：第一个参数：TIM2、TIM3….<br>第二个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;</span><br><span class="line">uint16_t TIM_OCMode;//设置模式是PWM还是输出比较；PWM下的格式：TIM_OC_PWM2</span><br><span class="line">uint16_t TIM_OutputState;//使能PWM到端口；PWM下的格式：TIM_OutputState_ENABLE</span><br><span class="line">uint16_t TIM_OutputNState;//高级定时器使用。</span><br><span class="line">uint16_t TIM_Pulse;//高级定时器使用</span><br><span class="line">uint16_t TIM_OCPolarity;//设置极性高/低</span><br><span class="line">uint16_t TIM_OCNPolarity;//高级定时器使用</span><br><span class="line">uint16_t TIM_OCIdleState;//高级定时器使用</span><br><span class="line">uint16_t TIM_OCNIdleState;//高级定时器使用</span><br><span class="line">&#125; TIM_OCInitTypeDef;</span><br></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line"></span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; //选择 PWM 模式 2 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性高</span><br><span class="line"></span><br><span class="line">TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure);  //初始化 TIM3 OC2</span><br></pre></td></tr></table></figure></p><h3 id="控制占空比"><a href="#控制占空比" class="headerlink" title="控制占空比"></a>控制占空比</h3><p>原型：void TIM_SetComparex(TIM_TypeDef*TIMx,Compare2)【x代表通道】<br>参数：第一个参数：TIMx；第二个参数：自动重装载寄存器的新值。<br>使用：TIM_SetCompare1(TIM2,重装载值)</p><h2 id="产生PWM值的步骤"><a href="#产生PWM值的步骤" class="headerlink" title="产生PWM值的步骤"></a>产生PWM值的步骤</h2><p>1）使能TIM3的时钟。看需要使能复用功能时钟。<br>2）看需要进行GPIO口映射。<br>3）初始化TIM3。<br>4）设置该定时器的该通道的PWM模式。<br>5）使能TIM3。<br>6）控制占空比。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有关STM32知识的笔记&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>树莓派笔记</title>
    <link href="http://linmushen.com/2019/06/14/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/06/14/树莓派笔记/</id>
    <published>2019-06-14T14:45:13.000Z</published>
    <updated>2019-08-18T16:13:04.311Z</updated>
    
    <content type="html"><![CDATA[<p>记录有关树莓派学习的笔记<br><a id="more"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>核心元件：树莓派 L298N</li><li>需要实现：视觉识别（Opencv） 底层电机驱动</li><li>核心功能：识别赛道图像，沿着白线走</li><li>核心原理：利用二值化（大律法二值化）将白色单独显示出来</li><li>未知问题：<blockquote><p>腐蚀膨胀问题？—一种对图像的处理方法，腐蚀是去掉，膨胀是把图放大<br>缩放倍率？</p></blockquote></li></ol><h1 id="GPIO控制使用"><a href="#GPIO控制使用" class="headerlink" title="GPIO控制使用"></a>GPIO控制使用</h1><ol><li>GPIO–通入输入/输出端口</li><li>wiringPi/RPI.GPIO是需要导入的库函数</li></ol><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ol><li>import RPI.GPIO as GPIO</li><li>设置编码规范： gpio.setmode(gpio.BOARD)<blockquote><p>编码规范：</p><blockquote><p>1）BOARD： 从左到右，从上到下：左边基数，右边偶数：1-40<br>2）BCM：编号侧重 CPU 寄存器，根据 BCM2835 的 GPIO 寄存器编号<br>3）wpi： 编号侧重实现逻辑，把扩展 GPIO 端口从 0 开始编号，这种编号方便编程。</p></blockquote></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录有关树莓派学习的笔记&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>Matlab相关</title>
    <link href="http://linmushen.com/2019/04/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1M/"/>
    <id>http://linmushen.com/2019/04/17/数学建模M/</id>
    <published>2019-04-17T13:59:01.000Z</published>
    <updated>2019-08-18T15:15:28.594Z</updated>
    
    <content type="html"><![CDATA[<p>有一些关于Matlab的知识<br><a id="more"></a></p><h1 id="Matlab知识笔记"><a href="#Matlab知识笔记" class="headerlink" title="Matlab知识笔记"></a>Matlab知识笔记</h1><ul><li>Matlab主要用来处理整个矩阵和数组。</li><li>所有matlab变量都是多维的。</li><li>matlab将数字存储为浮点值</li></ul><h2 id="命令与函数"><a href="#命令与函数" class="headerlink" title="命令与函数"></a>命令与函数</h2><h3 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h3><ol><li>help inv ：显示函数（inv）的帮助信息</li><li>[]  ：创建矩阵</li><li>[]; : 创建一个矩阵但不在命令行中显示出来</li><li>,   ：矩阵行元素分隔符号</li><li>;   ：矩阵列元素分隔符号</li><li>%   : 注释行</li><li>clear ：清理工作空间中的各种变量</li><li>== ：关系运算符：等于</li><li>~= ：关系运算符：不等于</li><li>| ：逻辑或运算</li></ol><h3 id="定义类型"><a href="#定义类型" class="headerlink" title="定义类型"></a>定义类型</h3><ol><li>format short : 定义输出格式为短，显示小数点后四位</li><li>format long : 定义输出格式为长，显示小数点后14（15）位</li><li>format rat：以有理数形式输出<blockquote><p>format只影响输出格式，不影响存储方式 </p></blockquote></li><li>syms x ：定义x为符号变量</li></ol><h3 id="控制流程语句"><a href="#控制流程语句" class="headerlink" title="控制流程语句"></a>控制流程语句</h3><ol><li>if..else if..end : 条件语句，作用与c中类似</li><li>for..end : for循环语句，与c类似</li></ol><h3 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h3><ol><li>n=input(‘…’):输入函数，其中’’之间的是提示字符</li><li>disp(‘….’):显示单引号中字符串</li></ol><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="创建矩阵的函数"><a href="#创建矩阵的函数" class="headerlink" title="创建矩阵的函数"></a>创建矩阵的函数</h3><ol><li>eye(n):创建n阶单位矩阵</li><li>zeros（m,n）：创建m*n阶零矩阵</li><li>zeros(n) :创建n阶方阵</li><li>ones（m,n):创建m*n阶元素全为1的矩阵</li><li>rand（m,n):创建m*n阶元素为从0到1均匀分布的随机数矩阵</li><li>randn(m,n):创建m*n阶均值为0，方差为1的标准正态分布随机矩阵</li><li>round（A）：对矩阵A所有元素进行四舍五入运算</li></ol><h3 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h3><ol><li>inv(A):求矩阵A的逆</li><li>A^-1:用幂运算求矩阵A的逆</li><li>a’ ：a的转置</li><li>inv(a):a的逆矩阵</li><li><ul><li>：执行标准矩阵乘法，计算行与列之间的内积</li></ul></li><li>\ :MATLAB特有的矩阵左除A/B=inv（A)*B</li><li>/ ：matlab特有的矩阵右除B/A=B*inv（A)</li><li>. ：在运算符号前加 . 含义为对应矩阵群运算（元素级运算，即每一个元素之间的运算）<blockquote><ul><li>只有乘除幂运算有相应的群运算。</li><li>C=A.*B：矩阵元素群运算（A,B矩阵中对应元素相乘）</li><li>D=A.^2:矩阵元素群运算（A中每一个元素平方）【a^2，相当于a乘a；a.^2，相当于a的每一个元素平方】</li></ul></blockquote></li><li>：  ：冒号运算符，start:step:end   不写step的值时，默认为1<blockquote><p>可以创建等距向量 ：B=0：50：100    </p><blockquote><p>B = 0，50，100</p></blockquote></blockquote></li></ol><h2 id="行列式与方程组求解"><a href="#行列式与方程组求解" class="headerlink" title="行列式与方程组求解"></a>行列式与方程组求解</h2><ol><li>U=rref(A)  :对矩阵A进行初等行变换，得到的U是A的最简行列式<blockquote><p>rref([A,b]) :就是将A，b的混合矩阵化为行最简</p></blockquote></li><li>[m,n]=size(A)：计算A的行，列，并返回一个二维向量</li><li>det(A):计算矩阵A的行列式</li><li>rank(A):计算矩阵A的秩</li><li>A(i,j) :引出A的第i行第j列的元素</li><li>B（：，i)=b : 把向量b的值赋给矩阵B的第i列（矩阵B的列向量和向量b同型）</li><li>B（：，1：5）：取矩阵的第一列至第五列</li><li>[A,eye(5)] : 创建一个5*10矩阵，前五列为A，后五列为单位矩阵i</li><li>T(1,:)=[] : 把一个空行赋给T的第1行（删除T的第一行）</li><li>factor(D):对符号变量多项式D进行因式分解</li><li>solve(D) :求符号变量多项式方程D=0的解</li></ol><h2 id="工作区变量"><a href="#工作区变量" class="headerlink" title="工作区变量"></a>工作区变量</h2><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>在Matlab中创建或从其他程序导入的变量</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><ol><li>使用： whos</li><li>直接在工作区窗格查看</li></ol><h3 id="保存和还原"><a href="#保存和还原" class="headerlink" title="保存和还原"></a>保存和还原</h3><ol><li>使用save name.mat保存到压缩文件中</li><li>使用load name.mat将mat中数据还原到工作区</li></ol><h2 id="文本和字符"><a href="#文本和字符" class="headerlink" title="文本和字符"></a>文本和字符</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>文本：与其他语言类似：字符串用单引号括起来，如果字符串中有单引号则单引号用两个单引号’’表示。</li><li>把文本赋值给变量，变量类型为数组（数据类型为char）</li><li>同样可以用[]来进行串联 a=’lin’ b=’mu’  A = [a,’-‘,b]<blockquote><p>A: ‘lin-mu’</p></blockquote><h3 id="数值与字符的转化"><a href="#数值与字符的转化" class="headerlink" title="数值与字符的转化"></a>数值与字符的转化</h3></li><li>由于数值不能与字符变量进行串联，所以需要将数值转化成char型</li></ul><ol><li>num2str(c)  c=3.33  <blockquote><p>转化为 ‘3.33’</p></blockquote></li><li>int2str(c) <blockquote><p>转化为 ‘3’</p></blockquote></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>clc: 清空命令窗口<br>clear: 清空工作区间的变量<br>mean()：获得一个序列的均值<br>std（）：获得一个序列的方差<br>magic():魔方矩阵<br>hilb():产生一个希尔伯特矩阵</p><blockquote><p>矩阵各个值为H（ij）= i+j-1分之一</p></blockquote><h1 id="入门学习"><a href="#入门学习" class="headerlink" title="入门学习"></a>入门学习</h1><h2 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h2><h3 id="常规方法"><a href="#常规方法" class="headerlink" title="常规方法"></a>常规方法</h3><p> 使用 ， 或 空格 来分隔各元素</p><blockquote><p>a = [1,2,3,4]<br>b = [1 2 3 4]<br> 使用 ； 来分隔各行</p></blockquote><h3 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h3><p> 使用ones zeros 或 rand函数（具体函数参照上文）</p><blockquote><p>z = zeros(5,1)   %创建一个五行一列的矩阵</p></blockquote><h2 id="矩阵与数组的运算"><a href="#矩阵与数组的运算" class="headerlink" title="矩阵与数组的运算"></a>矩阵与数组的运算</h2><h3 id="使用运算符"><a href="#使用运算符" class="headerlink" title="使用运算符"></a>使用运算符</h3><p> 使用单一的算术运算符或函数来处理矩阵中的所有值</p><blockquote><p>a+10     %对矩阵a中每一个元素加十<br>sin(a)   %对矩阵中每一个元素进行正弦处理<br>a’       %对矩阵a转置</p></blockquote><h3 id="串联"><a href="#串联" class="headerlink" title="串联"></a>串联</h3><ol><li>串联是连接数组以便形成更大数组的过程。（数组的创建也是如此，通过将各个元素串联而构成的）</li><li>[]即为串联符<br>规则：<blockquote><p>A = [a,b]   %将数组a与数组b水平串联，ab必须具有相同的行数<br>B = [a;b]   %将数组a与数组b竖直串联，ab必须具有相同的列数</p></blockquote></li></ol><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>复数包含 实部和虚部<br>虚数单位是-1的平方根</p><h2 id="数组的索引"><a href="#数组的索引" class="headerlink" title="数组的索引"></a>数组的索引</h2><p>前提 ：</p><blockquote><p>A = [1,2,3,4;4,3,2,1;5,6,7,8]</p></blockquote><h3 id="引用单个元素"><a href="#引用单个元素" class="headerlink" title="引用单个元素"></a>引用单个元素</h3><ol><li>A(4,2)     %引用数组中的特定元素，指定行标和列标</li><li>A(8)       %用单一下标，逐个遍历每一<strong>**</strong>列<strong>**</strong>  ；也叫线性索引<h3 id="添加单个元素"><a href="#添加单个元素" class="headerlink" title="添加单个元素"></a>添加单个元素</h3></li></ol><ul><li>A(4,3)=10  %在索引不存在的情况下，在右边进行赋值，数组大小就会扩大，其余部分填0<h3 id="引用多个元素"><a href="#引用多个元素" class="headerlink" title="引用多个元素"></a>引用多个元素</h3>用冒号 </li></ul><ol><li>A(1:3,2)   %指定一个start:end的范围（以原来形式列出前三行第二列的元素）</li><li>A(:,2)     %单独只有冒号，则列出该列所有元素 </li></ol><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>无接收值无参数： clc    （只写函数名）</p><h3 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h3><ol><li>使用单个参数：name(a)</li><li>使用多个参数：name(a,b)<h3 id="接收函数值"><a href="#接收函数值" class="headerlink" title="接收函数值"></a>接收函数值</h3></li><li>接收单个值：A = name(a)</li><li>接收多个值：[A,B] = name(a)</li></ol><h2 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h2><h3 id="线图"><a href="#线图" class="headerlink" title="线图"></a>线图</h3><ol><li>使用plot(x,y)函数绘制<blockquote><p>plot(x,y,‘r–’):第三个参数为线条设定（r–为红色虚线）<strong>注意：要用单引号引起来</strong></p><blockquote><p>线条设定包括线条颜色（r,g…)、样式、标记的字符(+、o、*标记各个数据点）</p></blockquote></blockquote></li><li>在plot(x,y)后使用 xlabel(‘x’)  ylabel(‘y’)  title(‘my title’)标记各个轴和写标题</li><li>默认情况下，matlab每调用一次绘图函数、重置坐标区及其他元素时，都会清除图窗<blockquote><p>若要保留，则使用 hold on。终止用hold off。</p></blockquote></li></ol><h3 id="三维图形"><a href="#三维图形" class="headerlink" title="三维图形"></a>三维图形</h3><ol><li>首先使用meshgrid创建一组点（x,y)<blockquote><p>meshgrid(X,Y): X，Y：为两个行向量，步数默认为1，范围给定（X=1：2   Y=1:3)<br>然后将X复制Y的元素个数次（3次），将Y复制X的元素个数次（2次）</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些关于Matlab的知识&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>知识积累</title>
    <link href="http://linmushen.com/2019/04/12/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    <id>http://linmushen.com/2019/04/12/知识积累/</id>
    <published>2019-04-12T14:30:38.000Z</published>
    <updated>2019-08-18T16:13:04.312Z</updated>
    
    <content type="html"><![CDATA[<p>一个用于日常知识积累的笔记<br><a id="more"></a></p><h1 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h1><p>此电脑—&gt;属性—-&gt;高级系统设置—-&gt;path—-&gt;新建</p><h1 id="python-安装第三方库"><a href="#python-安装第三方库" class="headerlink" title="python 安装第三方库"></a>python 安装第三方库</h1><p>cmd (powershell)</p><blockquote><p>转到pip下的cache目录<br>pip install 库名</p></blockquote><h1 id="关于pip时的编码错误问题"><a href="#关于pip时的编码错误问题" class="headerlink" title="关于pip时的编码错误问题"></a>关于pip时的编码错误问题</h1><p>最近安装pip-19.1 执行python setup.py install一直提示编码错误<br>弄了一晚上找到解决办法<br>在python27–&gt;Lib–&gt;site-packages下添加一个名为sitecustomize.py的文件<br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&apos;gb2312&apos;)</span><br></pre></td></tr></table></figure></p><p>用utf-8不好使，可能是环境不一样的问题</p><h1 id="创建python虚拟环境"><a href="#创建python虚拟环境" class="headerlink" title="创建python虚拟环境"></a>创建python虚拟环境</h1><p>记得要cd到Python27下的Scripts下运行virtualven name（创建一个名为name的虚拟环境）<br>运行Scripts\active进入虚拟环境<br>运行deactive退出虚拟环境</p><h1 id="高深的爬虫基础"><a href="#高深的爬虫基础" class="headerlink" title="高深的爬虫基础"></a>高深的爬虫基础</h1><p>这个笔记拿来记录一点零星的爬虫知识，以备后用<br><!--more--></p><h2 id="urllib模块"><a href="#urllib模块" class="headerlink" title="urllib模块"></a>urllib模块</h2><h3 id="打开网址-url-的操作"><a href="#打开网址-url-的操作" class="headerlink" title="打开网址(url)的操作"></a>打开网址(url)的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import urllib</span><br><span class="line">f = urllib.urlopen(&apos;网址&apos;)</span><br></pre></td></tr></table></figure><h3 id="返回一个文件对象，有与对文件对象类似的操作"><a href="#返回一个文件对象，有与对文件对象类似的操作" class="headerlink" title="返回一个文件对象，有与对文件对象类似的操作"></a>返回一个文件对象，有与对文件对象类似的操作</h3><ul><li>read() , readline() ,readlines() , fileno() , close() ：这些方法的使用方式与文件对象完全一样</li><li>info()：返回一个httplib.HTTPMessage对象，表示远程服务器返回的头信息</li><li>getcode()：返回Http状态码。如果是http请求，200请求成功完成;404网址未找到</li><li>geturl()：返回请求的url</li></ul><p>后续过于高深，暂时不写<br>关于代码，可以查看py42.py</p><h1 id="HTML文本的笔记"><a href="#HTML文本的笔记" class="headerlink" title="HTML文本的笔记"></a>HTML文本的笔记</h1><p>最近学习了一点有关HTML的知识<br>在此记录一下<br><!--more--></p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>好像是用&lt;&gt;来表示的<br>标签就好像是python里的函数<br>如 </p><ol><li><figure class="highlight plain"><figcaption><span>``` 表示主题内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2. ```&lt;html&gt; &lt;/html&gt;``` 表示HTML文件</span><br><span class="line">3. ```&lt;form&gt; &lt;/form&gt;``` 表示表单文件</span><br><span class="line">4. ```&lt;input&gt;``` 标签</span><br><span class="line"></span><br><span class="line">## input标签</span><br></pre></td></tr></table></figure></li></ol><p><input type="(1)"><br><code>`</code><br>其中（1）内容为以下</p><blockquote><p>button<br>定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）。<br>如果在HTML表单中使用button元素，不同的浏览器会提交不同的值。Internet Explorer将提交<code>&lt;button&gt;与&lt;button/&gt;</code>之间的文本<br>checkbox<br>定义复选框。<br>file<br>定义输入字段和 “浏览”按钮，供文件上传。<br>hidden<br>定义隐藏的输入字段。<br>image<br>定义图像形式的提交按钮。<br>password<br>定义密码字段。该字段中的字符被掩码。<br>radio<br>定义单选按钮。<br>reset<br>定义重置按钮。重置按钮会清除表单中的所有数据。<br>submit<br>定义提交按钮。提交按钮会把表单数据发送到服务器。<br>text<br>定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。</p></blockquote><h2 id="设置字体风格"><a href="#设置字体风格" class="headerlink" title="设置字体风格"></a>设置字体风格</h2><p>font 简写属性。作用是把所有针对字体的属性设置在一个声明中。<br>font-family 设置字体系列。<br>font-size 设置字体的尺寸。<br>font-size-adjust 当首选字体不可用时，对替换字体进行智能缩放。（CSS2.1 已删除该属性。）<br>font-stretch 对字体进行水平拉伸。（CSS2.1 已删除该属性。）<br>font-style 设置字体风格。<br>font-variant 以小型大写字体或者正常字体显示文本。<br>font-weight 设置字体的粗细。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个用于日常知识积累的笔记&lt;br&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://linmushen.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>实战1</title>
    <link href="http://linmushen.com/2019/04/11/%E5%AE%9E%E6%88%981/"/>
    <id>http://linmushen.com/2019/04/11/实战1/</id>
    <published>2019-04-11T14:40:15.000Z</published>
    <updated>2019-08-18T16:13:04.309Z</updated>
    
    <content type="html"><![CDATA[<p>第一个实战小项目<br><a id="more"></a></p><h2 id="解决问题的起点：步骤"><a href="#解决问题的起点：步骤" class="headerlink" title="解决问题的起点：步骤"></a>解决问题的起点：步骤</h2><ol><li>根据要解决的问题画出流程图</li><li>摘录第一条的关键概念并研究</li><li>创建一个类和对象的层次结构图</li><li>用代码实现各个类，并测试</li><li>重复上述步骤</li></ol><p>**有抽象概念入手，逐渐细化</p><h2 id="各种名字"><a href="#各种名字" class="headerlink" title="各种名字"></a>各种名字</h2><p>根据思路写出一个名词列表作为变量名<br>根据思路写出一个动词列表作为函数名</p><h2 id="对各种操作进行研究"><a href="#对各种操作进行研究" class="headerlink" title="对各种操作进行研究"></a>对各种操作进行研究</h2><p>如：玩家引爆炸弹的工作<br>怎么把游戏状态存储金数据库<br>应该通过学习类似游戏的工作原理来研究</p><h2 id="创建层次图和对象关系图"><a href="#创建层次图和对象关系图" class="headerlink" title="创建层次图和对象关系图"></a>创建层次图和对象关系图</h2><p>类的结构图：</p><ul><li>和其他东西有哪些类似</li><li>那个东西是另一个东西的换个说法而已</li></ul><h2 id="字典真是好用"><a href="#字典真是好用" class="headerlink" title="字典真是好用"></a>字典真是好用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scenes = &#123;</span><br><span class="line">&apos;Death&apos;:Death(),</span><br><span class="line">&apos;Escapepod&apos;:Escapepod(),</span><br><span class="line">&apos;TheBridge&apos;:TheBridge(),</span><br><span class="line">&apos;LaserWeaponArmony&apos;:LaserWeaponArmony(),</span><br><span class="line">&apos;central_corridor&apos;:CentralCorridor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过返回值来简单的引用类</p><ul><li>父类中的函数，若与子类的重名，而且没有被调用，则会被覆盖<h2 id="类中变量的使用"><a href="#类中变量的使用" class="headerlink" title="类中变量的使用"></a>类中变量的使用</h2>类中的被多个类中函数调用的变量要加上self表明位置，否则出现全局变量错误。（而参数不用）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class English(object):   #游戏引擎，用来根据场景名生产变量并切换场景</span><br><span class="line">def __init__(self,scene_map):</span><br><span class="line">self.dizhi = scene_map</span><br><span class="line">def play(self):</span><br><span class="line">current_scene = self.dizhi.opening_scene()</span><br><span class="line">while True:</span><br><span class="line">print &quot;\n--------&quot;</span><br><span class="line"></span><br><span class="line">self.next_scene_name = current_scene.enter()</span><br><span class="line"></span><br><span class="line">current_scene = self.dizhi.next_scene(self.next_scene_name)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class CentralCorridor(Scene):</span><br><span class="line">def enter(self):</span><br><span class="line"></span><br><span class="line">xiao = raw_input(&apos;&gt;&apos;)</span><br><span class="line">if xiao == &apos;1&apos;:</span><br><span class="line">print u&quot;(卫兵倒下，你成功进入下个房间。)&quot;</span><br><span class="line">return &apos;LaserWeaponArmony&apos;</span><br><span class="line">else:</span><br><span class="line">print u&quot;你是个没有幽默感的蠢货，哥顿人怒火中烧，把你打成了马蜂窝。&quot;</span><br><span class="line">return&apos;Death&apos;</span><br></pre></td></tr></table></figure><p>而变量xiao则不用。</p><h2 id="init"><a href="#init" class="headerlink" title="init()"></a><strong>init</strong>()</h2><p>直接实例化类，相当于直接调用其中的init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Map(object):</span><br><span class="line">def __init__(self,start_scene):</span><br><span class="line">self.dizhi = start_scene</span><br><span class="line">def next_scene(self,scene_name):</span><br><span class="line">return Map.scenes.get(scene_name)   #对获取的类进行实例化</span><br><span class="line">def opening_scene(self):</span><br><span class="line">return self.next_scene(self.dizhi)</span><br><span class="line"></span><br><span class="line">a_map = Map(&apos;central_corridor&apos;)</span><br></pre></td></tr></table></figure><p>a_map = Map(‘str’)<br>等价于<br>a_map = Map.<strong>init</strong>(‘str’)<br>就相当于<br>a_map.dizhi = str</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一个实战小项目&lt;br&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://linmushen.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>有关面向对象编程</title>
    <link href="http://linmushen.com/2019/04/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://linmushen.com/2019/04/08/面向对象/</id>
    <published>2019-04-08T14:39:44.000Z</published>
    <updated>2019-08-18T16:13:04.308Z</updated>
    
    <content type="html"><![CDATA[<p>把所有有关面向对象编程的对象汇集到了一起<br><a id="more"></a></p><h1 id="习题四十"><a href="#习题四十" class="headerlink" title="习题四十"></a>习题四十</h1><p>主要是有关面向对象编程的介绍<br><strong>python中的类就好像是创造对象的模板一样</strong></p><h2 id="模块的概念："><a href="#模块的概念：" class="headerlink" title="模块的概念："></a>模块的概念：</h2><ol><li>模块是包含函数和变量的python文件</li><li>可以导入模块</li><li>可以用.操作调用模块中的函数和变量<br><strong> 与字典的类比：</strong></li></ol><ul><li>对于字典—键来获取值（[键]）</li><li>对于模块—键相当于函数或变量，用函数或变量获取操作（.函数)<br><strong> 模块就好像是用来储存代码的字典，通过.操作进行访问。</strong><h2 id="通过模块类比-类"><a href="#通过模块类比-类" class="headerlink" title="通过模块类比 类"></a>通过模块类比 类</h2><strong> 好像一个迷你模块 </strong><br>类与模块的不同，可以使用一个类重复创建多个类，而类与类之间互不干涉。（而模块不行，导入一次之后，只有一份内容）<br><strong> 对象与模块的导入类比 </strong><br>实例化—创建—得到一个将之前创建的self空对象赋值给这个变量。<br>实现方法：</li></ul><ol><li>调用一个类<blockquote><p>object = class()<br>对象好像就是模块被导入后产生的东西一样。</p></blockquote></li></ol><h1 id="习题四十一"><a href="#习题四十一" class="headerlink" title="习题四十一"></a>习题四十一</h1><h2 id="有关面向对象编程的概念"><a href="#有关面向对象编程的概念" class="headerlink" title="有关面向对象编程的概念"></a>有关面向对象编程的概念</h2><ul><li>类：告诉python要创建新类型的东西</li><li>对象：最基本的东西，或某个东西的实例</li><li>实例：python创建时得到的东西</li><li>self：在类的函数中，用来指代被访问的对象或实例中的变量</li><li>继承：一个类可以继承另一个类的特性</li><li>组合：一个类可以将另一类作为它的部件</li><li>属性：源自组合，通常是一个变量</li><li>是什么（is-a)：用来描述继承关系</li><li>有什么（has-a):用来描述组合关系，或者某个东西有某个特性。<h2 id="描述代码的句子"><a href="#描述代码的句子" class="headerlink" title="描述代码的句子"></a>描述代码的句子</h2></li><li>class X(Y):创建一个叫X的类，他是Y的一种</li><li>class X(object):def <strong>init</strong>(self,J):类中有init函数来接收self和J参数</li><li>class X(object):def M(self,J):类中有M函数来接收self和J参数</li><li>foo = X():将foo设为X的一个实例</li><li>foo.M(J):从实例foo中找到函数M并使用self和J参数调用他</li><li>foo.K=Q:从实例中获得K属性并设为Q。</li></ul><h1 id="习题四十二"><a href="#习题四十二" class="headerlink" title="习题四十二"></a>习题四十二</h1><!--more--><h2 id="区别对象与类的技巧："><a href="#区别对象与类的技巧：" class="headerlink" title="区别对象与类的技巧："></a>区别对象与类的技巧：</h2><p>is-a：是什么，用于两个类之间的关系<br>has-a:有什么，两者无共同点，仅是互为参照</p><h2 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h2><p><strong>object 类是所有类的父类。换言之，其它的任何一个类，都直接或间接地继承了 object 类（的属性和方法）。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class namefu(object):  # object几乎没有意义，于函数中的不同</span><br><span class="line">def __init__(self,name): </span><br><span class="line">self.bianliang=name</span><br><span class="line">#只是创建了一个名为bianliang的变量，并把参数name赋给他。（self.作用是指明其在类中）</span><br><span class="line"></span><br><span class="line">class nmaezi(namefu):</span><br><span class="line">def __init__(self,name,name2):</span><br><span class="line">#在完成基类中的任务后，创建新变量名bianliang2并将参数2的值赋值给新变量</span><br><span class="line">self.bianliang2=name2</span><br><span class="line">def zihanshu(self,j):</span><br><span class="line">#类中的函数参数第一个必须是self</span><br><span class="line">print j</span><br><span class="line"></span><br><span class="line">shili = namezi(&quot;vauleforname&quot;,&quot;vauleforname2&quot;)</span><br><span class="line">    #将子类实例化，并赋值</span><br><span class="line">    #相当于导入这个类</span><br><span class="line">shili.zihanshu(&quot;shuchu&quot;)</span><br><span class="line">    #相当于调用这个类里的子函数并为子函数赋值</span><br></pre></td></tr></table></figure></p><h2 id="子类中的函数与父类中的函数的区别"><a href="#子类中的函数与父类中的函数的区别" class="headerlink" title="子类中的函数与父类中的函数的区别"></a>子类中的函数与父类中的函数的区别</h2><ol><li>子类中函数只可用于该实例化子类的变量调用</li><li>父类中的函数可以被每一个实例化的子类调用<br>super.(子类,self).父类中的函数（）：</li></ol><ul><li>用来解决多重调用问题。（继承父类的顺序表）<h2 id="问题记录："><a href="#问题记录：" class="headerlink" title="问题记录："></a>问题记录：</h2></li><li>怎么使用列表和字典创建一些新的一对多的有多个关系？</li></ul><h1 id="习题四十四"><a href="#习题四十四" class="headerlink" title="习题四十四"></a>习题四十四</h1><p><strong>继承与合成的简单介绍</strong><br><!--more--></p><h2 id="作者的警告"><a href="#作者的警告" class="headerlink" title="作者的警告"></a>作者的警告</h2><p>大部分使用合成的场合都可以用合成取代，而多重继承则要不惜一切代价</p><h2 id="继承（据说是邪恶女巫）"><a href="#继承（据说是邪恶女巫）" class="headerlink" title="继承（据说是邪恶女巫）"></a>继承（据说是邪恶女巫）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>继承：用来知名一个类中大部分或全部分都是从一个父类中获得的</p><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>class Foo(bar) 创建一个叫Foo的类，并让他继承Bar。（Foo的实例所具有的功能都工作在Foo的实例上）</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>可以将Foo与Bar的通用功能都放在Bar里，并在Bar中添加一些特殊性质</p><h3 id="三种交互方式"><a href="#三种交互方式" class="headerlink" title="三种交互方式"></a>三种交互方式</h3><ol><li>子类动作完全等同于父类动作（隐式继承）</li><li>子类动作完全覆盖父类动作（？）</li><li>子类动作部分替换父类动作。</li></ol><h2 id="隐式继承"><a href="#隐式继承" class="headerlink" title="隐式继承"></a>隐式继承</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>在父类里定义了一个函数但没有在子类中定义，会发生隐式继承。</p><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Parent(object):</span><br><span class="line">def implicit(self):</span><br><span class="line">print &quot;Parent implicit()&quot;</span><br><span class="line"></span><br><span class="line">class Child(Parent):</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">dad = Parent()</span><br><span class="line">son = Child()</span><br><span class="line">dad.implicit()</span><br><span class="line">son.implicit()</span><br></pre></td></tr></table></figure><p>其中子类没有任何细节上的修改，所以他继承了父类所有的行为</p><h2 id="显式覆盖"><a href="#显式覆盖" class="headerlink" title="显式覆盖"></a>显式覆盖</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>需要让子类里的函数有一个不同的行为，需要覆盖父类的函数（只要在子类中定义一个相同名称的函数就可以）</p><h3 id="例如-1"><a href="#例如-1" class="headerlink" title="例如"></a>例如</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Parent(object):</span><br><span class="line">def override(self):</span><br><span class="line">print &quot;Parent override()&quot;</span><br><span class="line">class Child(Parents):</span><br><span class="line">def override(self):</span><br><span class="line">print&quot;Child override()&quot;</span><br><span class="line">dad = Parent()</span><br><span class="line">son = Child()</span><br><span class="line"></span><br><span class="line">dad.override()</span><br><span class="line">son.override()</span><br></pre></td></tr></table></figure><p>在子类中重新定义的函数在此取代父类中的函数</p><h2 id="在进行前后进行后替换"><a href="#在进行前后进行后替换" class="headerlink" title="在进行前后进行后替换"></a>在进行前后进行后替换</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>目的是在父类中定义的内容运行之前或之后在修改行为</p><h3 id="例如-2"><a href="#例如-2" class="headerlink" title="例如"></a>例如</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Parent(object):</span><br><span class="line">def override(self):</span><br><span class="line">print &quot;Parent override()\n&quot;</span><br><span class="line">class Child(Parent):</span><br><span class="line">def override(self):</span><br><span class="line">print&quot;Child override() before Parent&quot;</span><br><span class="line">super(Child,self).override()</span><br><span class="line">print&quot;Child override() after Parent&quot;</span><br><span class="line">dad = Parent()</span><br><span class="line">son = Child()</span><br><span class="line"></span><br><span class="line">dad.override()</span><br><span class="line">son.override()</span><br></pre></td></tr></table></figure><p>用super获取并访问parent类。<br>（super（）就是运行父类中的函数）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前提：父类中有一个dad（）函数</p><ol><li>在子类中只写dad（）而不写内容（pass），叫隐式继承，执行父类函数中的内容，</li><li>在子类中写dad（）其中又有内容（与父类中的不一样），只执行子类的内容，叫显示继承（覆盖）。</li><li>调用super（）函数，执行子类到super（）函数位置执行父类，然后继续执行子类（相当于将父类导入）。</li><li>值得注意的是，只要是继承，在子类中没有重名的函数，默认被先执行，而且发生隐式继承<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3>定义的子类继承了多个类<h3 id="例如-3"><a href="#例如-3" class="headerlink" title="例如"></a>例如</h3>class superfoo(dad,mom)<br>superfoo类同时继承了dad和mom类 <h3 id="发生情况"><a href="#发生情况" class="headerlink" title="发生情况"></a>发生情况</h3>如果出现隐式动作，则要使用固定顺序回到类的层次逐个检查类。<br>而这个固定顺序就是“方法解析顺序”（MRO)（C3算法）<br>运用super()这样把继承关系弄糟，python会找到正确的函数。<h3 id="常用情况"><a href="#常用情况" class="headerlink" title="常用情况"></a>常用情况</h3>常用情况是在基类的<strong>init</strong>()函数中使用<br>对子类做一些事情，然后再对父类进行初始化<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3>super（子类，self）.<strong>init</strong>()</li></ol><p>##合成</p><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>通过调用模块里的函数来实现继承</p><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Other(object):</span><br><span class="line">def override(self):</span><br><span class="line">print&quot;Other override()&quot;</span><br><span class="line"></span><br><span class="line">def implicit(self):</span><br><span class="line">print&quot;Other implicit()&quot;</span><br><span class="line"></span><br><span class="line">def altered(self):</span><br><span class="line">print&quot;Other altered()&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Child(object):</span><br><span class="line">def __init__(self):</span><br><span class="line">self.other = Other()</span><br><span class="line">#用Child里的变量实例化other类</span><br><span class="line">def implicit(self):</span><br><span class="line">print&quot;Child override()&quot;</span><br><span class="line"></span><br><span class="line">def override(self):</span><br><span class="line">print &quot;Child override()&quot;</span><br><span class="line">def altered(self):</span><br><span class="line">print&quot;Child Before other altered()&quot;</span><br><span class="line">self.other.altered()</span><br><span class="line">#通过实例化other类来调用other中的函数</span><br><span class="line">print&quot;Child after altered()&quot;</span><br><span class="line"></span><br><span class="line">son = Child()</span><br><span class="line">son.implicit()</span><br><span class="line">son.override()</span><br><span class="line">son.altered()</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>合成就是在类2中对一个类1进行实例化并且调用类1的函数的操作</p><h2 id="对继承与合成的总结"><a href="#对继承与合成的总结" class="headerlink" title="对继承与合成的总结"></a>对继承与合成的总结</h2><blockquote><p>继承与合成说到底只是解决代码复用的问题</p><blockquote><p>继承可以隐含基类中的功能<br>而合成则是用别的类和其中的函数达到相同的目的</p></blockquote></blockquote><h3 id="作者的建议"><a href="#作者的建议" class="headerlink" title="作者的建议"></a>作者的建议</h3><ol><li>不惜一切代价避免多重继承</li><li>如果一些代码会在不同位置和场合应用到，就应用合成把他们做成模块（类）</li><li>如果代码之间有清楚的联系，可以通过共性联系起来的时候使用继承</li></ol><p><strong> python的思想：</strong><br><strong> “一切都是对象！” </strong><br><!--more--><br>面向对象：python从设计之初就是一门面向对象的语言<br>面向对象编程就是对类与对象的使用<br>过程：将实际问题抽象化成’类’，然后对基类进行继承（构造函数），将类实例化成实例，通过调用实例中的函数进行使用。</p><blockquote><p>类：对函数进行归类，以防止命名冲突。</p><blockquote><p>不能实例化的类叫静态类，其本质相当于一个归纳函数的集合。</p></blockquote><blockquote><p>能够实例化的类，通过构造函数变化出行为不大一样的实例的类，一般直接称做类。</p></blockquote><p>定义子类，也叫做继承。</p><blockquote><p>对父类中的函数进行添加或覆盖。</p><blockquote><p>不同子类用不同内容覆盖一个相同函数，产生不同结果，叫多态性<br>调用子类叫实例化类。</p></blockquote></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Human(object):     #定义基类（类）</span><br><span class="line">    def __init__(self, name=&apos;泥人&apos;):</span><br><span class="line">        self.name = name </span><br><span class="line">self.hands = 2 </span><br><span class="line">self.legs = 2 </span><br><span class="line">def introduce_self(self):  </span><br><span class="line"> print(&apos;我是%s&apos; % self.name)</span><br><span class="line">class Female(Human):    #定义子类（继承基类）</span><br><span class="line">def __init__(self, name):  #对基类中的函数进行微调。</span><br><span class="line">super().__init__(name) </span><br><span class="line">self.hair = random.randint(3, 5) </span><br><span class="line">self.power = random.randint(1, 3) </span><br><span class="line">self.married = False </span><br><span class="line">def work():         #给基类添加函数</span><br><span class="line">print(&apos;%s采摘了一些果子&apos; % self.name) </span><br><span class="line">class Male(Human):      #定义第二个子类</span><br><span class="line">def __init__(self, name): </span><br><span class="line">super().__init__(name) </span><br><span class="line">self.hair = random.randint(0, 2)</span><br><span class="line">self.power = random.randint(2, 5) </span><br><span class="line">self.married = False </span><br><span class="line">def work():         #在不同子类中的同名函数，调用时候可以出现多态性。</span><br><span class="line">    print(&apos;%s出去打猎了一天&apos; % self.name) </span><br><span class="line">def marry(self, other): </span><br><span class="line">if self.married is True or other.married is True: </span><br><span class="line">raise ValueError(&apos;法律不支持多次结婚&apos;) </span><br><span class="line">if instance(other, Female): </span><br><span class="line">self.married = True </span><br><span class="line">other.married = True </span><br><span class="line">else:</span><br><span class="line">raise TypeError(&apos;法律不支持同性结婚&apos;)</span><br><span class="line">a = Male(&apos;name&apos;)#调用子类（实例化）</span><br><span class="line">a.introduce_self()                          #调用基类中的函数</span><br><span class="line">a.work()                                    #调用子类中的函数</span><br></pre></td></tr></table></figure><p>以上是目前为止对面向对象编程的初步理解。</p><h1 id="4-9补"><a href="#4-9补" class="headerlink" title="4.9补"></a><strong>4.9补</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyStuff(object):    </span><br><span class="line">def __init__(self):         #对创建的空对象进行初始化。(值得注意的是，init处左右的下划线都是两个)</span><br><span class="line">self.tangerine = &quot;And now a thousand years between&quot;  </span><br><span class="line">def apple(self):     </span><br><span class="line">print&quot;I AM CLASSY APPLES!&quot;</span><br><span class="line">thing = MyStuff()   </span><br><span class="line">thing.apple()</span><br><span class="line">print thing.tangerine</span><br></pre></td></tr></table></figure><blockquote><p>将类进行实例化(相当于调用函数），其中，self相当于一个空对象（其中包含了类中所有函数）<br>  如果有——init函数，则在创建空对象的同时，对空对象进行了初始化操作。<br>  这一步操作后，self空对象被赋给thing变量。<br>  值得注意的是，类stuff并没有直接被使用，而是被用来创建一个与这个类有相同属性的副本<br>  thing 相当于导入了的模块，用.操作调用其中的函数</p></blockquote><h1 id="4-10补"><a href="#4-10补" class="headerlink" title="4.10补"></a>4.10补</h1><p>类与对象没有真正的不同，只是不同时间下的名字不同<br>类是一个用来描述具有同类属性的实例的概括性词汇。（不是一个具体的东西）<br>对象属于某个类，某个类又可能属于某个类。</p><blockquote><p>来自习题四十二的例子<br>鱼—-类—-具有’有鳍，会游水’的属性<br>泥鳅–属于鱼，又不同于鱼—-也是一个类—-具有鱼的属性又具有泥鳅特有的属性’不仅有鳍会游水，还会钻洞’<br>小李被厨子炖了—其中一条泥鳅—–是一个实例化的泥鳅（泥鳅的实例）—是一个对象—-小李有上述属性还有特有的被顿了的属性，<strong> 并且被使用（被大厨）</strong></p><blockquote><p>对象（小李）属于某个类（泥鳅）属于另一个类（鱼）</p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把所有有关面向对象编程的对象汇集到了一起&lt;br&gt;
    
    </summary>
    
      <category term="python学习" scheme="http://linmushen.com/categories/python-study/"/>
    
    
  </entry>
  
  <entry>
    <title>语法内容</title>
    <link href="http://linmushen.com/2019/04/03/%E8%AF%AD%E6%B3%95%E5%86%85%E5%AE%B9/"/>
    <id>http://linmushen.com/2019/04/03/语法内容/</id>
    <published>2019-04-03T15:36:32.000Z</published>
    <updated>2019-08-18T15:15:28.598Z</updated>
    
    <content type="html"><![CDATA[<p>为了更方便的记笔记，我搭建了这个博客<br> <a id="more"></a></p><h1 id="习题三十七：复习各种符号"><a href="#习题三十七：复习各种符号" class="headerlink" title="习题三十七：复习各种符号"></a>习题三十七：复习各种符号</h1><ul><li>总注</li></ul><ol><li>True为任意非0或非空的值。0或空为False。</li><li>Traceback，回溯，一种错误信息</li><li>python用异常对象表示异常情况。异常对象未被捕捉或处理，则会用回溯的方式结束程序</li><li>python中对象包含三个基本元素：id（身份标识），type（数据类型），value（值）</li></ol><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h2><ul><li>and </li><li>not</li><li>or</li><li>from </li><li>import</li><li>del</li><li>while</li><li>as</li><li>global</li><li>with</li><li>if/elif/else</li><li>assert</li><li>pass</li><li>yield</li><li>break</li><li>expect</li><li>finally</li><li>print</li><li>class</li><li>exec</li><li>in</li><li>raise</li><li>continue</li><li>is</li><li>return</li><li>def</li><li>for</li><li>lambda</li><li>try</li></ul><hr><h2 id="逻辑关键词-and-or-not"><a href="#逻辑关键词-and-or-not" class="headerlink" title="逻辑关键词(and,or,not)"></a>逻辑关键词(and,or,not)</h2><h3 id="优先级："><a href="#优先级：" class="headerlink" title="优先级："></a>优先级：</h3><blockquote><p>优先级从大到小为：</p><blockquote><p>not&gt;and&gt;or</p></blockquote></blockquote><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值:"></a>返回值:</h3><blockquote><h4 id="and：（x为真返回y，x为假返回x）"><a href="#and：（x为真返回y，x为假返回x）" class="headerlink" title="and：（x为真返回y，x为假返回x）"></a>and：（x为真返回y，x为假返回x）</h4><blockquote><p>and的返回值是决定表达式结果的值。</p><blockquote><p>如x and y：若x为真，则y决定了表达式的结果，返回值为y（与表达式真假无关，只要x为真，就返回y）。若x为假，则返回值为x。</p></blockquote></blockquote></blockquote><blockquote><h4 id="or-not："><a href="#or-not：" class="headerlink" title="or/not："></a>or/not：</h4><blockquote><p>x or y有一个结果真，返回的结果就是真。</p><blockquote><p>print(x or y):x为真输出x，x为假输出y。</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>not 布尔表达式 ：返回与表达式结果相反的值。</p><blockquote><p>print(not 表达式）：只输出False/Ture </p></blockquote></blockquote></blockquote><p>##print语句</p><blockquote><p>print会自动在末尾加\n，如果不需要，直接在最末加‘，’。（如果有字符串，在引号外）</p><p>输出变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line">print num</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print 1</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;lin mu shen &quot;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出字符串加变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=&apos;lin&apos;</span><br><span class="line">print&quot;str=&quot;,str</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>格式化输出数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line">print&apos;num= %d&quot; %num</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>格式化输出字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str=&apos;lin&apos;</span><br><span class="line">print &apos;str= %s&apos; %str    #输出lin</span><br><span class="line">print &apos;str=.1%s&apos; %str   #输出l</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>格式化输出原样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str=&apos;lin&apos;</span><br><span class="line">num=1</span><br><span class="line">print &apos;str=%r,num=%r&apos; %(str,num)   # str=&apos;lin&apos;,num=1</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="模块的引入（import-from…import）"><a href="#模块的引入（import-from…import）" class="headerlink" title="模块的引入（import/from…import）"></a>模块的引入（import/from…import）</h2><h3 id="import语句的使用"><a href="#import语句的使用" class="headerlink" title="import语句的使用"></a>import语句的使用</h3><blockquote><p>导入模块：</p><blockquote><p>import 模块<br>这个声明将整个模块导入</p></blockquote></blockquote><blockquote><p>调用模块中的函数：</p><blockquote><p>模块名.函数名</p></blockquote></blockquote><blockquote><p>无论执行多少次import，模块只会被导入一次。</p></blockquote><h3 id="from…import语句的使用"><a href="#from…import语句的使用" class="headerlink" title="from…import语句的使用"></a>from…import语句的使用</h3><blockquote><p>导入模块中的指定部分：</p><blockquote><p>from 模块名 import 函数名<br>这个声明将模块中的特定函数导入</p></blockquote></blockquote><blockquote><p>调用函数:</p><blockquote><p>函数名()</p></blockquote></blockquote><h3 id="from…import-的使用"><a href="#from…import-的使用" class="headerlink" title="from…import * 的使用"></a>from…import * 的使用</h3><blockquote><p>导入模块中所有内容:</p><blockquote><p>from 模块名 import *</p></blockquote></blockquote><blockquote><p>调用模块中的任意函数：</p><blockquote><p>函数名（）</p></blockquote></blockquote><h3 id="improt…as…"><a href="#improt…as…" class="headerlink" title="improt…as…"></a>improt…as…</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import game_functions as gf</span><br></pre></td></tr></table></figure><p>为导入的模块起一个代号</p><h2 id="del语句"><a href="#del语句" class="headerlink" title="del语句"></a>del语句</h2><ul><li><p>del语句作用在变量上，而不是数据对象上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line">b=a</span><br><span class="line">del a</span><br><span class="line">print b</span><br><span class="line">del a,b     #也可以使用del一次删除多个变量的引用</span><br></pre></td></tr></table></figure></li><li><p>输出结果为1。</p></li><li>del只解除了a对1的引用，并没有删除数据a。</li></ul><h2 id="定义函数（def）"><a href="#定义函数（def）" class="headerlink" title="定义函数（def）"></a>定义函数（def）</h2><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def name(形式参数):</span><br><span class="line">   执行语句</span><br><span class="line">name(实际参数）</span><br></pre></td></tr></table></figure></p><p>值得一提，形式参数是一个局部变量，而实际参数是一个全局变量，调用函数的过程中，实际参数被赋值给形式参数。</p><h2 id="定义一个匿名函数（lambda表达式）"><a href="#定义一个匿名函数（lambda表达式）" class="headerlink" title="定义一个匿名函数（lambda表达式）"></a>定义一个匿名函数（lambda表达式）</h2><p>起到一个函数速写的作用</p><blockquote><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def name(n)</span><br><span class="line">return lambda x: x*n#定义了一个匿名函数</span><br><span class="line">double=name(2)              #把函数值赋给变量</span><br><span class="line">print double(8)#double还需要一个变量</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出：<br>16</p></blockquote><h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p>return将结果与程序控制权一起返回到调用位置。<br>程序运行到第一个return位置即返回（退出函数）（但在try/finally情况下不是，在try遇到return，也会继续执行finally）（也就是说，函数可以有多个return语句）<br>如：返回两个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return x,y</span><br></pre></td></tr></table></figure></p><h2 id="成员运算符（in，not-in）"><a href="#成员运算符（in，not-in）" class="headerlink" title="成员运算符（in，not in）"></a>成员运算符（in，not in）</h2><ol><li>配合if用来查找元素是否在可迭代对象中<blockquote><p>if x in list   如果在，返回真<br>if x  not in list   如果不在，返回真</p></blockquote></li><li>配合for逐个取可迭代对象的元素<blockquote><p>for i in list   i取遍list中每一个元素</p></blockquote></li></ol><h2 id="身份运算符（is-，is-not）"><a href="#身份运算符（is-，is-not）" class="headerlink" title="身份运算符（is ，is not）"></a>身份运算符（is ，is not）</h2><p>is与==一样，都是对对象进行比较判断作用的运算符<br>但对对象比较判断的内容不同<br>is用来比较对象id是否相同。<br>可以用print id（x）来查看x的id</p><h2 id="global语句"><a href="#global语句" class="headerlink" title="global语句"></a>global语句</h2><blockquote><p>用于定义全局变量<br>global用于给定义在函数外的变量赋值，用global表明，这是个全局变量而非局部变量。</p></blockquote><blockquote><p>global语句可以在函数内对定义在函数外的变量赋值<br>赋值产生的变化也同时反映在主块中的变量</p><p>使用：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i=20</span><br><span class="line">def somefau()</span><br><span class="line">  global i</span><br><span class="line">  print i</span><br><span class="line">  i=10</span><br><span class="line">  print&quot;2nd=&quot;,i</span><br></pre></td></tr></table></figure><blockquote><p>输出结果</p><blockquote><p>20</p></blockquote></blockquote><blockquote><blockquote><p>2nd=10<br>通过global实现了在函数内对主块变量的赋值</p></blockquote></blockquote><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while型"><a href="#while型" class="headerlink" title="while型"></a>while型</h3><blockquote><h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句:"></a>while循环语句:</h4><blockquote><p>基本形式：（注：执行语句前要有缩进）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 判断条件：</span><br><span class="line">  执行语句...</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>当判断条件为Ture时，则会无限循环。</p></blockquote></blockquote><blockquote><h4 id="while…else语句："><a href="#while…else语句：" class="headerlink" title="while…else语句："></a>while…else语句：</h4><blockquote><p>基本形式：（注：同样要缩进)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while 判断条件：</span><br><span class="line">  执行语句1...</span><br><span class="line">else：</span><br><span class="line">  执行语句2...</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><ul><li>当判断条件为Ture时，执行1。</li><li>当判断条件为False时，执行2。</li></ul></blockquote></blockquote><blockquote><h4 id="while的简单语句组："><a href="#while的简单语句组：" class="headerlink" title="while的简单语句组："></a>while的简单语句组：</h4><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(判断语句）：执行语句</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>当执行语句只有一行时，可以将执行语句与while写在同一行。</p></blockquote></blockquote><blockquote><h4 id="while的附加命令"><a href="#while的附加命令" class="headerlink" title="while的附加命令:"></a>while的附加命令:</h4><blockquote><h5 id="continue："><a href="#continue：" class="headerlink" title="continue："></a>continue：</h5><blockquote><p>continue用于跳过当次循环</p></blockquote></blockquote><blockquote><blockquote><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = 1</span><br><span class="line">while i&lt;10:</span><br><span class="line">    i += 1</span><br><span class="line">    if i%2 == 0:</span><br><span class="line">        continue</span><br><span class="line">    print i</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><blockquote><blockquote><h5 id="break"><a href="#break" class="headerlink" title="break:"></a>break:</h5><blockquote><p>break用于退出循环</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>使用：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line">while 1:</span><br><span class="line">    i+=1</span><br><span class="line">    if i&gt;10:</span><br><span class="line">         break</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="for型"><a href="#for型" class="headerlink" title="for型"></a>for型</h3><blockquote><h4 id="for…in…"><a href="#for…in…" class="headerlink" title="for…in…"></a>for…in…</h4><p>主要用于遍历列表，字符串。</p><blockquote><h5 id="使用-遍历列表）："><a href="#使用-遍历列表）：" class="headerlink" title="使用(遍历列表）："></a>使用(遍历列表）：</h5></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4,5]</span><br><span class="line">for num in list</span><br><span class="line">    print num</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>输出结果：</p><blockquote><p>1</p></blockquote></blockquote><blockquote><blockquote><p>2</p></blockquote></blockquote><blockquote><blockquote><p>3</p></blockquote></blockquote><blockquote><blockquote><p>4</p></blockquote></blockquote><blockquote><blockquote><p>5</p></blockquote></blockquote></blockquote><blockquote><blockquote><h5 id="使用（遍历字符串）："><a href="#使用（遍历字符串）：" class="headerlink" title="使用（遍历字符串）："></a>使用（遍历字符串）：</h5></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for var in &apos;lin&apos;</span><br><span class="line">    print var</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>输出结果：</p><blockquote><p>l</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>i</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>n</p></blockquote></blockquote></blockquote><blockquote><blockquote><h5 id="通过指针变量来进行遍历："><a href="#通过指针变量来进行遍历：" class="headerlink" title="通过指针变量来进行遍历："></a>通过指针变量来进行遍历：</h5></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4,5]</span><br><span class="line">for i in range(5):</span><br><span class="line">    num = list[i]</span><br><span class="line">    print num,</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>输出结果：</p><blockquote><p>1 2 3 4 5</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><h6 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数:"></a>range()函数:</h6><p>range（start，stop,step）可创建一个整数列表：<br>三个参数</p><blockquote><p>start:计数开始位置，默认是0。如range(3)等价于range（0，3）</p></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>stop:计数结束位置，但不包括stop。如range（0，5）中没有5。</p></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>step:步长（每次加的数），默认是1。如range(0,6,2)为[0,1,3,5]</p></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><h4 id="for…in-else"><a href="#for…in-else" class="headerlink" title="for…in:/else:"></a>for…in:/else:</h4></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(10):</span><br><span class="line">    print i</span><br><span class="line">else:</span><br><span class="line">    print i+100</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>for中语句与之前的没有区别，但else只在for正常循环结束后（不是通过break结束）的情况下被执行。</p></blockquote></blockquote><h2 id="占位语句（pass）"><a href="#占位语句（pass）" class="headerlink" title="占位语句（pass）"></a>占位语句（pass）</h2><ul><li>pass不做任何事情，只用作占位。</li><li>没想好函数内容是，在函数内写入一条pass可以避免报错<blockquote><p>像这样：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def unthink()</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></li></ul><h2 id="条件语句（if…elif…else…"><a href="#条件语句（if…elif…else…" class="headerlink" title="条件语句（if…elif…else…)"></a>条件语句（if…elif…else…)</h2><blockquote><blockquote><p>通过一条或多条语句的执行结果（Ture或False)来决定执行的代码块。</p></blockquote></blockquote><blockquote><blockquote><p>要格外注意缩进的问题，没进入一个新代码块，打两个空格</p></blockquote><blockquote><p>使用：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件1：</span><br><span class="line">    执行语句1</span><br><span class="line">elif 判断条件2：</span><br><span class="line">    执行语句2</span><br><span class="line">···</span><br><span class="line">else:</span><br><span class="line">    执行语句n</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>也有类似于while的简单语句组：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if 判断语句：执行语句</span><br></pre></td></tr></table></figure></blockquote><h2 id="捕捉异常并处理（try-except-else-finally）"><a href="#捕捉异常并处理（try-except-else-finally）" class="headerlink" title="捕捉异常并处理（try/except/else/finally）"></a>捕捉异常并处理（try/except/else/finally）</h2><blockquote><p>检测try中的错误，用except捕获异常并处理。<strong> 然后程序返回到try位置 </strong><br>可以做到异常发生时不结束程序。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法:"></a>语法:</h3><p>三者顺序不能乱，且有else就必须有except</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  语句1    #先执行语句1</span><br><span class="line">  ...</span><br><span class="line">except name:</span><br><span class="line">  语句2    #发生name异常，执行语句2，而后通过整个try</span><br><span class="line">  ...</span><br><span class="line">except name1，数据：</span><br><span class="line">  语句3    #发生name1异常，执行语句3，获得数据。数据可以是（as reason 输出程序检测到的错误类型）</span><br><span class="line">except：</span><br><span class="line">  语句3_1  #没有匹配到的异常，执行语句3_1</span><br><span class="line">else:</span><br><span class="line">  语句4    #语句1没有异常，执行此代码</span><br><span class="line">finally:</span><br><span class="line">  语句5    #无论有无异常发生，都会执行语句5</span><br></pre></td></tr></table></figure><blockquote><p>执行语句1，根据语句1发生的异常类型来选择执行的except下的代码块，没有发生异常则执行else下的代码块。</p></blockquote><h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    num1 = raw_input(&apos;输入一个数字&apos;)</span><br><span class="line">    num1 = int(num1)</span><br><span class="line">except ValueError , as reason:</span><br><span class="line">    print &quot;请输入一个数字&quot;, reason</span><br><span class="line">else:</span><br><span class="line">    print num1</span><br><span class="line">finally:</span><br><span class="line">    print &quot;无论如何都执行我&quot;</span><br></pre></td></tr></table></figure><blockquote><p>输入：5<br>输出：</p><blockquote><p>5</p></blockquote><blockquote><p>无论如何都输出我</p></blockquote></blockquote><blockquote><p>输入：a<br>输出：</p></blockquote><blockquote><blockquote><p>请输入一个数字</p></blockquote></blockquote><blockquote><blockquote><p>无论如何都输出我</p></blockquote></blockquote><blockquote><blockquote><p>_(光标，回到try位置）</p></blockquote></blockquote><h2 id="捕捉异常语句并处理（with-as"><a href="#捕捉异常语句并处理（with-as" class="headerlink" title="捕捉异常语句并处理（with as)"></a>捕捉异常语句并处理（with as)</h2><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with expresion as val:</span><br><span class="line">    语句1</span><br></pre></td></tr></table></figure><blockquote><p>执行过程：先执行expresion中的<em>enter</em>（）方法，这个方法的返回值被赋值给val（若没有as val，则返回值被忽略）。接着执行语句1，语句1若出现异常，执行expresion中的<em>exit</em>()方法，若果没有异常，则在执行完毕后执行<em>exit</em>（）方法。</p></blockquote><h3 id="例如"><a href="#例如" class="headerlink" title="例如:"></a>例如:</h3><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(lin.txt) as obj:</span><br><span class="line">    data=obj.read()</span><br></pre></td></tr></table></figure><p>等价于</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    obj=open(lin.txt)</span><br><span class="line">    data=obj.read()</span><br><span class="line">finally:</span><br><span class="line">    obj.close</span><br></pre></td></tr></table></figure><p>也就是说，无论读取文件是否出现异常，都会执行关闭文件句柄这一个操作</p><h2 id="exec-函数"><a href="#exec-函数" class="headerlink" title="exec()函数"></a>exec()函数</h2><blockquote><p>exec函数能够执行复杂的python代码。</p></blockquote><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k=10</span><br><span class="line">exec(&apos;i=10 j=100 anw=i*j*k print anw&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br>10000<br>exec（’str’,’参数’）<br>也可以在参数位置改变k值<br>也就是说，exec（）函数可以执行字符串形式的python代码）<br>如果上面的字符串在一个.txt文本中，也可以用exec（）函数来执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(name.txt) as obj:</span><br><span class="line">    data=obj.read()</span><br><span class="line">exec(data)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出：<br>1000</p></blockquote><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>yield类似中断，一旦执行到yield就会返回变量当前的值，记住这个位置，然后下一次再继续执行yield后的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yield 变量</span><br></pre></td></tr></table></figure></p><h2 id="raise"><a href="#raise" class="headerlink" title="raise()"></a>raise()</h2><p>可以用来引发异常，可以用来传递异常,但是异常对象必须是error或exception的子类。<br>引发异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise Exception(&quot;抛出一个异常&quot;)</span><br></pre></td></tr></table></figure></p><h2 id="assert断言"><a href="#assert断言" class="headerlink" title="assert断言"></a>assert断言</h2><p>相当于一个 raise-if-not<br>即：assert后的布尔表达式为假时，抛出一个异常。</p><h2 id="assert-布尔表达式"><a href="#assert-布尔表达式" class="headerlink" title="assert 布尔表达式"></a>assert 布尔表达式</h2><p>表达式为假时，抛出异常<br>添加异常参数的语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 布尔表达式，&apos;一个字符串&apos;</span><br></pre></td></tr></table></figure></p><p>表达式为假时，抛出异常，并返回字符串。</p><h1 id="变量的容器们"><a href="#变量的容器们" class="headerlink" title="变量的容器们"></a>变量的容器们</h1><p>本笔记主要用来记录关于，列表，字典，文件等的特性<br><!--more--></p><h2 id="总注"><a href="#总注" class="headerlink" title="总注"></a>总注</h2><ol><li>列表只可以通过数字作为索引。（只能通过数来来获取列表中的元素）</li><li>字典可以通过任何东西找到其中的元素。（字典可以将一个事物和另一个事物关联）<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><strong> 专供有序排列的数据使用 </strong><h3 id="列表的创建"><a href="#列表的创建" class="headerlink" title="列表的创建"></a>列表的创建</h3>list=[‘python’,’lin’,1,2,3]<blockquote><p>也就是说，列表中的元素不需要一定同类型</p></blockquote></li></ol><h3 id="列表的操作包括：索引，切片，加，乘，检查成员"><a href="#列表的操作包括：索引，切片，加，乘，检查成员" class="headerlink" title="列表的操作包括：索引，切片，加，乘，检查成员"></a>列表的操作包括：索引，切片，加，乘，检查成员</h3><blockquote><p>索引（正向读取）—var=list[0]—–var=’python’。<br>索引（逆向读取）—var=list[-1]—-var=3—–(-1就是倒数第一个<br>索引(替换）—var=2。list[2]=var—-list2=[‘python’,’lin’,2,2,3]</p><p>切片—lis=list[0:3]—lis=[‘python’,’lin’,1]（包括头不包括尾）</p><p>加(也可以用list.extend（lis））—–lit=lis+list—-lit=<br>[‘python’,’lin’,1,’python’,’lin’,1,2,3]</p></blockquote><blockquote><p>乘—–lis2=list[2:5] lis3=lis2*2—-lis3=[1,2,3,1,2,3]</p></blockquote><h3 id="通过内置函数和方法，可以实现"><a href="#通过内置函数和方法，可以实现" class="headerlink" title="通过内置函数和方法，可以实现:"></a>通过内置函数和方法，可以实现:</h3><ul><li>比较（cmp(a,b)，</li><li>添加成员(list.append(obj)(obj可以是列表，也可以是成员)，</li><li>计算长度（len（a))，</li><li>返回最值(max(a);min(a)),</li><li>统计某成员出现次数（list.count(obj)),</li><li>反向排序（list.reverse())，</li><li>移除特定成员（list.remove（obj）），</li><li>移除特定位置成员（list.pop(-1)(-1为最后一项，0为第一个，1为第二个…)</li><li>找出特定对象的索引位置（list.index(obj))(找出obj的索引位置）</li><li>将对象插入特定位置（list.insert（index，obj））</li><li>对原列表进行排序（list.sort())</li></ul><h3 id="列表与字符串的转化"><a href="#列表与字符串的转化" class="headerlink" title="列表与字符串的转化"></a>列表与字符串的转化</h3><h4 id="列表-gt-字符串"><a href="#列表-gt-字符串" class="headerlink" title="列表 =&gt; 字符串"></a>列表 =&gt; 字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list=[&apos;lin&apos;,&apos;mu&apos;,&apos;shen&apos;]</span><br><span class="line">print &apos; &apos;.join(list)</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote></blockquote><p>lin mu shen</p><p>用字符串的形式显示并用空格分隔列表中的成员。</p><h4 id="字符串-gt-列表"><a href="#字符串-gt-列表" class="headerlink" title="字符串 =&gt; 列表"></a>字符串 =&gt; 列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var=&apos;lin mu shen&apos;</span><br><span class="line">list=var.split(&apos; &apos;)</span><br><span class="line">print list</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote></blockquote><p>[‘lin’,’mu’,’shen’]</p><p>以空格为每一个成员分隔点创建列表。</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>可以存储任意型变量（值可以是任意型数据，但键只可以是字符串，数字或元组。）<br><strong> 就像一个查询表 </strong></p><h3 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h3><p>键与值用冒号分割。每对键值之间用逗号分割。整个字典用花括号括起来。</p><blockquote><p>dic={‘abd’:1234,’lin’:’mushen’}</p></blockquote><h3 id="访问字典里的值："><a href="#访问字典里的值：" class="headerlink" title="访问字典里的值："></a>访问字典里的值：</h3><p>把相应的键放入[]中</p><blockquote><p>dic[‘abc’]</p></blockquote><h3 id="修改字典："><a href="#修改字典：" class="headerlink" title="修改字典："></a>修改字典：</h3><h4 id="增加："><a href="#增加：" class="headerlink" title="增加："></a>增加：</h4><p>dic[‘python’]=’func’</p><h4 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h4><p>dic[‘python’]=’very fun’</p><h4 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h4><ol><li>删除单一成员：<blockquote><p>del dic[‘python’]</p></blockquote></li><li>清空字典：<blockquote><p>dic.clear()</p></blockquote></li><li>删除字典：<blockquote><p>del dic</p></blockquote><h3 id="字典的特性："><a href="#字典的特性：" class="headerlink" title="字典的特性："></a>字典的特性：</h3></li><li>键不可以重复，一旦重复，后一个覆盖前一个</li><li>键不可以更改。（列表不可以当键）</li><li>字典内容是无序的。<h3 id="有关字典的函数和方法："><a href="#有关字典的函数和方法：" class="headerlink" title="有关字典的函数和方法："></a>有关字典的函数和方法：</h3><h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4></li><li>cmp(dic1,dic2)—–比较两个字典中的元素</li><li>len（dic）—–计算键（元素）的总数</li><li>str(dic)—–用字符串的形式输出字典</li><li>type(value)—-返回变量类型（value=dic时，返回字典）<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4></li><li>dec.clear()—-清空字典中内容</li><li>dic.copy()—–返回一个字典的浅复制（浅复制：只复制一级目录，二级的不复制（例如值是一个列表，则只复制列表名，列表中内容不复制）<blockquote><p>与直接赋值（dic1=dic的区别：dic1只是对dic中的对象进行了引用，如果dic对象发生改变，则dic1也改变，而复制不会）</p></blockquote></li><li>dic.get(key,default=value)—-返回指定键的值，如果键不存在，则返回default的值</li><li>dic.setdefault(key,default=value)—-返回指定键值，若键不存在则将value添加为该键的值</li><li>dic.has_key(key)—–判断键是否在字典中，若在，返回Ture，不在返回False</li><li>dic.items()—–返回列表形式的可遍历的元组数组（将一组键与值当作一个元组，所有元组当作一个列表）</li><li>dic.keys()—–以列表返回一个字典中所有的键。</li><li>dic.values()—以列表返回一个字典中所有的值</li><li>dic.update(dic2)—将dic2的键值更新到dic中</li><li>dic.popitem()—-随机返回并删除字典中的一对键值</li><li>dic.pop(‘key’，value)—-返回并删除指定键对应的值，若键值不存在，返回value。</li><li>dic.fromkeys(seq,value)—-以序列（列表等）中的元素做键，value为所有键的值。</li></ol><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>总注：</p><ol><li>数据类型是不允许改变的</li></ol><h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>True</li><li>False</li><li>None</li><li>strings</li><li>numbers</li><li>floats</li><li>lists</li></ul><h2 id="True-False和None"><a href="#True-False和None" class="headerlink" title="True,False和None"></a>True,False和None</h2><p>都是布尔值</p><h2 id="strings（字符串）"><a href="#strings（字符串）" class="headerlink" title="strings（字符串）"></a>strings（字符串）</h2><ol><li><p>创建字符串,使用单引号或双引号创建字符串,python中单个字符也作为字符串</p><blockquote><p>如：value=’strings’</p></blockquote></li><li><p>访问字符串中断值</p><blockquote><p>如：let=value[1]—-t<br>   lets=value[1:5]—–trin（包括头但不包括尾）</p></blockquote></li><li><p>字符串的更新</p><blockquote><p>如：valuess=value[:4]+lins——strlins(从冒号后面的是更新启始位，相当于添加字符串的0位）</p></blockquote></li></ol><h2 id="numbers（数字）"><a href="#numbers（数字）" class="headerlink" title="numbers（数字）"></a>numbers（数字）</h2><p>该数据类型用于存储数字<br>python支持四种不同的数据类型</p><ol><li>整型（int)—-正数或负数，不带有小数点<blockquote><p>如： var=10  var=-100</p></blockquote></li><li>长整型（long int）—-无限大小的整数，末尾带有大写或小写的L<blockquote><p>如： var=11112222L</p></blockquote></li><li>浮点型（floating point real values）—-由整数部分和小数部分组成，也可以使用科学记数法<blockquote><p>如：flo=15.20 flo=32.3+e18</p></blockquote></li><li>复数：由实部和虚部组成<blockquote><p>如： fus=a+bj fus=complex(a,b)</p></blockquote></li></ol><h2 id="lists-列表）"><a href="#lists-列表）" class="headerlink" title="lists(列表）"></a>lists(列表）</h2><p>列表是较为常见的数据结构<br>列表中每一个元素都有一个特定的索引（每一个元素分配一个数字）</p><h3 id="列表的创建-1"><a href="#列表的创建-1" class="headerlink" title="列表的创建"></a>列表的创建</h3><p>list=[‘python’,’lin’,1,2,3]</p><blockquote><p>也就是说，列表中的元素不需要一定同类型</p></blockquote><h3 id="列表的操作包括：索引，切片，加，乘，检查成员-1"><a href="#列表的操作包括：索引，切片，加，乘，检查成员-1" class="headerlink" title="列表的操作包括：索引，切片，加，乘，检查成员"></a>列表的操作包括：索引，切片，加，乘，检查成员</h3><blockquote><p>索引（正向读取）—var=list[0]—–var=’python’。<br>索引（逆向读取）—var=list[-1]—-var=3—–(-1就是倒数第一个<br>索引(替换）—var=2。list[2]=var—-list2=[‘python’,’lin’,2,2,3]</p><p>切片—lis=list[0:3]—lis=[‘python’,’lin’,1]（包括头不包括尾）</p><p>加(也可以用list.extend（lis））—–lit=lis+list—-lit=<br>[‘python’,’lin’,1,’python’,’lin’,1,2,3]</p></blockquote><blockquote><p>乘—–lis2=list[2:5] lis3=lis2*2—-lis3=[1,2,3,1,2,3]</p></blockquote><h3 id="通过内置函数和方法，可以实现-1"><a href="#通过内置函数和方法，可以实现-1" class="headerlink" title="通过内置函数和方法，可以实现:"></a>通过内置函数和方法，可以实现:</h3><ul><li>比较（cmp(a,b)，</li><li>添加成员(list.append(obj)(obj可以是列表，也可以是成员)，</li><li>计算长度（len（a))，</li><li>返回最值(max(a);min(a)),</li><li>统计某成员出现次数（list.count(obj)),</li><li>反向排序（list.reverse())，</li><li>移除特定成员（list.remove（obj）），</li><li>移除特定位置成员（list.pop(-1)(-1为最后一项，0为第一个，1为第二个…)</li><li>找出特定对象的索引位置（list.index(obj))(找出obj的索引位置）</li><li>将对象插入特定位置（list.insert（index，obj））</li><li>对原列表进行排序（list.sort())</li></ul><h3 id="列表与字符串的转化-1"><a href="#列表与字符串的转化-1" class="headerlink" title="列表与字符串的转化"></a>列表与字符串的转化</h3><h4 id="列表-gt-字符串-1"><a href="#列表-gt-字符串-1" class="headerlink" title="列表 =&gt; 字符串"></a>列表 =&gt; 字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list=[&apos;lin&apos;,&apos;mu&apos;,&apos;shen&apos;]</span><br><span class="line">print &apos; &apos;.join(list)</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote></blockquote><p>lin mu shen</p><p>用字符串的形式显示并用空格分隔列表中的成员。</p><h4 id="字符串-gt-列表-1"><a href="#字符串-gt-列表-1" class="headerlink" title="字符串 =&gt; 列表"></a>字符串 =&gt; 列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var=&apos;lin mu shen&apos;</span><br><span class="line">list=var.split(&apos; &apos;)</span><br><span class="line">print list</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote></blockquote><p>[‘lin’,’mu’,’shen’]</p><p>以空格为每一个成员分隔点创建列表。</p><h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>只需要复制\征服蟒蛇\projects\skeleton中所有内容然后将其粘贴到projecs中的项目文件中。</li><li>将其中所有NAME的文件都改为新项目的名字。</li><li>删除所有.pyc文件</li><li>在原NAME文件下创建新的项目py文件</li><li>根据需要，更改原NAME_tests.py（测试脚本）文件</li></ol><h2 id="作者的建议"><a href="#作者的建议" class="headerlink" title="作者的建议"></a>作者的建议</h2><ol><li>测试脚本要放在tests/目录下，且命名必须符合NAME_tests.py的规则。</li><li>为每一个模块写一个测试。</li><li>测试用例尽可能易懂又易写，但要尽量保持整洁。</li><li>别太把测试当回事。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了更方便的记笔记，我搭建了这个博客&lt;br&gt;
    
    </summary>
    
      <category term="python学习" scheme="http://linmushen.com/categories/python-study/"/>
    
    
  </entry>
  
</feed>
