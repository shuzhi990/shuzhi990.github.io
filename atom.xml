<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林木深的个人博客</title>
  
  <subtitle>热爱技术，痴迷技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linmushen.com/"/>
  <updated>2019-08-21T08:18:23.523Z</updated>
  <id>http://linmushen.com/</id>
  
  <author>
    <name>林木深</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Matlab学习笔记</title>
    <link href="http://linmushen.com/2019/08/16/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/08/16/Matlab学习笔记/</id>
    <published>2019-08-16T05:16:47.000Z</published>
    <updated>2019-08-21T08:18:23.523Z</updated>
    
    <content type="html"><![CDATA[<p>好好学习Matlab。<br><a id="more"></a></p><p>学习目标：基本常用拟合曲线形式及特点、线性拟合线性度。了解插值、回归。<br>微分、偏微分方程求解及数值解，了解数学意义及程序</p><p>知识积累：<br>运算：<br>1） .  ：矩阵中相同位置的元素进行.后的运算。</p><p>函数：<br>1）画图<br>x = linspace(起始点，终止点，点的个数)<br>y = sin(x)<br>沿sin(x)曲线生成点的个数（默认是100个）个等间距的点</p><p>2）数据拟合：<br>p = polyfit(x,y,n)；返回n+1阶拟合后函数的系数。<br>配合y = polyval(p,x)；计算对应点y的值。</p><p>3）读取Excel电子表格文件<br>xlsread(filename,sheetx,xlrange)<br>filename：文件名<br>sheetx：第几个表格（sheet1,sheet2…）<br>xlrange:矩阵范围A1：H99（从A行的第一列的元素到H行的第九十九的元素之间的矩阵）</p><p>4）清除临时变量<br>clearvars 临时变量1 临时变量2；</p><p>5）创建一个新的临时图像窗口<br>figure</p><p>6）datetick(变量1，变量2)<br>变量1：要改变的轴<br>变量2：日期转变的形式<br><img src="https://i.imgur.com/DGFnl7c.png" alt></p><p>7）xlabel(txt,name,value)</p><ul><li>txt-轴标签</li><li>name-变量的名称 如 fontsize</li><li>value-变量的值  如 fontsize对应的12</li></ul><p>8）mean(变量（一个向量）)<br>返回变量的均值</p><p>9）sum(变量（一个向量）)<br>将变量累加</p><p>10）subplot(m,n,p)<br>将窗口划分成m*n个区域，并在p区域画图。</p><p>11）axis([x1 x2 y1 y2])<br>用来确定x轴y轴范围的函数。</p><p>12）<br>grid on；%添加网格<br>grid off；%去掉网格</p><p>13）unifrnd(A,B,m,n)函数<br>生成被A和B指定上下端点[A,B]的连续均匀分布的随机数组。<br>当存在m，n时，数组大小为m*n；当没有m,n时，数组大小由A,B数组确定。<br>附上Matlab文档</p><blockquote><p>A和B可以是向量也可以是标量，若两个都是向量，则两者都是列向量或都是行向量，而且维数相等。从A到B产生一系列区间，若A和B均为向量，则区间个数等于他们的维数；若其中恰有一个是向量，假设A为向量，则区间个数等于A的维数；若两个均为标量，则A&lt;= B，区间个数为1，且区间为[A,B]。然后在这一系列区间中随机产生连续均匀分布的数组R并返回之。具体例子下述。<br>如：<br>执行指令</p></blockquote><blockquote><blockquote><p>x = [1:9];<br>y = [2:10];<br>unifrnd(x,y)</p></blockquote></blockquote><p>得到</p><p>ans =</p><pre><code>1.9595    2.6557    3.0357    4.8491    5.9340    6.6787    7.7577    8.7431    9.3922</code></pre><p>从x到y产生区间[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9.10].然后从每个区间产生一个随机数，得到R。</p><blockquote><p>执行指令</p></blockquote><blockquote><blockquote><p>x = [1:3];<br>R1 = unifrnd(x,1);<br>R2 = unifrnd(1,x);</p></blockquote></blockquote><p>得到</p><p>R1 =</p><pre><code>1   NaN   NaN</code></pre><p>R2 =</p><pre><code>1.0000    1.2769    1.0923</code></pre><p>NaN表示”not a number”即不是数字。观察语句R1 = unifrnd(x,1);“从x到1”产生区间[1,1],[2,1],[3,1]显然只有第一个区间可以取得“随机数”1，其余区间不符合规定，故而返回NaN。</p><p>观察R2 = unifrnd(1,x);从1到x产生区间[1,1],[1,2],[1,3],取得随机数组R2。</p><p>14） exp(X)：指数函数，返回X中每个元素的e^x。</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><h2 id="学习目录"><a href="#学习目录" class="headerlink" title="学习目录"></a>学习目录</h2><p>1）了解Matlab基本用法，常用的命令。<br>2）熟悉常见模型的求解算法和套路，如：连续模型、规划模型等。<br>3）将机理建模的过程模拟出来，能够建立和求解没有套路的模型。</p><h2 id="主要题型对应的模型"><a href="#主要题型对应的模型" class="headerlink" title="主要题型对应的模型"></a>主要题型对应的模型</h2><p><img src="https://i.imgur.com/3oIfAhp.png" alt><br><img src="https://i.imgur.com/mQt1xY1.png" alt></p><h1 id="第一篇—实战项目"><a href="#第一篇—实战项目" class="headerlink" title="第一篇—实战项目"></a>第一篇—实战项目</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>已知股票的交易数据：日期、开盘价、最高价、最低价、收盘价、成交量、换手率，用某种方法来评价这只股票的价值和风险。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>作为一个科学计算问题，典型的流程是：1.获取并导入数据；2.数据探索和建模；3.分享结果</p><h2 id="Matlab实现"><a href="#Matlab实现" class="headerlink" title="Matlab实现"></a>Matlab实现</h2><h3 id="第一步—从外部读取数据（获取省略，已下为导入部分）"><a href="#第一步—从外部读取数据（获取省略，已下为导入部分）" class="headerlink" title="第一步—从外部读取数据（获取省略，已下为导入部分）"></a>第一步—从外部读取数据（获取省略，已下为导入部分）</h3><p>1）在左侧窗口下找到需要读取的数据的位置<br><img src="https://i.imgur.com/gB5VTcr.png" alt><br>2）右击该文件，点击导入数据<br>3）出现一个导入引擎<br><img src="https://i.imgur.com/gUGdBnC.png" alt><br>4）点击导入所选内容（大绿色对号），点击之前可以选择导入的形式（默认是列向量的形式），之后Matlab工作区出现这些导入的数据。</p><h3 id="第二步—数据探索和建模"><a href="#第二步—数据探索和建模" class="headerlink" title="第二步—数据探索和建模"></a>第二步—数据探索和建模</h3><p>绘制图形：<br>首先双击变量名，然后选中变量，点击绘图建，选择想要绘制的图形，可视化查看数据。<br><img src="https://i.imgur.com/djqIzuE.jpg" alt><br><img src="https://i.imgur.com/xoddok0.png" alt><br>或者输入 plot(x轴：文件名.变量名,y轴：文件名.变量名)</p><p>创建脚本：<br>还是找到数据所在位置，然后右击导入数据，进入菜单，点击大绿对号下的小箭头，选择生成脚本，然后保存该脚本。<img src="https://i.imgur.com/lUzJTng.png" alt></p><p>知识积累：<br>1）画图<br>x = linspace(起始点，终止点，点的个数)<br>y = sin(x)<br>沿sin(x)曲线生成点的个数（默认是100个）个等间距的点</p><p>2）数据拟合：<br>p = polyfit(x,y,n)；返回n+1阶拟合后函数的系数。<br>配合y = polyval(p,x)；计算对应点y的值。</p><p>3）读取Excel电子表格文件<br>xlsread(filename,sheetx,xlrange)<br>filename：文件名<br>sheetx：第几个表格（sheet1,sheet2…）<br>xlrange:矩阵范围A1：H99（从A行的第一列的元素到H行的第九十九的元素之间的矩阵）</p><p>4）清除临时变量<br>clearvars 临时变量1 临时变量2；</p><p>5）创建一个新的临时图像窗口<br>figure</p><p>6）datetick(变量1，变量2)<br>变量1：要改变的轴<br>变量2：日期转变的形式<br><img src="https://i.imgur.com/DGFnl7c.png" alt></p><p>Matlab程序<br>写在了 C:\Users\树枝990\Matlab\Matlab学习1 下</p><h3 id="第三步—发布并转换成word形式"><a href="#第三步—发布并转换成word形式" class="headerlink" title="第三步—发布并转换成word形式"></a>第三步—发布并转换成word形式</h3><p>1）点击发布下的编辑发布内容<br><img src="https://i.imgur.com/YpTRybG.png" alt></p><p>2）改为word形式<br><img src="https://i.imgur.com/ednd6ng.png" alt><br>发布出来的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc,clear,close all</span><br><span class="line">[~,~,raw] = xlsread(&apos;sz000004.xlsx&apos;,&apos;Sheet1&apos;,&apos;A2:H99&apos;);   %读取sz000004.xls文件中的sheet表格中的A2到H99之间矩阵的所有元素</span><br><span class="line">data = reshape([raw&#123;:&#125;],size(raw));     %将raw&#123;:&#125;重构成原来尺寸的矩阵</span><br><span class="line"></span><br><span class="line">Date = data(:,1);</span><br><span class="line">DataNum = data(:,2);</span><br><span class="line">Popen = data(:,3);</span><br><span class="line">Phigh = data(:,4);</span><br><span class="line">Plow = data(:,5);</span><br><span class="line">Pclose = data(:,6);</span><br><span class="line">Volum = data(:,7);</span><br><span class="line">Turm = data(:,8);</span><br><span class="line"></span><br><span class="line">clearvars data raw;</span><br><span class="line"></span><br><span class="line">plot(DataNum,Pclose,&apos;k&apos;)</span><br><span class="line">datetick(&apos;x&apos;,&apos;dd&apos;);     %修改日期形式</span><br><span class="line">xlabel(&apos;日期&apos;);</span><br><span class="line">ylabel(&apos;收盘价格&apos;);</span><br><span class="line">figure %创建一个临时窗口</span><br><span class="line">bar(Pclose)</span><br><span class="line"></span><br><span class="line">p = polyfit(DataNum,Pclose,1);</span><br><span class="line">P1 = polyval(p,DataNum);    %进行拟合</span><br><span class="line">figure</span><br><span class="line">plot(DataNum,P1,DataNum,Pclose,&apos;*g&apos;)</span><br><span class="line">value = p(1);</span><br><span class="line"></span><br><span class="line">MaxDD = maxdrawdown(Pclose);</span><br><span class="line">risk = MaxDD;</span><br></pre></td></tr></table></figure><h1 id="第二篇—回归方法"><a href="#第二篇—回归方法" class="headerlink" title="第二篇—回归方法"></a>第二篇—回归方法</h1><p>数学建模有很多方法，数学建模常用方法包括：回归、统计、机器学习、深度学习、灰色预测、主成分分析、神经网络、时间序列分析。<br>本章介绍几种回归方法。<br>回归方法分为：一元线性、一元非线性、多元回归、逐步回归、Logistic回归。</p><h2 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h2><h3 id="最小二乘法进行拟合"><a href="#最小二乘法进行拟合" class="headerlink" title="最小二乘法进行拟合"></a>最小二乘法进行拟合</h3><p>公式：y=b1*x+b0<br>确定系数的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Lxx = sum((x-mean(x)).^2); %最小二乘法</span><br><span class="line">Lxy = sum((x-mean(x)).*(y-mean(y)));</span><br><span class="line">b1 = Lxy/Lxx;              %最小二乘法拟合出来的直线的斜率</span><br><span class="line">b0 = mean(y)-b1*mean(x);   %最小二乘法拟合出来的直线的截距</span><br></pre></td></tr></table></figure><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">close all;</span><br><span class="line">x = [23.80,27.60,31.60,32.40,33.70,34.90,43.20,52.80,63.80,73.40];</span><br><span class="line">y = [41.40,51.80,61.70,67.90,68.70,77.50,95.90,137.40,155.00,175.00];</span><br><span class="line"></span><br><span class="line">figure</span><br><span class="line">plot(x,y,&apos;r*&apos;)             %画出x,y的散点图</span><br><span class="line">xlabel(&apos;x(职工工资总额)&apos;,&apos;fontsize&apos;,12)   %为x轴标注，并将字体设置为12号</span><br><span class="line">ylabel(&apos;y(商品零售总额)&apos;,&apos;fontsize&apos;,12)   %为y轴标注，并将字体设置为12号</span><br><span class="line">set(gca,&apos;linewidth&apos;,2)     %为坐标轴设置线宽为2号</span><br><span class="line"></span><br><span class="line">Lxx = sum((x-mean(x)).^2); %最小二乘法</span><br><span class="line">Lxy = sum((x-mean(x)).*(y-mean(y)));</span><br><span class="line">b1 = Lxy/Lxx;              %最小二乘法拟合出来的直线的斜率</span><br><span class="line">b0 = mean(y)-b1*mean(x);   %最小二乘法拟合出来的直线的截距</span><br><span class="line">y1 = b1*x+b0;              %拟合后的直线</span><br><span class="line">hold on</span><br><span class="line">plot(x,y1,&apos;linewidth&apos;,2);</span><br></pre></td></tr></table></figure><p>最小二乘法是将散点拟合到一条直线上，得到的直线方程是y=k<em>x+b<br>其中k的公式为<img src="https://i.imgur.com/dDKeeNE.jpg" alt><br>b的公式为y的平均值-k</em>x的平均值。</p><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://i.imgur.com/nq2Xncm.png" alt></p><h2 id="非线性回归"><a href="#非线性回归" class="headerlink" title="非线性回归"></a>非线性回归</h2><p>变量的关系并不都是线性的，用非线性回归首先要解决的问题是回归方程中参数如何估计。</p><h3 id="对数方法进行拟合"><a href="#对数方法进行拟合" class="headerlink" title="对数方法进行拟合"></a>对数方法进行拟合</h3><p>公式：y=a+b*lnx<br>确定系数a,b的方法：调用 fitnlm(x,y,m1,[0.01;0.01])函数<br>具体代码：见最后，和指数方法的一起列出</p><h3 id="指数方法进行拟合"><a href="#指数方法进行拟合" class="headerlink" title="指数方法进行拟合"></a>指数方法进行拟合</h3><p>公式：y=a*x^b<br>确定系数a,b的方法：调用fitnlm(x,y,m2,[1;1])函数<br>具体代码：见最后</p><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">%输入数据</span><br><span class="line"></span><br><span class="line">x = [1.5,4.5,7.5,10.5,13.5,16.5,19.5,22.5,25.5];</span><br><span class="line">y = [7.0,4.8,3.6,3.1,2.7,2.5,2.4,2.3,2.2];</span><br><span class="line"></span><br><span class="line">%画散点图，标明xy轴，加粗坐标轴</span><br><span class="line"></span><br><span class="line">figure</span><br><span class="line">plot(x,y,&apos;b*&apos;);</span><br><span class="line">xlabel(&apos;x(销售额x/万元)&apos;,&apos;fontsize&apos;,12)</span><br><span class="line">ylabel(&apos;y(流通费率y/%)&apos;,&apos;fontsize&apos;,12)</span><br><span class="line">set(gca,&apos;linewidth&apos;,2)</span><br><span class="line"></span><br><span class="line">%进行拟合（对数方法）</span><br><span class="line"></span><br><span class="line">m1 = @(b,x)b(1) + b(2)*log(x);</span><br><span class="line">nonlinfit1 = fitnlm(x,y,m1,[0.01;0.01]);</span><br><span class="line">b = nonlinfit1.Coefficients.Estimate;</span><br><span class="line">Y1 = b(1,1) + b(2,1)*log(x);</span><br><span class="line">hold on</span><br><span class="line">plot(x,Y1,&apos;--k&apos;,&apos;linewidth&apos;,2)</span><br><span class="line"></span><br><span class="line">%再次进行拟合（指数方法）</span><br><span class="line"></span><br><span class="line">m2 = &apos;y~b1*x^b2&apos;;</span><br><span class="line">nonlinfit2 = fitnlm(x,y,m2,[1,1]);</span><br><span class="line">b1 = nonlinfit2.Coefficients.Estimate(1,1);</span><br><span class="line">b2 = nonlinfit2.Coefficients.Estimate(2,1);</span><br><span class="line">Y2 = b1*x.^b2;</span><br><span class="line">hold on</span><br><span class="line">plot(x,Y2,&apos;r&apos;,&apos;linewidth&apos;,2)</span><br><span class="line"></span><br><span class="line">%为每条线加注释</span><br><span class="line"></span><br><span class="line">legend(&apos;原始数据&apos;,&apos;a+b*lnx&apos;,&apos;a*x^b&apos;)</span><br></pre></td></tr></table></figure><h3 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://i.imgur.com/tJM98Lu.png" alt></p><h2 id="多元回归"><a href="#多元回归" class="headerlink" title="多元回归"></a>多元回归</h2><p>在拟合之前，应先通过数据可视化，判断问题能否应该多元线性拟合。</p><h3 id="regress-函数进行拟合"><a href="#regress-函数进行拟合" class="headerlink" title="regress()函数进行拟合"></a>regress()函数进行拟合</h3><h4 id="regress-函数"><a href="#regress-函数" class="headerlink" title="regress()函数"></a>regress()函数</h4><p>[回归系数字母B，回归系数置信区间左边界bint，回归系数（中值）b，回归系数置信区间右区间rint，统计变量s]=repress(Y,X,0.05)</p><p>回归系数:[1,2,3,4]—四个，分别对应b0,b1,b2,b3,<br>回归系数置信区间:[bint,rint]—四组，分别对应b0,b1,b2,b3<br>统计变量s:相关系数的平方R^2;假设检验统计量F;F对应的概率P;s^2的值。</p><p>最终得到方程y = b0 +b1<em>x1 +b2</em>x2 +b3*x3</p><h4 id="判断模型："><a href="#判断模型：" class="headerlink" title="判断模型："></a>判断模型：</h4><p>1）结果法：回归系数置信区间不包含零点的模型比较好。残差在零点附近比较好。<br>2）R法：R越靠近1，说明相关性越高。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>首先将y转置，再构建一个n+1列的矩阵X（x1,x2…,xn均转置，第一列为ones(n,1)）</p><h4 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">%输入数据</span><br><span class="line"></span><br><span class="line">x1 = [3.5,5.3,5.1,5.8,4.2,6.0,6.8,5.5,3.1,7.2,4.5,4.9,8.0,6.5,6.6,3.7,6.2,7.0,4.0,4.5,5.9,5.6,4.8,3.9];</span><br><span class="line">x2 = [9,20,18,33,31,13,25,30,5,47,25,11,23,35,39,21,7,40,35,23,33,27,34,15];</span><br><span class="line">x3 = [6.1,6.4,7.4,6.7,7.5,5.9,6.0,4.0,5.8,8.3,5.0,6.4,7.6,7.0,5.0,4.4,5.5,7.0,6.0,3.5,4.9,4.3,8.0,5.8];</span><br><span class="line">y = [33.2,40.3,38.7,46.8,41.4,37.5,39.0,40.7,30.1,52.9,38.2,31.8,43.3,44.1,42.5,33.6,34.2,48.0,38.0,35.9,40.4,36.8,45.2,35.1];</span><br><span class="line"></span><br><span class="line">%绘制散点图</span><br><span class="line"></span><br><span class="line">plot(x1,y,&apos;b*&apos;)</span><br><span class="line">hold on</span><br><span class="line">plot(x2,y,&apos;ro&apos;)</span><br><span class="line">hold on</span><br><span class="line">plot(x3,y,&apos;g+&apos;)</span><br><span class="line">hold on</span><br><span class="line"></span><br><span class="line">%进行拟合</span><br><span class="line"></span><br><span class="line">n = 24;</span><br><span class="line">X = [ones(n,1),x1&apos;,x2&apos;,x3&apos;];</span><br><span class="line">Y = y&apos;;</span><br><span class="line">[b,bint,r,rint,s] = regress(Y,X,0.05)</span><br><span class="line"></span><br><span class="line">%写出表达式</span><br><span class="line"></span><br><span class="line">y1 = b(1)+ b(2)*x1 +b(3)*x2 +b(4)*x3</span><br></pre></td></tr></table></figure><h2 id="逐步回归"><a href="#逐步回归" class="headerlink" title="逐步回归"></a>逐步回归</h2><p>调用stepwise(X,Y,0.05,0.1)函数<br>X是由x1，x2…xn组成的，x1，x2…xn的第一个元素组成第一行，第二个组成第二行…<br>然后得到逐步回归窗口点击 Next Step 直至变成灰色，表明逐步回归结束，得到最终的回归模型。</p><h2 id="logistic回归"><a href="#logistic回归" class="headerlink" title="logistic回归"></a>logistic回归</h2><p>搞不懂，大概是输入一组数据，判断是0是1。</p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">[~,~,raw] = xlsread(&apos;Logistic.xlsx&apos;,&apos;sheet1&apos;,&apos;A2:F26&apos;);</span><br><span class="line">data = reshape([raw&#123;:&#125;],size(raw));</span><br><span class="line"></span><br><span class="line">X0 = xlsread(&apos;Logistic.xlsx&apos;,&apos;B2:D21&apos;);</span><br><span class="line">Y0 = xlsread(&apos;Logistic.xlsx&apos;,&apos;E2:E21&apos;);</span><br><span class="line">X1 = xlsread(&apos;Logistic.xlsx&apos;,&apos;B2:D26&apos;);</span><br><span class="line">%logistic函数</span><br><span class="line">GM = fitglm(X0,Y0,&apos;Distribution&apos;,&apos;binomial&apos;);</span><br><span class="line">Y1 = predict(GM,X1);</span><br><span class="line">%模型评估</span><br><span class="line">N0 = 1:size(Y0,1);N1 = 1:size(Y1,1);</span><br><span class="line">hold on</span><br><span class="line">scatter(N1&apos;,Y1,&apos;b&apos;);</span><br><span class="line">plot(N0&apos;,Y0,&apos;-kd&apos;);</span><br><span class="line">xlabel(&apos;数据点编号&apos;);</span><br><span class="line">ylabel(&apos;输出值&apos;);</span><br></pre></td></tr></table></figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1）判断变量个数：一个用一元回归，超过两个用多元回归。<br>2）如果一元，判断是否线性；如果多元，先拟合，再检验效果。</p><h1 id="第三篇—全局最优解"><a href="#第三篇—全局最优解" class="headerlink" title="第三篇—全局最优解"></a>第三篇—全局最优解</h1><h2 id="蒙特卡洛算法"><a href="#蒙特卡洛算法" class="headerlink" title="蒙特卡洛算法"></a>蒙特卡洛算法</h2><ol><li>举个例子，假如筐里有100个苹果，让我每次闭眼拿1个，挑出最大的。于是我随机拿1个，再随机拿1个跟它比，留下大的，再随机拿1个……我每拿一次，留下的苹果都至少不比上次的小。拿的次数越多，挑出的苹果就越大，但我除非拿100次，否则无法肯定挑出了最大的。这个挑苹果的算法，就属于蒙特卡罗算法——尽量找好的，但不保证是最好的。</li><li>随机算法，在采样不全时，通常不能保证找到最优解，只能说是尽量找。</li><li>由此知：蒙特卡洛算法是一种尽量找最优解的方法。<br>数值计算方法<br>1）作用：</li><li>用于计算：<br>计算圆周率：<br>设有一个正方形，正方形中间有一个内切圆，他们的面积之比为Pi/4。<br>在这个正方形内部生成10000个点，计算他们与圆心之间的距离，从而判断点是否落在圆内。如果这些点均匀分布，则落在圆内的点应占所有点的pi/4，因此将圆内点/所有点的值乘4，就是pi的值。<br><img src="https://i.imgur.com/U8jmGs2.png" alt></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%蒙特卡洛算法估计圆周率</span><br><span class="line">n = input(&apos;请输入n:&apos;);</span><br><span class="line">m = 0;</span><br><span class="line">a = 2;      %半径为2</span><br><span class="line"></span><br><span class="line">for i=1:n</span><br><span class="line">    x = rand * a/2;</span><br><span class="line">    y = rand * a/2;</span><br><span class="line">    if(x^2+y^2&lt;=(a/2)^2)</span><br><span class="line">        m = m+1;        %落入圆中的点数</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">fprintf(&apos;pi = %d\n&apos;,4*m/n)</span><br></pre></td></tr></table></figure><ol start="2"><li>用于模拟系统内部的随机运动。<br>模拟单车道交通堵塞<br>根据 Nagel-Schreckenberg 模型，车辆的运动满足以下规则。</li></ol><ul><li>当前速度是 v 。</li><li>如果前面没车，它在下一秒的速度会提高到 v + 1 ，直到达到规定的最高限速。</li><li>如果前面有车，距离为d，且 d &lt; v，那么它在下一秒的速度会降低到 d - 1 。</li><li>此外，司机还会以概率 p 随机减速， 将下一秒的速度降低到 v - 1 。</li></ul><p>在一条直线上，随机产生100个点，代表道路上的100辆车，另取概率p为0.3 。<br>横轴代表距离（从左到右），纵轴代表时间（从上到下），因此每一行就表示下一秒的道路情况。<br>该模型会随机产生交通拥堵。这就证明了，单车道即使没有任何原因，也会产生交通堵塞。</p><h2 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h2><p>上述的蒙特卡洛算法为本节中实例的一小部分，因此提前简要介绍。一下。<br>模拟退火算法为一种现代优化算法，用来求解全局最小（最优）解<br>模拟退火法：<br>核心原理：当材料从状态i进入状态j时，若E(j)&lt;=E(i),状态会被转移（E(i)=E(j)）;若为其他情况，状态会以小概率被转移。也就是说，模拟退火法是一个不断寻找新解和缓慢降温交替的过程。<br>具体实现：</p><ol><li>优化函数 f(x)。</li><li>初始温度，初始解x0。</li><li>根据初始温度，初始解，生成下一个解x2。</li><li>判断f(x2)与f(x0)的关系，并根据核心原理进行判断、取值。、</li><li>根据规定的每一个温度结束的标志，判断是否需要降温</li><li>返回第三步</li></ol><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="https://i.imgur.com/2gw4akc.png" alt></p><h3 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h3><p>求解TSP问题<br>例:有100个目标，需要找出巡航最优路径。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">clc,clear</span><br><span class="line"></span><br><span class="line">%导入数据部分</span><br><span class="line"></span><br><span class="line">[~,~,raw] = xlsread(&apos;sj.xlsx&apos;,&apos;Sheet1&apos;,&apos;A2:H26&apos;);</span><br><span class="line">sj0 = reshape([raw&#123;:&#125;],size(raw)); %将raw&#123;:&#125;重构成原来尺寸的矩阵</span><br><span class="line">x = sj0(:,[1:2:8]);     %将数据中的经度部分存储在x矩阵中</span><br><span class="line">x = x(:);               %将x（四列）转为一列</span><br><span class="line">y = sj0(:,[2:2:8]);     %将数据中的纬度部分存储在y矩阵中</span><br><span class="line">y = y(:);               %将y（四列）转为一列</span><br><span class="line"></span><br><span class="line">%对数据进行处理的部分</span><br><span class="line"></span><br><span class="line">sj = [x y];             %将xy矩阵合成，sj中第一列为x；sj中第二列为y</span><br><span class="line">d1 = [70,40];           %将基地位置存储进去</span><br><span class="line">sj = [d1;sj;d1];        %将基地存储入数据中,都整合成两列</span><br><span class="line">sj = sj*pi/180;         %将角度转为弧度制（计算距离时，位置坐标被当作角度计算）</span><br><span class="line"></span><br><span class="line">%创建距离公式，距离存储矩阵（用于存储两个点之间的距离）</span><br><span class="line"></span><br><span class="line">d = zeros(102);         %创建距离矩阵</span><br><span class="line">for i = 1:101</span><br><span class="line">    for j = i+1:102</span><br><span class="line">        d(i,j) = 6370*acos(cos(sj(i,1)-sj(j,1))*cos(sj(i,2))*cos(sj(j,2))+sin(sj(i,2))*sin(sj(i,2))*sin(sj(j,2)));</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">d =d +d&apos;;</span><br><span class="line"></span><br><span class="line">path = [];              %创建用于存储路径的矩阵</span><br><span class="line">long = inf;             %初始化距离变量（inf为正无穷）</span><br><span class="line">rand(&apos;state&apos;,sum(clock));           %初始化随机数发生器，这种写法的作用：是每一次初始值不同，避免出现相同数字</span><br><span class="line"></span><br><span class="line">%蒙特卡洛算法部分，为了得到更好的初始值，先用蒙特卡洛法求解相对较好的解</span><br><span class="line"></span><br><span class="line">for j=1:1000            %随机产生一千种解</span><br><span class="line">    path0 = [1,1+randperm(100),102];%解的情况</span><br><span class="line">    temp =0;</span><br><span class="line">    %求解每种情况对应的距离值</span><br><span class="line"></span><br><span class="line">    for i=1:101         %通过循环，解得该情况下的距离</span><br><span class="line">        temp = temp + d(path0(i)+path0(i+1));</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %对每种情况进行比较，得到最优（小）解</span><br><span class="line"></span><br><span class="line">    if temp&lt;long</span><br><span class="line">        path = path0;</span><br><span class="line">        long =temp;</span><br><span class="line">        long</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%模拟退火法部分</span><br><span class="line">e = 0.1^30;     %结束条件</span><br><span class="line">L = 20000;      %迭代次数（解空间的大小）</span><br><span class="line">at = 0.999;     %执行一次的降温比例</span><br><span class="line">T = 1;          %初始温度</span><br><span class="line">for k =1:L</span><br><span class="line">    c = 2+floor(100*rand(1,2));</span><br><span class="line">    %另c取20000次大于2的值；其中c是一个一行二列的矩阵，rand产生一行二列的元素大于0小于1的随机数矩阵</span><br><span class="line">    c = sort(c);        %对c的元素进行升序排列</span><br><span class="line">    c1 = c(1);c2=c(2);</span><br><span class="line">    df = d(path(c1-1),path(c2))+d(path(c1),path(c2+1)) - d(path(c1-1),path(c1))-d(path(c2),path(c2+1));</span><br><span class="line">    %判断两组不相邻的两个点的具体是否小于两组相邻两个点之间的距离</span><br><span class="line">    if df&lt;0</span><br><span class="line">        path = [path(1:c1-1),path(c2:-1:c1),path(c2+1:102)]; long = long+df;</span><br><span class="line">        %如果新解距离小于原来解，则进行替换</span><br><span class="line">    elseif exp(-df/T) &gt;= rand</span><br><span class="line">        path = [path(1:c1-1),path(c2:-1:c1),path(c2+1:102)]; long = long+df;</span><br><span class="line">        %以这个极小的概率，进行替换</span><br><span class="line">    end</span><br><span class="line">    T = T*at;</span><br><span class="line">    if T&lt;e</span><br><span class="line">        break;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%输出部分</span><br><span class="line"></span><br><span class="line">path;</span><br><span class="line">long;</span><br><span class="line">xx = sj(path,1);</span><br><span class="line">yy = sj(path,2);</span><br><span class="line">figure</span><br><span class="line">plot(xx,yy,&apos;- *&apos;)</span><br><span class="line">legend(&apos;巡航最优路径&apos;)</span><br><span class="line">figure</span><br><span class="line">plot(xx,yy,&apos;ro&apos;)</span><br><span class="line">legend(&apos;巡航点位置&apos;)</span><br></pre></td></tr></table></figure><h3 id="实现效果-2"><a href="#实现效果-2" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://i.imgur.com/Fe8WKHJ.jpg" alt></p><h3 id="模拟退火法模板"><a href="#模拟退火法模板" class="headerlink" title="模拟退火法模板"></a>模拟退火法模板</h3><p>依据上述程序改动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">%模拟退火法部分</span><br><span class="line">e =   ;     %结束条件（到该温度终止）</span><br><span class="line">L =   ;     %迭代次数（解空间的大小）</span><br><span class="line">at =  ;     %执行一次的降温比例</span><br><span class="line">T =   ;     %初始温度</span><br><span class="line">for k =1:L</span><br><span class="line">%&#123;</span><br><span class="line"></span><br><span class="line">计算新解的代价</span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line">    </span><br><span class="line">    if %取新解的条件（新解的代价需要满足的条件）</span><br><span class="line">        </span><br><span class="line">    %&#123;</span><br><span class="line">满足条件，进行替换</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">    elseif exp(-df/T) &gt;= rand%不满足条件且被替换的概率</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">发生这个概率的事件，进行替换</span><br><span class="line">&#125;%</span><br><span class="line">    </span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    T = T*at;%每次进行降温</span><br><span class="line">    if T&lt;e%达到目标温度，结束模拟退火法</span><br><span class="line">        break;</span><br><span class="line">    end</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好好学习Matlab。&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>PID学习笔记</title>
    <link href="http://linmushen.com/2019/08/13/PID%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/08/13/PID学习笔记/</id>
    <published>2019-08-13T06:38:03.000Z</published>
    <updated>2019-08-18T16:13:04.306Z</updated>
    
    <content type="html"><![CDATA[<p>潜心学习技术，最近发现了一篇比较好的介绍PID的文章。学习并记录一下。<br><a id="more"></a><br>PID控制是对偏差进行比例，积分和微分的控制。PID由三个单元组成，分别是比例单元，积分单元，微分单元。</p><h1 id="位置闭环控制"><a href="#位置闭环控制" class="headerlink" title="位置闭环控制"></a>位置闭环控制</h1><h2 id="PID简介"><a href="#PID简介" class="headerlink" title="PID简介"></a>PID简介</h2><p>位置闭环控制是根据编码器的脉冲累加测量电机的位置信息，并与目标值进行比较，进而得到控制偏差，然后对偏差进行比例、积分、微分进行控制。使偏差趋近于0。</p><h2 id="PID理论知识"><a href="#PID理论知识" class="headerlink" title="PID理论知识"></a>PID理论知识</h2><p>1）PID公式<br><img src="https://i.imgur.com/j5YKEuO.png" alt><br>2）符号含义<br><img src="https://i.imgur.com/ICGUcUc.png" alt></p><h2 id="控制原理"><a href="#控制原理" class="headerlink" title="控制原理"></a>控制原理</h2><p><img src="https://i.imgur.com/JJfTRfg.png" alt><br>其中PID控制器，是一个软件实现过程（比如程序里的一个函数）。</p><h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><p>通过改变KP,KI,KD的值实现调参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int Position_PID(int Encoder,int Targe)//入口参数为位置测量值和位置目标值</span><br><span class="line">&#123;</span><br><span class="line">Static float Bias,Pwm,Integral_bias,Last_Bias;  </span><br><span class="line">Bias = Encoder-Target;//计算偏差</span><br><span class="line">Interal_bias+=Bias;//用累加法，求出偏差的积分</span><br><span class="line">Pwm=Position_KP*Bias+Position_KI*Integral_bias+Position_KD*(Bias-Last_Bias);//根据PID计算Pwm输出值</span><br><span class="line">Last_Bias=Bias;//保存上一次偏差</span><br><span class="line">return Pwm;//返回Pwm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在中断服务函数中调用这个函数并将输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PWM = Position_PID(Encoder,Targe)</span><br></pre></td></tr></table></figure></p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>1）稳定性：主要评估指标为最大超调量，最大超调量是指响应曲线的最大峰值与稳态值的差。<br>2）快速性：主要评估指标为上升时间，上升时间是指响应工作状态从原始工作状态出发，第一次到达输出稳定值所需要的时间，是评估系统快速性的一个重要指标。<br>3）准确性：主要评估指标为静差，静差是被控制量与给定值之差，一般用于衡量系统的准确性。<img src="https://i.imgur.com/5tp9brf.png" alt></p><h2 id="调参注意事项"><a href="#调参注意事项" class="headerlink" title="调参注意事项"></a>调参注意事项</h2><p>P：用于提高响应速度。<br>I：用于减小静差。<br>D：用于抑制震荡。<br>一般调参时，先将I值和D值设置为0，然后把P值从0逐渐增大，直到系统震荡。<br>静差一般是在P值较小，且I值为0的时候出现的。所以增大P值可以一定程度上的消除静差，提高响应速度，但会导致系统震荡。<br>加入D值后，震荡得到抑制，但响应速度变慢了。<br>所以一般调节经验可以总结为：先只P控制，增大P直至系统震荡之后加入D控制，消除一点震荡后，再次调节P和I参数。<br>控制难度取决于系统转动惯量和对相应速度的要求。转动惯量越小，对相应速度要求越低，PID参数就越不敏感。</p><h1 id="速度闭环控制"><a href="#速度闭环控制" class="headerlink" title="速度闭环控制"></a>速度闭环控制</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;潜心学习技术，最近发现了一篇比较好的介绍PID的文章。学习并记录一下。&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>破解论文</title>
    <link href="http://linmushen.com/2019/08/12/%E7%A0%B4%E8%A7%A3%E8%AE%BA%E6%96%87/"/>
    <id>http://linmushen.com/2019/08/12/破解论文/</id>
    <published>2019-08-12T01:58:55.000Z</published>
    <updated>2019-08-21T08:59:47.686Z</updated>
    
    <content type="html"><![CDATA[<p>为了准备数学建模竞赛，力求在假期剩余的十几天中，破解七篇优秀论文。<br><a id="more"></a></p><p>使用软件：Excel、作图软件origin、Visio、SPSS、matlab</p><p>论文写作：</p><ol><li>论文在20-25页左右，加上附录也不要超过40页。</li><li>用专业的visio绘图，效果更好。</li></ol><p>题型分布：</p><ol><li>A题需要强大的工科、物理学背景，需要比较好的数学基础、查阅论文能力。一般考察建模同学实力，完全自主建模，然后matlab实现</li><li>B题社会性比较强，偏于统计学方法，相对入手简单，好做。</li></ol><h1 id="第一篇优秀论文"><a href="#第一篇优秀论文" class="headerlink" title="第一篇优秀论文"></a>第一篇优秀论文</h1><h2 id="模型一部分"><a href="#模型一部分" class="headerlink" title="模型一部分"></a>模型一部分</h2><h3 id="模型准备"><a href="#模型准备" class="headerlink" title="模型准备"></a>模型准备</h3><p>建立坐标系，为各个结构件命名。<br>（以锚和锚链的交点为原点，建立坐标系；将各个结构件从上至下命名为P1~P267）</p><h3 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h3><p>1）对有关结构件进行受力分析，得到各个力之间的方程（模型）。<br>2）确定约束条件（水的深度；吃水深与各个结构件的投影之和等于水的深度）。<br>3）最后要将所有的到的方程汇总写在一起。<br><img src="https://i.imgur.com/HAsNEAC.png" alt></p><h3 id="模型修正"><a href="#模型修正" class="headerlink" title="模型修正"></a>模型修正</h3><p>对特殊情况予以考虑，并得到修正方程（修正模型）。<br>（是否有铁链沉底）。</p><h3 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h3><p>共有两个变量吃水深h以及各个角度Ai。<br>1）将多目标非线性方程（在第二步中汇总的方程）转换为单目标非线性方程（利用角度与吃水深之间的递推关系）。<br>2）将连续型的变量h转化为离散型的（通过规定步长（步长就是累加的数））。<br>3）计算每一个解，由于最优解等于最大的h（h&lt;=2），计算出满足h&lt;=2的最大h即为最优解。<br><img src="https://i.imgur.com/dRzGAao.png" alt><br>4）算法精度检验（暂时不懂）。</p><h2 id="Matlab程序"><a href="#Matlab程序" class="headerlink" title="Matlab程序"></a>Matlab程序</h2><p>当存在一个变量在多个地方有意义时，应该使用矩阵<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">mq = 1200;%重物球质量</span><br><span class="line">n = 210;%锚链数量（22.5/锚链直径）</span><br><span class="line">min = inf;%实际水深和计算得到的水的深度的差值</span><br><span class="line">minh = 0;%修正时目前的计算得到的吃水深</span><br><span class="line">minH = 0;%修正时目前得到的水深（由吃水深度+投影得到的，但不到18m，因此需要修正）</span><br><span class="line">minbeta = 0;%修正时目前的铁桶与竖直方向的夹角。</span><br><span class="line">minthital1 = zeros(1,4);%修正时目前的钢管与竖直方向的夹角。</span><br><span class="line">minthital2 = zeros(1,n)+pi/2;%修正时目前的锚链与竖直方向的夹角的修正办法。</span><br><span class="line">minFt2 = zeros(1,n+1);%创建一个一行211列的零矩阵（）</span><br><span class="line"></span><br><span class="line">for h= 0 : 0.0001 : 2%h从0开始，每次运行完结构内容后加0.0001，一直到2。</span><br><span class="line"></span><br><span class="line">Ft = zeros(1,5);%各钢管、浮标之间的拉力</span><br><span class="line">alpha = zeros(1,5);%各钢管、浮标之间的角度</span><br><span class="line">thital1 = zeros(1,4);%各钢管与竖直方向的夹角</span><br><span class="line">beta = 0；%钢桶与竖直方向夹角</span><br><span class="line">Ft2 = zeros(1,n+1); %各锚链之间的力</span><br><span class="line">gama = zeros(1,n+1);%各锚链之间的夹角</span><br><span class="line">thital2 = zeros(1,n);%各锚链与竖直方向的夹角</span><br><span class="line"></span><br><span class="line">%&#123;以下为浮标部分&#125;%</span><br><span class="line"></span><br><span class="line">v = 24;%风速=24</span><br><span class="line">S = 2*(2-h);%浮标没有没入水中部分的横截面积</span><br><span class="line">m = 1000;%浮标质量为1000kg</span><br><span class="line">rou = 1025; %水的密度</span><br><span class="line">g = 9.8；%重力加速度</span><br><span class="line">V = pi*1^2*h;%体积 = (pi*d^2*h)/4;d^2 = 4</span><br><span class="line">Ffeng = 0.625*S*v^2;%由公式：Ffeng = 0.625*横截面积*风速^2</span><br><span class="line">Ffu = rou*g*V;%浮标浮力</span><br><span class="line">G = m*g;%浮标重力</span><br><span class="line"></span><br><span class="line">if Ffu - G &lt; 0</span><br><span class="line">continue;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">alpha(1) = atan(Ffeng/(Ffu-G));%根据建立的模型，解得浮标与第一个钢管之间的角度</span><br><span class="line">Ft(1) = sqrt(Ffeng^2+(Ffu-Gfu)^2);%根据之前建立的模型，解得浮标与第一个钢管之间的拉力</span><br><span class="line"></span><br><span class="line">%&#123;以下为钢管部分&#125;%</span><br><span class="line"></span><br><span class="line">Vg = 1*pi*0.025^2;%钢管的体积</span><br><span class="line">Ggang = 10*g;%钢管的质量</span><br><span class="line">Fgfu = rou*g*Vg;%钢管的浮力</span><br><span class="line">for i=1:4</span><br><span class="line">alpha(i+1) = atan(Ft(i)*sin(alpha(i))/(Ft(i)*cos(alpha(i))+Fgfu-Ggang));%根据之前得到的模型，分别计算出四个钢管的之间的角度</span><br><span class="line">Ft(i+1) = Ft(i)*sin(alpha(i+1));thital1(i) = atan(Ft(i)*sin(alpha(i))*1/(Fgfu-Ggang)*1/2+Ft(i)*cos(alpha(i))));%根据之前建立的模型，分别计算出来四个钢管之间的作用力</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%&#123;以下是钢桶部分&#125;%</span><br><span class="line"></span><br><span class="line">Vt = 1*pi*0.15^2;%钢桶的体积（钢桶直径为30cm）</span><br><span class="line">Vq = mq/7800;%重物球的体积（由于本题中球的半径没有给出，因此，用铁道密度代指球的密度，用球的质量比球的体积，进而得到球的体积）</span><br><span class="line">Gt = 100*g;%钢桶的重量</span><br><span class="line">Gq = mq*g;%重物球的重量</span><br><span class="line">Ftfu = rou*g*Vt;%桶收到的浮力</span><br><span class="line">Fqfu = rpu*g*Vq;%球受到的浮力</span><br><span class="line"></span><br><span class="line">gama(1) = atan(Ft(5)*sin(alpha(5))/(Ftfu+Ft(5)*cos(alpha(5))-Gt-Gq+Fqfu));</span><br><span class="line">%根据之前得到的模型，计算第一个锚链与钢桶的夹角</span><br><span class="line">bata = atan(Ft(5)*sin(alpha(5)*1/(Ftfu-Gt)*1/2+Ft(5)*cos(alpha(5))*1));%根据之前得到的模型，计算出钢桶与竖直夹角</span><br><span class="line"></span><br><span class="line">%&#123;以下是锚链部分&#125;%</span><br><span class="line"></span><br><span class="line">mm = 0.735;%锚链的质量（查阅资料得到）</span><br><span class="line">roum = 6450;%锚链的密度（查阅资料得到）</span><br><span class="line">Vm = mm/roum;%锚链的体积</span><br><span class="line">Fmfu = rou*g*Vm;%锚链收到的浮力</span><br><span class="line">Gm = mm*g;%锚链受到的重力</span><br><span class="line">Lm = 0.105;%一节锚链的长度（22.05/210得到）</span><br><span class="line"></span><br><span class="line">for i=1:n</span><br><span class="line">gama(i+1)=atan(Ft2(i)*sin(gama(i))/(Ft(i)*cos(gama(i))+Fmfu - Gm));%根据之前得到的模型，计算出每个锚链之间的夹角。</span><br><span class="line"></span><br><span class="line">if gama(i+1)&lt;0%如果夹角小于0，则加派。</span><br><span class="line"></span><br><span class="line">gama(i+1) = gama(i+1)+pi</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Ft2(i+1) = Ft2(i)*sin(gama(i))/sin(gama(i+1));%根据模型，得到各个锚链之间的作用力。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thital2(i) = atan(Ft2(i)*sin(gama(i))*Lm/((Fmfu-Gm)*Lm/2+Ft2(i)*cos(gama(i))*Lm));%根据模型，计算得到每个锚链与竖直方向的夹角。</span><br><span class="line"></span><br><span class="line">if thital2(i)&lt;0%如果夹角小于0，则加派</span><br><span class="line"></span><br><span class="line">thital=thital+pi;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">H = h+1*sum(cos(thital1))+1*cos(beta)+Lm*sum(cos(thital2))%构建几何约束条件，其中sum()为求和函数。</span><br><span class="line"></span><br><span class="line">%&#123;当出现有铁链沉底的情况，需要进行修正&#125;%</span><br><span class="line"></span><br><span class="line">if abs(H-18)&lt;min</span><br><span class="line">minh = h;</span><br><span class="line">min = abs(H-18);</span><br><span class="line">minH = H ;</span><br><span class="line">minthita1 = thita1;</span><br><span class="line">minthita2 = thita2;</span><br><span class="line">minbeta = beta;</span><br><span class="line">minFt2 = Ft2;</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h2 id="模型二部分"><a href="#模型二部分" class="headerlink" title="模型二部分"></a>模型二部分</h2><h3 id="模型准备-1"><a href="#模型准备-1" class="headerlink" title="模型准备"></a>模型准备</h3><p>根据问题一的模型，求解当前风速（36m/s）时的各系统参数（钢管、浮标、吃水深度）。<br>然后根据问题一的模型，将钢桶倾斜角和锚链在锚点处的夹角，计算得到重物球重量范围。</p><h3 id="模型建立-1"><a href="#模型建立-1" class="headerlink" title="模型建立"></a>模型建立</h3><p>1）确定决策变量（决策变量等同于因变量，这个因变量有一定范围）—-本题中的重物球重量。<br>2）确定目标变量（目标变量等同于要求解的变量，等同于自变量）—-本题中有三个自变量（钢桶倾斜角、浮标吃水深度、浮标游动区域）。<br>3）确定约束变量（约束条件一般由题目已知条件）—-本题中锚点210与竖直方向夹角小于16度和钢桶倾斜角小于5度。</p><h3 id="模型建立-2"><a href="#模型建立-2" class="headerlink" title="模型建立"></a>模型建立</h3><p><img src="https://i.imgur.com/7Ns9n2x.png" alt></p><h3 id="模型求解-1"><a href="#模型求解-1" class="headerlink" title="模型求解"></a>模型求解</h3><p>求解方法还是循环搜索算法，但重物球有重量上下范围，同样需要设置步长。<br>先将最开始计算得到参数值带入，从重量球最小值开始带入，计算得到U，每次计算重量球重量球加步长，最后当达到最大值时，输出U。</p><h3 id="灵敏性分析"><a href="#灵敏性分析" class="headerlink" title="灵敏性分析"></a>灵敏性分析</h3><p>灵敏性—决策变量对每一个优化目标的影响（画图），最终得到结论，重量球重量对浮标游动、吃水深影响较小；对钢桶倾角影响大。<br><img src="https://i.imgur.com/FaUHj7H.png" alt></p><h2 id="Matlab程序-1"><a href="#Matlab程序-1" class="headerlink" title="Matlab程序"></a>Matlab程序</h2><p>function [y1,…,yN] = myfun(x1,…,xM) 声明名为 myfun 的函数，该函数接受输入 x1,…,xM 并返回输出 y1,…,yN。此声明语句必须是函数的第一个可执行代码行。有效的函数名称以字母字符开头，并且可以包含字母、数字或下划线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">n=210;%锚链数目</span><br><span class="line"></span><br><span class="line">%&#123;创建几个用于存放数据的矩阵&#125;%</span><br><span class="line"></span><br><span class="line">kxmq=[];</span><br><span class="line">kxh=[];</span><br><span class="line">kxr=[];</span><br><span class="line">kxbeta=[];</span><br><span class="line">zfenshu=[];</span><br><span class="line"></span><br><span class="line">%&#123;开始搜索法，求出每一个mq对应的值&#125;%</span><br><span class="line"></span><br><span class="line">for mq=1800:4100</span><br><span class="line">mq%输出mq</span><br><span class="line">min = inf;%最小值，用于存放实际水深（18m）和计算得到的水深的差值。</span><br><span class="line">minh = 0;%得到的最小吃水深度。</span><br><span class="line">minH = 0;%根据最小吃水深度得到的计算水深。</span><br><span class="line">minbeta = 0;%得到的钢桶最小夹角。</span><br><span class="line">minthita1 = zeros(1,4);%浮标、钢管之间的夹角。</span><br><span class="line">minthita2 = zeros(1,n);%锚链、铁桶之间的夹角。</span><br><span class="line">minFt2 = zeros(1,n+1);%锚链、铁桶、锚之间的拉力。</span><br><span class="line"></span><br><span class="line">for h= 0 : 0.0001 : 2       %h从0开始，每次运行完结构内容后加0.0001，一直到2。</span><br><span class="line"></span><br><span class="line">    Ft = zeros(1,5);    %各钢管、浮标之间的拉力</span><br><span class="line">    alpha = zeros(1,5); %各钢管、浮标之间的角度</span><br><span class="line">    thital1 = zeros(1,4);   %各钢管与竖直方向的夹角</span><br><span class="line">    beta = 0；           %钢桶与竖直方向夹角</span><br><span class="line">    Ft2 = zeros(1,n+1); %各锚链之间的力</span><br><span class="line">    gama = zeros(1,n+1);%各锚链之间的夹角</span><br><span class="line">    thital2 = zeros(1,n);   %各锚链与竖直方向的夹角</span><br><span class="line"></span><br><span class="line">    %&#123;以下为浮标部分&#125;%</span><br><span class="line"></span><br><span class="line">    v = 24;     %风速=24</span><br><span class="line">    S = 2*(2-h);%浮标没有没入水中部分的横截面积</span><br><span class="line">    m = 1000;   %浮标质量为1000kg</span><br><span class="line">    rou = 1025; %水的密度</span><br><span class="line">    g = 9.8；    %重力加速度</span><br><span class="line">    V = pi*1^2*h;   %体积 = (pi*d^2*h)/4;d^2 = 4</span><br><span class="line">    Ffeng = 0.625*S*v^2;    %由公式：Ffeng = 0.625*横截面积*风速^2</span><br><span class="line">    Ffu = rou*g*V;  %浮标浮力</span><br><span class="line">    G = m*g;        %浮标重力</span><br><span class="line"></span><br><span class="line">    if Ffu - G &lt; 0</span><br><span class="line">        continue;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    alpha(1) = atan(Ffeng/(Ffu-G));     %根据建立的模型，解得浮标与第一个钢管之间的角度</span><br><span class="line">    Ft(1) = sqrt(Ffeng^2+(Ffu-Gfu)^2);  %根据之前建立的模型，解得浮标与第一个钢管之间的拉力</span><br><span class="line"></span><br><span class="line">    %&#123;以下为钢管部分&#125;%</span><br><span class="line"></span><br><span class="line">    Vg = 1*pi*0.025^2;  %钢管的体积</span><br><span class="line">    Ggang = 10*g;       %钢管的质量</span><br><span class="line">    Fgfu = rou*g*Vg;    %钢管的浮力</span><br><span class="line">    for i=1:4</span><br><span class="line">        alpha(i+1) = atan(Ft(i)*sin(alpha(i))/(Ft(i)*cos(alpha(i))+Fgfu-Ggang));    %根据之前得到的模型，分别计算出四个钢管的之间的角度</span><br><span class="line">        Ft(i+1) = Ft(i)*sin(alpha(i+1));thital1(i) = atan(Ft(i)*sin(alpha(i))*1/(Fgfu-Ggang)*1/2+Ft(i)*cos(alpha(i))));     %根据之前建立的模型，分别计算出来四个钢管之间的作用力</span><br><span class="line">    end </span><br><span class="line"></span><br><span class="line">    %&#123;以下是钢桶部分&#125;%</span><br><span class="line"></span><br><span class="line">    Vt = 1*pi*0.15^2;   %钢桶的体积（钢桶直径为30cm）</span><br><span class="line">    Vq = mq/7800;       %重物球的体积（由于本题中球的半径没有给出，因此，用铁道密度代指球的密度，用球的质量比球的体积，进而得到球的体积）</span><br><span class="line">    Gt = 100*g;         %钢桶的重量</span><br><span class="line">    Gq = mq*g;          %重物球的重量</span><br><span class="line">    Ftfu = rou*g*Vt;    %桶收到的浮力</span><br><span class="line">    Fqfu = rpu*g*Vq;    %球受到的浮力</span><br><span class="line"></span><br><span class="line">    gama(1) = atan(Ft(5)*sin(alpha(5))/(Ftfu+Ft(5)*cos(alpha(5))-Gt-Gq+Fqfu));</span><br><span class="line">    %根据之前得到的模型，计算第一个锚链与钢桶的夹角</span><br><span class="line">    bata = atan(Ft(5)*sin(alpha(5)*1/(Ftfu-Gt)*1/2+Ft(5)*cos(alpha(5))*1)); %根据之前得到的模型，计算出钢桶与竖直夹角</span><br><span class="line"></span><br><span class="line">    %&#123;以下是锚链部分&#125;%</span><br><span class="line"></span><br><span class="line">    mm = 0.735;     %锚链的质量（查阅资料得到）</span><br><span class="line">    roum = 6450;    %锚链的密度（查阅资料得到）</span><br><span class="line">    Vm = mm/roum;   %锚链的体积</span><br><span class="line">    Fmfu = rou*g*Vm;%锚链收到的浮力</span><br><span class="line">    Gm = mm*g;      %锚链受到的重力</span><br><span class="line">    Lm = 0.105;     %一节锚链的长度（22.05/210得到）</span><br><span class="line"></span><br><span class="line">    for i=1:n</span><br><span class="line">        gama(i+1)=atan(Ft2(i)*sin(gama(i))/(Ft(i)*cos(gama(i))+Fmfu - Gm)); %根据之前得到的模型，计算出每个锚链之间的夹角。</span><br><span class="line"></span><br><span class="line">        if gama(i+1)&lt;0      %如果夹角小于0，则加派。</span><br><span class="line"></span><br><span class="line">            gama(i+1) = gama(i+1)+pi</span><br><span class="line"></span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        Ft2(i+1) = Ft2(i)*sin(gama(i))/sin(gama(i+1));  %根据模型，得到各个锚链之间的作用力。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thital2(i) = atan(Ft2(i)*sin(gama(i))*Lm/((Fmfu-Gm)*Lm/2+Ft2(i)*cos(gama(i))*Lm));      %根据模型，计算得到每个锚链与竖直方向的夹角。</span><br><span class="line"></span><br><span class="line">        if thital2(i)&lt;0     %如果夹角小于0，则加派</span><br><span class="line"></span><br><span class="line">            thital=thital+pi;</span><br><span class="line"></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    H = h+1*sum(cos(thital1))+1*cos(beta)+Lm*sum(cos(thital2))  %构建几何约束条件，其中sum()为求和函数。</span><br><span class="line"></span><br><span class="line">    %&#123;当出现有铁链沉底的情况，需要进行修正&#125;%</span><br><span class="line"></span><br><span class="line">    if abs(H-18)&lt;min    </span><br><span class="line">        minh = h;</span><br><span class="line">        min = abs(H-18);</span><br><span class="line">        minH = H ;</span><br><span class="line">        minthita1 = thita1;</span><br><span class="line">        minthita2 = thita2;</span><br><span class="line">        minbeta = beta;</span><br><span class="line">        minFt2 = Ft2;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%&#123;验证是否满足水深约束，不满足则调用修正函数&#125;%</span><br><span class="line"></span><br><span class="line">if minthia2(n)&gt;pi/2%大于90度，则说明沉底</span><br><span class="line"></span><br><span class="line">[r,minh,minbeta,minthita1,minthita2,minH] = tuodir(n,mq);%调用修正函数，得到新值</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">r = Lm*sum(sin(minthia2))+sum(sin(minbeta))+sum(sin(minthia1));</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%&#123;验证是否满足约束条件，不满足直接结束本次循环，进行下一次&#125;%</span><br><span class="line"></span><br><span class="line">if minthia*180/pi&gt;5</span><br><span class="line">continue;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if (90-minthia2(n)*180/pi)&gt;16;</span><br><span class="line">cintinue;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if abs(minH-18)&gt;0.2</span><br><span class="line">continue;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">kxmq = [kxmq,mq];</span><br><span class="line">kxh = [kxh,minh];</span><br><span class="line">kxbeta = [kxbeta,minbeta];</span><br><span class="line">kxr = [kxr,r];</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">[fenshu,i] = max(-zfenshu);%将矩阵中最优（U最大）的拿出来</span><br><span class="line">fenshu%打印出来</span><br><span class="line">kxmq(i)</span><br></pre></td></tr></table></figure></p><h1 id="第二遍优秀论文"><a href="#第二遍优秀论文" class="headerlink" title="第二遍优秀论文"></a>第二遍优秀论文</h1><p>除去摘要和问题重述，第一部分为问题分析。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="问题一分析"><a href="#问题一分析" class="headerlink" title="问题一分析"></a>问题一分析</h3><p>1）阐述问题：要求建立合理的指标，并分析出租车资源的匹配程度。<br>2）简述述解决问题的答案：建立了两个指标—里程利用率、供求比。<br>3）详述解决问题的方法：得到平衡点N(K<em>,n</em>)和实际点M(K,n)；通过归一化处理后，计算实际点与平衡点之间的距离，距离越大供求匹配度越低。</p><h3 id="问题二分析"><a href="#问题二分析" class="headerlink" title="问题二分析"></a>问题二分析</h3><p>1）阐述问题：要求分析各公司补贴办法是否有用。<br>2）简述解决问题的步骤：</p><ol><li>计算各公司对乘客、对司机的补贴金额。</li><li>设计意愿半径、软件使用人数来计算人均车辆占有率（有多少使用软件的人在司机的意愿半径内）。</li><li>通过人均车辆占有率来检测不同补贴效果。<h3 id="问题三分析"><a href="#问题三分析" class="headerlink" title="问题三分析"></a>问题三分析</h3>1）阐述问题：设计补贴方案并论证合理性。<br>2）简述解决办法</li></ol><h2 id="模型一部分-1"><a href="#模型一部分-1" class="headerlink" title="模型一部分"></a>模型一部分</h2><h3 id="模型准备—指标确立"><a href="#模型准备—指标确立" class="headerlink" title="模型准备—指标确立"></a>模型准备—指标确立</h3><p>1）里程利用率<br>公式：里程利用率K = 载客里程/行驶里程 *100%<br>指标意义：<br>K大—对司机：空驶率较低；对乘客—可供打的车不多。<br>K小—对司机：空驶率较高；对乘客—可供打的车较多。<br>因此，K存在一个平衡值。</p><p>2）供求比率<br>公式：供求比率n = 一定时间内某市场可供额的总和/相应的需求额总和 *100%<br>指标意义：<br>n&gt;1：供大于求。<br>n&lt;1：供小于求。<br>n=1：供等于求。<br>因此，n存在一个平衡值。</p><h3 id="模型建立—指标理想值确定"><a href="#模型建立—指标理想值确定" class="headerlink" title="模型建立—指标理想值确定"></a>模型建立—指标理想值确定</h3><p>1）里程利用率理想值<br>出租车总里程L；出租车载客总里程Ls；乘客需求里程Ld。<br>K = L/Ls；当Ls = Ld时，得到K的平衡值K*。</p><p>本题将L细分为：</p><ul><li>出租车保有量—N</li><li>主要时间段平均运营时间—T</li><li>出租车平均行驶速度—v</li><li>出租车出车率—a</li><li>主要时间段占全天运营时间的比例—b<br>L = TvNa/b</li></ul><p>本题将Ld细分为：</p><ul><li>人口总量—n</li><li>人均出行—o</li><li>出租车出行占所有出行方式的比例—p</li><li>每次出行的平均距离—d</li><li>出租车承担的人民出行周转量（旅客人数与其距离的乘积）—Q</li><li>平均每天乘出租车总人数—s<br>Ld = nopd/s</li></ul><p>得到理想值<br>Ld = Ls<br>最终得到 K* = nopdb/TNsva</p><p>2）供求比率理想值<br>需求订单量D，出租车数量S，n = S/D。<br>以每个人（每个订单）为圆心，以司机的意愿半径为半径，画圆。由于不同地方n的值差异较大，因此将大区域划分为n个小区域。<br>小区域分为三种</p><ul><li>供大于求,D1,n1</li><li>供小于求,D2,n2</li><li>供等于求,D3,n3<br>n = (D1/D)<em>n1+(D2/D)</em>n2+D3/(D*n3)—不是打错了，n3&lt;1，所以n3越大表示供求越平衡，所以需要改动。<br>n1&gt;1，所以n1越大表示供求越不平衡。</li></ul><p>得到理想值n = 1。</p><h3 id="模型建立-3"><a href="#模型建立-3" class="headerlink" title="模型建立"></a>模型建立</h3><p>此时得到了平衡点坐标N(K<em>,n</em>)和实际点M(K,n)，但不是关于原点的情况，不易于求解，因此通过<strong>归一化处理</strong>转化为关于原点的数据，点Q。<br>Q = (K-K<em>/K</em>,n<em>-n/n</em>)<br>综合不平衡度—Q到原点的距离r。</p><p><img src="https://i.imgur.com/vYLHcff.png" alt></p><h3 id="模型求解-2"><a href="#模型求解-2" class="headerlink" title="模型求解"></a>模型求解</h3><p>带入理想值需要的数据，求解得到K<em>，n</em>。<br>利用matlab仿真，得到K，n<br>并分别在时间角度、空间角度下，解得r。</p><h1 id="2018年B题"><a href="#2018年B题" class="headerlink" title="2018年B题"></a>2018年B题</h1><h2 id="对条件的推测"><a href="#对条件的推测" class="headerlink" title="对条件的推测"></a>对条件的推测</h2><p>一. 智能加工系统组成</p><ol><li>轨道车(RGV)可以自由移动，且有一个机械手臂，两只机械手爪，物料清洗槽。可以控制移动方向、移动距离。</li><li>RGV直线轨道共RGV自由移动。</li><li>8台计算机数控机床。</li><li>上料传送带、下料传送带。</li></ol><p>二. 推测工序</p><p>一道工序版：</p><ol><li>未加工的生料 放到 上料传送带。</li><li>RGV运动到物料位置，然后抓取到某一台CNC。</li><li>物料加工完成后，RGV用自带的物料清洗槽进行清洗。</li><li>清洗完成后放到下料传送带。</li></ol><p>两道工序版：</p><ol><li>未加工的生料 放到 上料传送带。</li><li>RGV运动到物料位置，然后抓取到某一台CNC。</li><li>物料加工完第一道工序后，RGV运动到该位置后，进行抓取，放到不同的CNC上。</li><li>物料加工完成后，RGV用自带的物料清洗槽进行清洗。</li><li>清洗完成后放到下料传送带。</li></ol><p>三. 问题假设</p><ol><li>假设输入指令无延迟，传送信号无延迟。</li><li>假设物料放置时间间隔相同（因为速度不变，所以间距相同）且无停顿。</li></ol><p>四. 大致方案<br>一道工序版：<br>RGV将物料就近放到CNC机床上，如果该机床在忙，则放到相对机床上，如果也在忙，则放到相邻机床上。</p><h2 id="对问题的分析"><a href="#对问题的分析" class="headerlink" title="对问题的分析"></a>对问题的分析</h2><p>任务1：对一般问题进行研究，给出RGV动态调度模型和相应的求解算法；<br>任务2：利用表1中系统作业参数的3组数据分别检验模型的实用性和算法的有效性，给出RGV的调度策略和系统的作业效率，并将具体的结果分别填入附件2的EXCEL表中。</p><p>问题一：<br>一般问题：一道工序、两道工序、出现故障的情况。</p><ol><li>放入1生料–&gt;RGV在CNC1处等待–&gt;物料1到达RGV位置处–&gt;RGV夹起，放入CNC1处</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了准备数学建模竞赛，力求在假期剩余的十几天中，破解七篇优秀论文。&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>OPENMV学习笔记</title>
    <link href="http://linmushen.com/2019/07/29/OPENMV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/07/29/OPENMV学习笔记/</id>
    <published>2019-07-29T11:07:59.000Z</published>
    <updated>2019-08-18T15:15:28.590Z</updated>
    
    <content type="html"><![CDATA[<p>本节根据星瞳科技的OPENMV<br><a id="more"></a></p><h1 id="OPENMV图像处理方法"><a href="#OPENMV图像处理方法" class="headerlink" title="OPENMV图像处理方法"></a>OPENMV图像处理方法</h1><h2 id="感光元件"><a href="#感光元件" class="headerlink" title="感光元件"></a>感光元件</h2><p>sensor模块，用于设置感光元件的参数。</p><blockquote><p>初始化：.resert()–初始化感光元件。<br>设置彩色/黑白：.set_pixformat(sensor.RGB565[彩色]/sensor.GARYSCALE[灰度])<br>设置图像大小：.set_framesize([A])</p><blockquote><p>其中A：sensor.QQVGA: 160x120<br>sensor.QQVGA2: 128x160 (用于 lcd 扩展板)<br>sensor.HQVGA: 240x160<br>sensor.QVGA: 320x240<br>sensor.VGA: 640x480 (只用于OpenMV Cam M7 的灰度图处理图像，或者彩图采集图像)<br>sensor.QQCIF: 88x72<br>sensor.QCIF: 176x144<br>sensor.CIF: 352x288</p></blockquote></blockquote><blockquote><p>跳过一些帧：.skip_frames(n=需要跳过的帧数,time=需要跳过的ms数)。<br>获取一张图象：.snapshot()，拍摄一张照片并返回一个image对象。<br>自动增益：.set_auto_gain(True/False)，使用颜色追踪时，需要关闭(False)自动增益。<br>白平衡：.set_auto_whitebat(True/False)，使用颜色追踪时，需要关闭(False)白平衡。<br>设置窗口ROI：.set_windowing(roi)，roi的格式是(x,y)，取中间的x*y区域。ROI为感兴趣区。<br>设置翻转：.set_hmirror(True)—水平方向翻转；.set_vflip(True)—垂直方向翻转。</p></blockquote><h1 id="图像的基本运算"><a href="#图像的基本运算" class="headerlink" title="图像的基本运算"></a>图像的基本运算</h1><h2 id="获取设置像素点-pixel"><a href="#获取设置像素点-pixel" class="headerlink" title="获取设置像素点(pixel)"></a>获取设置像素点(pixel)</h2><ol><li>image.get_pixel(x,y):返回image中(x,y)处的像素值（若为灰度图，返回灰度值；若为彩色图，返回RGB 的元组）。</li><li>image.set_pixel(x,y):设置image中(x,y)处的像素值（若为灰度图，设置灰度值；若为彩色图，设置(R,G,B)的值。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节根据星瞳科技的OPENMV&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>stm32学习笔记</title>
    <link href="http://linmushen.com/2019/07/18/stm32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/07/18/stm32学习笔记/</id>
    <published>2019-07-18T13:22:17.000Z</published>
    <updated>2019-08-18T16:13:04.307Z</updated>
    
    <content type="html"><![CDATA[<p>有关STM32知识的笔记<br><a id="more"></a></p><h1 id="关于MDK5的几个使用技巧"><a href="#关于MDK5的几个使用技巧" class="headerlink" title="关于MDK5的几个使用技巧"></a>关于MDK5的几个使用技巧</h1><p>1）TAB键的妙用。首先要介绍的就是TAB键的使用，这个键在很多编译器里面都是用来空位的，每按一下移 空几个位。如果你是经常编写程序的对这个键一定再熟悉不过了。但是 MDK 的 TAB 键和一般 编译器的 TAB 键有不同的地方，和 C++的 TAB 键差不多。MDK 的 TAB 键支持块操作。也就 是可以让一片代码整体右移固定的几个位，也可以通过 SHIFT+TAB 键整体左移固定的几个位。</p><p>2）快速查看一个函数或者变量所定义的地方的功能。 也可能想看看某个变量或数组是在哪个地方定义的等。MDK提供了这样的快速定位的功能只要你把光标放到这个函数/变量的上面，然后右键，弹出菜单栏，我们找到Go to Definition Of‘名字’ 这个地方，然后单击左键就可以快速跳到该函数的定义处（注意要先在 Options for Target 的 Output 选项卡里面勾选 Browse Information 选项，再编译，再定位，否则无法定位！）</p><p>3）快速注释与快速消注释功能。在调试代码的时候，你可能会想注释某一片的代码，来看看执行的情况，MDK提供了这样的快速注释/消注释块代码的功能。也是通过右键实现的。这个操作比较简单，就是先选中你要注释的代码区，然后右键，选择Advanced-&gt;Comment Selection 就可以了。</p><p>4）快速打开头文件功能。在将光标放到要打开的引用头文件上，然后右键选择 Open Document“XXX”，就可以快速打开这个文件了（XXX 是你要打开的头文件名字）</p><p>5）查找替换功能。这个和WORD等很多文档操作的替换功能是差不多的， 在MDK5里面查找替换的快捷键是“CTRL+H”，只要你按下该按钮就会调出查找替换功能。这个和WORD等很多文档操作的替换功能是差不多的。</p><p>6）跨文件查找功能，先双击你要找的函数/变量名，然后再点击IDE上面的左数第九个按键，然后再点击find。</p><h1 id="MDk下C语言基础复习"><a href="#MDk下C语言基础复习" class="headerlink" title="MDk下C语言基础复习"></a>MDk下C语言基础复习</h1><h2 id="六种位操作"><a href="#六种位操作" class="headerlink" title="六种位操作"></a>六种位操作</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li>&amp;：按位与，全1为1，有0为0。</li><li>|：按位或，全0为0，有1为1。</li><li>^：按位异或，相同为0，不同为1。</li><li>~：取反，按位取反，1变0，0变1。（由于是对其本身进行变换，所以~为单目运算符。</li><li>&lt;&lt;：左移，用来将一个数的各位全部向左移N位，右边补零（a=a&lt;&lt;N)</li><li><blockquote><blockquote><p>：右移，与左移作用一样只是方向不同。<br>注：复合运算：a&amp;=1—&gt;a=a&amp;1（其他符号同理）</p></blockquote></blockquote><h3 id="位操作的使用"><a href="#位操作的使用" class="headerlink" title="位操作的使用"></a>位操作的使用</h3>1）与操作的清零作用：如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOA-&gt;CRL&amp;=0XFFFFFF0F;//将4-7位清零</span><br></pre></td></tr></table></figure></li></ol><p>2）或运算设置相应值：如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOA-&gt;CRL|=0X00000040;//设置相应位，不改变其他位</span><br></pre></td></tr></table></figure></p><p>3）提高可读性：如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOx-&gt;BSRR=(((uint32_t)0x01)&lt;&lt;pinpos);//将GPIOx-&gt;BSRR寄存器的第PINPOS位设置为1</span><br></pre></td></tr></table></figure></p><p>其中(uint32_t)0x01是将0x01转换为32位。（因为该寄存器32位）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPIOA-&gt;ODR|=1&lt;&lt;5;</span><br><span class="line">= GPIOA-&gt;ODR=GPIOA-&gt;ODR|(00000001&lt;&lt;5);</span><br><span class="line">= GPIOA-&gt;ODR=GPIOA-&gt;ODR|0100000;//将第二位置1，其余位不变</span><br></pre></td></tr></table></figure></p><h2 id="define宏定义"><a href="#define宏定义" class="headerlink" title="define宏定义"></a>define宏定义</h2><p>常见格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define 标识符 字符串</span><br></pre></td></tr></table></figure></p><p>标识符为所定义宏名，字符串可以是常数，表达式，格式串等。<br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SYSCLK_FREQ_72MHZ 72000000</span><br></pre></td></tr></table></figure><p>此时，SYSCLK_FREQ_72MHZ = 72000000</p><h2 id="ifdef条件编译"><a href="#ifdef条件编译" class="headerlink" title="ifdef条件编译"></a>ifdef条件编译</h2><p>当满足某条件时，对一组语句进行编译；不满足某条件时，则编译另一组语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 标识符</span><br><span class="line">程序段 1</span><br><span class="line">#else</span><br><span class="line">程序段2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>作用是：当标识符用#define定义过，则对程序段1 进行编译，否则编译程序段2。（#else部分可以没有）</p><h2 id="extern变量声明"><a href="#extern变量声明" class="headerlink" title="extern变量声明"></a>extern变量声明</h2><p>extern置于变量或函数前时，表示变量在别的文件中。</p><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>为下文注：子优先级又叫做响应优先级。</p><h2 id="中断寄存器"><a href="#中断寄存器" class="headerlink" title="中断寄存器"></a>中断寄存器</h2><ul><li>ISER[8]：中断使能寄存器，ISER[0]的bit0~bit31对应中断0~31，ISER[1]的bit0~bit27对应中断0~27。通过将对应中断的ISER位置1，使该中断使能。</li><li>ICER[8]：中断除能寄存器，与ISER功能相反（对相应位置1，清除相应中断使能）。</li><li>ISPR[8]：中断挂起寄存器，通过将与中断对应的位置1，可以将正在进行的中断挂起。</li><li>ICPR[8]：中断解挂寄存器，通过将与中断对应的位置1，可以将挂起的中断解挂。</li><li>IABR[8]：中断激活标志位寄存器组，与相应中断对应的位如果为1，则表示该中断正在进行。</li><li>IP[240]：中断优先级控制寄存器组，IP[0]~IP[59]分别对应中断0~59。每个IP[]为8bit（共240个），叫做一个寄存器，该寄存器只用了高四位，分别为抢占优先级和子优先级（抢占优先级在前，子优先级在后）。</li></ul><h2 id="中断分组"><a href="#中断分组" class="headerlink" title="中断分组"></a>中断分组</h2><p>STM32中断分为五组（0~4），其中的不同是不同组中抢占优先级和子优先级对应的位不同。<br>如0组：则0位抢占优先级，4位子优先级；<br>1组：1位抢占优先级，3位子优先级。<br>以此类推。<br>高优先级的中断可以打断低优先级的中断，优先级对应的数字越小，优先级越高。</p><h2 id="优先级的概念"><a href="#优先级的概念" class="headerlink" title="优先级的概念"></a>优先级的概念</h2><p>抢占优先级：抢占优先级大的，可以打断抢占优先级小的。<br>响应优先级：同时触发两个中断时，先响应抢占优先级大的。但抢占优先级相同时，响应优先极大的不能打断抢占优先级小的。</p><h2 id="库函数使用"><a href="#库函数使用" class="headerlink" title="库函数使用"></a>库函数使用</h2><h3 id="中断优先级分组函数"><a href="#中断优先级分组函数" class="headerlink" title="中断优先级分组函数"></a>中断优先级分组函数</h3><p>原型：void NVIC_PriorityGroupConfig(u32_tNVIC_PriorityGroup)<br>作用：对中断优先级进行分组。<br>注意：该函数在只可以被调用一次。<br>使用：NVIC_PriorityGroupConfig(NVIC_PriorityGroup_x)<br>x的范围为0-4。x对应为上述对应x组。</p><h3 id="设置优先级函数"><a href="#设置优先级函数" class="headerlink" title="设置优先级函数"></a>设置优先级函数</h3><p>原型：void NVIC_Init(NVIC_InitTypeDef*InitStruct)<br>作用：1.选定需要确定优先级的中断；2.为中断确定响应优先极大和抢占优先级。<br>使用：1.首先定义一个NVIC_InitTypeDef类型的指针；2.用指针设置结构体内的几个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123; </span><br><span class="line">uint8_t NVIC_IRQChannel;//选定中断</span><br><span class="line">    uint8_t NVIC_IRQChannelPreemptionPriority;   //设置抢占优先级</span><br><span class="line">uint8_t NVIC_IRQChannelSubPriority;    //设置响应优先级</span><br><span class="line">FunctionalState NVIC_IRQChannelCmd;   //使能</span><br><span class="line">&#125; NVIC_InitTypeDef;</span><br></pre></td></tr></table></figure></p><p>调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitTypeDef   NVIC_InitStructure;  </span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;//串口 1 中断  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1 ;// 抢占优先级 1</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; // 子优先级位 2  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;   //IRQ 通道使能  </span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure); //根据上面指定的参数初始化 NVIC 寄存器</span><br></pre></td></tr></table></figure></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>在程序最开始的地方，进行中断分组（调用void NVIC_PriorityGroupConfig(u32_tNVIC_PriorityGroup)）。</li><li>设置用到的中断的优先级。</li></ol><h1 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h1><p>STM32F103共有19个外部中断，0~15对应着GPIOx.0~GPIOx.15（x：A~G。A~G等价)；16中断-&gt;PVD输出；17中断-&gt;RTC闹钟事件；18中断-&gt;USB唤醒事件。</p><h2 id="库函数使用-1"><a href="#库函数使用-1" class="headerlink" title="库函数使用"></a>库函数使用</h2><h3 id="GPIO与外部中断的映射关系的函数"><a href="#GPIO与外部中断的映射关系的函数" class="headerlink" title="GPIO与外部中断的映射关系的函数"></a>GPIO与外部中断的映射关系的函数</h3><p>原型：void GPIO_EXTILineConfig(uint8_t GPIO_PortSource,uint8_t GPIO_PinSource2)<br>参数意义：参数1，GPIOx；参数2，中断x（相当于pin）<br>使用：GPIO_EXTILINEConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2)<br>作用：将端口GPIO_PortSource与中断GPIO_PinSource2来连接起来。</p><h3 id="中断初始化函数"><a href="#中断初始化函数" class="headerlink" title="中断初始化函数"></a>中断初始化函数</h3><p>原型：void EXTI_Init(EXTI_InitTypeDef*EXTI_InitStruct)<br>参数意义：设置结构体成员的结构体指针。<br>作用：设置需要设置的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;</span><br><span class="line">uint32_t EXTI_Line;//设置需要初始化的中断</span><br><span class="line">EXTIMode_TypeDef EXTI_Mode;      //设置模式--&gt;中断\事件（Interrupt\Event）</span><br><span class="line">EXTITrigger_TypeDef EXTI_Trigger;    //设置触发边沿--&gt;下降沿\上升沿\上升和下降（Falling\Rising\Rising_Falling)</span><br><span class="line">FunctionalState EXTI_LineCmd;   //使能(ENABLE)或失能(DISABLE)</span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTI_InitTypeDef  EXTI_InitStructure;</span><br><span class="line">   EXTI_InitStructure.EXTI_Line=EXTI_Line4;    </span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;     </span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; </span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;    </span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br></pre></td></tr></table></figure></p><h3 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h3><p>原型：NVIC_Init(&amp;NVIC_InitStructure)<br>参数意义：与上一章相同。（此处需将变量NVIC_InitStructure.NVIC_IRQChannel设置为EXTIx_IRQn;x代表外部中断x）。<br>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel=EXTI2_IRQn;         //使能按键外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级 2，  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;  //子优先级 2 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;   //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure);                          //中断优先级分组初始化</span><br></pre></td></tr></table></figure></p><h3 id="检查状态函数"><a href="#检查状态函数" class="headerlink" title="检查状态函数"></a>检查状态函数</h3><p>原型：FlagStatus ITStatus EXTI_GetITStauts(uint32_t EXTI_Line)<br>参数意义：指定中断（EXTI_LINEx）<br>使用：EXTIStatus = EXTI_GetFlagStatus(EXTI_Linex)<br>作用：返回指定中断的状态（SET/RESET)</p><h3 id="清除中断标志函数"><a href="#清除中断标志函数" class="headerlink" title="清除中断标志函数"></a>清除中断标志函数</h3><p>原型：void EXTI_ClearITPendingBit(u32_t EXTI_Line)<br>参数意义：指定中断<br>使用EXTI_ClearITPendingBit（EXTI_Linex）<br>作用：一般在中断函数结束之前，清除中断标志位</p><h3 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h3><p>注意：所有中断函数都有固定名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPORT  EXTI0_IRQHandler           </span><br><span class="line">EXPORT  EXTI1_IRQHandler        </span><br><span class="line">EXPORT  EXTI2_IRQHandler          </span><br><span class="line">EXPORT  EXTI3_IRQHandler         </span><br><span class="line">EXPORT  EXTI4_IRQHandler//0~4中断分别对应这几个函数           </span><br><span class="line">EXPORT  EXTI9_5_IRQHandler  //5~9中断公用这一个函数</span><br><span class="line">EXPORT  EXTI15_10_IRQHandler//10~15中断公用这一个函数</span><br></pre></td></tr></table></figure></p><h3 id="一般中断函数的形式"><a href="#一般中断函数的形式" class="headerlink" title="一般中断函数的形式"></a>一般中断函数的形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void EXTIx_IRQHandler()</span><br><span class="line">&#123;</span><br><span class="line">if(EXTI_GetITStatus(EXTI_Linex)!=RESET)//判断终端是否发生</span><br><span class="line">&#123;</span><br><span class="line">函数主体···</span><br><span class="line">EXTI_ClearITPendingBit（EXTI_Line3）；//清除中断标志位</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外部中断使用步骤"><a href="#外部中断使用步骤" class="headerlink" title="外部中断使用步骤"></a>外部中断使用步骤</h2><p>1）初始化GPIO口为输入（要开启的中断所对应的GPIO口）<br>2）开启AFIO时钟</p><blockquote><p>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //②使能 AFIO 时钟 </p></blockquote><p>3）设置IO口与中断的映射关系</p><blockquote><p>如：GPIO_EXTILINEConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2);</p></blockquote><p>4）初始化中断</p><blockquote><p>EXTI_Init(&amp;EXTI_InitStructure);</p></blockquote><p>5）配置中断分组，并且使能该中断<br>6）编写中断服务函数</p><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>自动重装载周期A；cpu时钟频率B；预分频系数C；需要的时间：T<br>(B/C)/A = T<br>//如：时钟频率72M，预分频系数为7200，则：1s对应10000个时钟周期；所需时间T=（1/10000）*A</p><h2 id="定时器种类"><a href="#定时器种类" class="headerlink" title="定时器种类"></a>定时器种类</h2><p>STM32F103共有11个定时器[2个高级定时器（TIM1,TIM8)，4个普通定时器(TIM2-TIM5)，2个基本定时器(TIM6,TIM7)，2个看门狗定时器，1个系统滴答定时器]</p><h2 id="3种计数模式"><a href="#3种计数模式" class="headerlink" title="3种计数模式"></a>3种计数模式</h2><ol><li>向上计数模式：从0开始，计到预设值，产生溢出事件，返回重新计数。</li><li>向下计数模式：从预设值开始，计到0，产生溢出事件，返回重新计时。</li><li>中央对齐模式：从0开始向上计数，计到预设值产生溢出事件，然后从预设值开始向下计数，计数到1后产生溢出事件，然后再从0开始向上计数。</li></ol><h2 id="3种定时器主要功能"><a href="#3种定时器主要功能" class="headerlink" title="3种定时器主要功能"></a>3种定时器主要功能</h2><ol><li>基本定时器主要功能(TIM6,TIM7)：只有基本定定时功能。</li><li>普通定时器主要功能(TIM2-TIM5)：除基本的定时器功能外，可以测量输入信号的脉冲长度或者产生输出波形（PWM和输出比较）。</li><li>高级定时器主要功能(TIM1,TIM8)：除上述功能，还可以控制交直流电机的所有功能。</li></ol><h1 id="普通定时器"><a href="#普通定时器" class="headerlink" title="普通定时器"></a>普通定时器</h1><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ol><li>16位自动装载计数器（向上，向下，向上\向下）</li><li>16位可编程预分频器（分频系数：1~65535）</li><li>4个独立通道（TIMx_CH1~4)，通道作用：A.输入捕获；B。输出比较；C.PWM生成；D.单脉冲模式输出。</li><li>可实现一个定时器控制另一个定时器的同步电路</li></ol><h2 id="触发中断"><a href="#触发中断" class="headerlink" title="触发中断"></a>触发中断</h2><ol><li>中断触发条件：A.计数器溢出或计数器初始化。</li><li>触发事件：计数器启动、停止、初始化或者有内部/外部触发计数。</li><li>输入捕获</li><li>输出比较</li><li>增量编码器或霍尔传感器电路</li><li>触发输入作为外部时钟或者按周期的电路管理</li></ol><h2 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h2><ul><li>TIM_CR1：控制寄存器，功能有：使能定时器，设置计数方向（向上\向下），设置计数对齐方式，设置时钟分频因子。</li><li>TIMx_DIER：中断使能寄存器，功能有：顾名思义，用来允许更新事件所产生的中断。</li><li>TIMx_PSC：预分频寄存器，功能有：对时钟进行分频，作为定时器的时钟。</li><li>TIMx_CNT：定时器的计数器，功能有：存储当前定时器的计数值。</li><li>TIMx_ARR：自动重装载寄存器，功能有：用来设置自动重装载的值（值为空时，寄存器不起作用）。</li><li>TIMx_SR：状态寄存器，功能是：标记当前与定时器相关的中断是否发生。</li></ul><h2 id="库函数使用-2"><a href="#库函数使用-2" class="headerlink" title="库函数使用"></a>库函数使用</h2><h3 id="定时器时钟使能"><a href="#定时器时钟使能" class="headerlink" title="定时器时钟使能"></a>定时器时钟使能</h3><p>原型：void RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIMx,ENABLE)<br>参数意义：指明是使能哪一个定时器。x范围是2~5（普通定时器）<br>使用：RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIMx,ENABLE)；使能TIMx定时器。</p><h3 id="初始化定时器"><a href="#初始化定时器" class="headerlink" title="初始化定时器"></a>初始化定时器</h3><p>原型：void TIM_TimeBaseInit(TIM_TypeDef<em>TIMx,TIM_TimeBaseInitTypeDef</em>TIM_TimeBaseInitStruct)<br>参数意义：第一个参数：指定定时器；第二个参数：用于设置初始值的结构体指针。<br>结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;   </span><br><span class="line">uint16_t TIM_Prescaler;//设置分频系数</span><br><span class="line">uint16_t TIM_CounterMode;//设置计数方式(向上计数模式TIM_CounterMode_Up；向下计数模式：TIM_CounterMode_Down)</span><br><span class="line">uint16_t TIM_Period;//设置自动重载计数周期值</span><br><span class="line">uint16_t TIM_ClockDivision; //设置时钟分频因子</span><br><span class="line">uint8_t TIM_RepetitionCounter;//高级定时器使用</span><br><span class="line">&#125; TIM_TimeBaseInitTypeDef;</span><br></pre></td></tr></table></figure></p><p>使用：以TIM3为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">TIM_TimeBaseStructure.TIM_Period = 5000;//自动装载周期：5000</span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =7199;//分频系数：7199</span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision =TIM_CKD_DIV1;//设置时间分频因子</span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数方式：向上计数模式</span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure);</span><br></pre></td></tr></table></figure></p><h3 id="设置允许更新"><a href="#设置允许更新" class="headerlink" title="设置允许更新"></a>设置允许更新</h3><p>原型：void TIM_ITConfig(TIMx,TIM_IT,ENABLE/DISABLE)<br>参数意义：第一个参数：指明定时器；第二个参数指明中断类型（由什么触发中断；如，更新中断，输入捕获中断）；第三个参数：使能/失能<br>使用：以TIM3为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_ITConfig(TIM3,TIM_IT_Updata,ENABLE);//设置为更新中断</span><br></pre></td></tr></table></figure></p><h3 id="使能TIMx函数"><a href="#使能TIMx函数" class="headerlink" title="使能TIMx函数"></a>使能TIMx函数</h3><p>原型：void TIM_Cmd(TIM_TypeDef*TIMx,ENABLE/DISABLE)<br>参数意义：第一个参数：指明定时器；第二个参数：使能/失能。<br>使用：TIM_Cmd(TIMx,enable/disable)</p><h3 id="检查状态函数-1"><a href="#检查状态函数-1" class="headerlink" title="检查状态函数"></a>检查状态函数</h3><p>原型：ITStatus TIM_GetITStatus(TIM_TypeDef*TIMx,中断类型)<br>参数意义：第一个参数：指明定时器；第二个参数：指明中断类型。<br>作用：返回状态值SET/RESET.<br>使用：TIM_GetStatus(TIMx,TIM_IT_Upadata)        //更新类型中断</p><h3 id="清除标志位函数"><a href="#清除标志位函数" class="headerlink" title="清除标志位函数"></a>清除标志位函数</h3><p>原型：void TIM_ClearITPendingBit(TIM_TypeDef*TIMx,中断类型)<br>参数意义：与上相同<br>使用：TIM_ClearITPendingBit(TIM3,TIM_IT_Upadata)</p><h2 id="定时器使用步骤"><a href="#定时器使用步骤" class="headerlink" title="定时器使用步骤"></a>定时器使用步骤</h2><p>1）时钟使能<br>2）初始化定时器（计数模式，自动装载周期，分频因子等）<br>3）允许中断并配置中断类型<br>4）中断优先级设置（调用NVIC库实现）<br>5）使能TIMx<br>6）编写中断服务函数<br>注意：中断服务函数：void TIMx_IRQHandler()<br>设置中断初始化的中断频道：TIMx_IRQn</p><h1 id="PWM输出"><a href="#PWM输出" class="headerlink" title="PWM输出"></a>PWM输出</h1><p>实现：使用TIMx的一个通道，把该通道重映射到GPIO端口，产生PWM。<br>默认：CH1–PA6;CH2–PA7;CH3–PB0;CH4–PB1。<br>部分重映射：CH1–PB4;CH2–PB5;CH3–PB0;CH4–PB1。<br>重映射：CH1–PC6;CH2–PC7;CH3–PC8;CH4–PC9。</p><h2 id="STM32与PWM"><a href="#STM32与PWM" class="headerlink" title="STM32与PWM"></a>STM32与PWM</h2><p>基本定时器（TIM6;TIM7)无法产生PWM。<br>不同定时器（TIM2~TIM5）可以产生四路PWM输出。<br>高级定时器（TIM1;TIM8）可以产生七路PWM输出。</p><h2 id="相关寄存器-1"><a href="#相关寄存器-1" class="headerlink" title="相关寄存器"></a>相关寄存器</h2><p>TIMx_CCMR1/2：捕获/比较模式寄存器，TIMx_CCMR1控制CH1,CH2;TIMx_CCMR2控制CH3，CH4。主要使用其模式设置功能。<br>TIMx_CCER:捕获/比较使能寄存器，顾名思义：使能PWM波。<br>TIMx_CCR1~4：捕获/比较寄存器，输出模式下，该寄存器的值与CNT寄存器的值比较，根据结果产生相应动作。<br>实际使用中，通过修改这个寄存器的值来控制PWM的输出脉宽。（ccr1~4分别对应CH1~4）</p><h2 id="硬件相关"><a href="#硬件相关" class="headerlink" title="硬件相关"></a>硬件相关</h2><p>由于STM32每个通道连接固定的GPIO口，因此，需要用到GPIO的重映射。<br>STM32的重映射是由复用重映射和IP配置寄存器（AFIO_MAPR）控制的。该寄存器的各位描述见STM32开发指南（库函数版）P217。<br>重映射实现</p><h2 id="库函数使用-3"><a href="#库函数使用-3" class="headerlink" title="库函数使用"></a>库函数使用</h2><p>关于极性的问题：<br>如果是PWM1模式 :<br>如果设置TIM_OCPolarity_High     TIMx_CNT&lt;TIMx_CCR输出为高电平   TIMx_CNT&gt;TIMx_CCR输出为低电平<br>如果设置TIM_OCPolarity_Low      TIMx_CNT&lt;TIMx_CCR输出就为低电平  TIMx_CNT&gt;&lt;TIMx_CCR输出就为高电平<br>如果是PWM2模式 :<br>如果设置TIM_OCPolarity_High     TIMx_CNT&gt;TIMx_CCR输出为低电平   TIMx_CNT&lt;TIMx_CCR输出为高电平<br>如果设置TIM_OCPolarity_Low      TIMx_CNT&gt;TIMx_CCR输出就为高电平  TIMx_CNT&lt;TIMx_CCR输出就为低电平</p><h3 id="开启TIM3时钟以及【复用功能时钟（AFIO）】（如果需要的话）"><a href="#开启TIM3时钟以及【复用功能时钟（AFIO）】（如果需要的话）" class="headerlink" title="开启TIM3时钟以及【复用功能时钟（AFIO）】（如果需要的话）"></a>开启TIM3时钟以及【复用功能时钟（AFIO）】（如果需要的话）</h3><p>RCC_APB1PeriphClockCmd(RCC_PAB1Periph_TIM3,ENABLE)    //TIM3时钟使能<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIP,ENABLE)    //使能复用时钟</p><h3 id="设置重映射（如果有需要的话）"><a href="#设置重映射（如果有需要的话）" class="headerlink" title="设置重映射（如果有需要的话）"></a>设置重映射（如果有需要的话）</h3><p>原型：void GPIO_PinRemapConfig(u32_t GPIO_Remap,FunctionalState NewState)<br>参数：第一个参数：GPIO_FullRenmap_TIMx;(重映射)；GPIO_PartialRenmap_TIMx;(部分重映射)；第二个参数：使能/失能<br>使用：GPIO_PinRemapConfig(GPIO_PinRemap_TIM3,ENABLE);TIM3重映射使能</p><h3 id="初始化定时器-1"><a href="#初始化定时器-1" class="headerlink" title="初始化定时器"></a>初始化定时器</h3><p>设置重装值，预分频系数，时钟分割（此时该参数设为0），计数模式</p><h3 id="设置TIMx-CHx的PWM模式"><a href="#设置TIMx-CHx的PWM模式" class="headerlink" title="设置TIMx_CHx的PWM模式"></a>设置TIMx_CHx的PWM模式</h3><p>原型：void TIM_OCxInit(TIM_TypeDef<em>TIMx,TIM_OCInitTypeDef</em>TIM_OCInitStruct)【x代表选中的通道】<br>参数：第一个参数：TIM2、TIM3….<br>第二个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;</span><br><span class="line">uint16_t TIM_OCMode;//设置模式是PWM还是输出比较；PWM下的格式：TIM_OC_PWM2</span><br><span class="line">uint16_t TIM_OutputState;//使能PWM到端口；PWM下的格式：TIM_OutputState_ENABLE</span><br><span class="line">uint16_t TIM_OutputNState;//高级定时器使用。</span><br><span class="line">uint16_t TIM_Pulse;//高级定时器使用</span><br><span class="line">uint16_t TIM_OCPolarity;//设置极性高/低</span><br><span class="line">uint16_t TIM_OCNPolarity;//高级定时器使用</span><br><span class="line">uint16_t TIM_OCIdleState;//高级定时器使用</span><br><span class="line">uint16_t TIM_OCNIdleState;//高级定时器使用</span><br><span class="line">&#125; TIM_OCInitTypeDef;</span><br></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line"></span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; //选择 PWM 模式 2 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性高</span><br><span class="line"></span><br><span class="line">TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure);  //初始化 TIM3 OC2</span><br></pre></td></tr></table></figure></p><h3 id="控制占空比"><a href="#控制占空比" class="headerlink" title="控制占空比"></a>控制占空比</h3><p>原型：void TIM_SetComparex(TIM_TypeDef*TIMx,Compare2)【x代表通道】<br>参数：第一个参数：TIMx；第二个参数：自动重装载寄存器的新值。<br>使用：TIM_SetCompare1(TIM2,重装载值)</p><h2 id="产生PWM值的步骤"><a href="#产生PWM值的步骤" class="headerlink" title="产生PWM值的步骤"></a>产生PWM值的步骤</h2><p>1）使能TIM3的时钟。看需要使能复用功能时钟。<br>2）看需要进行GPIO口映射。<br>3）初始化TIM3。<br>4）设置该定时器的该通道的PWM模式。<br>5）使能TIM3。<br>6）控制占空比。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有关STM32知识的笔记&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>树莓派笔记</title>
    <link href="http://linmushen.com/2019/06/14/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0/"/>
    <id>http://linmushen.com/2019/06/14/树莓派笔记/</id>
    <published>2019-06-14T14:45:13.000Z</published>
    <updated>2019-08-18T16:13:04.311Z</updated>
    
    <content type="html"><![CDATA[<p>记录有关树莓派学习的笔记<br><a id="more"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>核心元件：树莓派 L298N</li><li>需要实现：视觉识别（Opencv） 底层电机驱动</li><li>核心功能：识别赛道图像，沿着白线走</li><li>核心原理：利用二值化（大律法二值化）将白色单独显示出来</li><li>未知问题：<blockquote><p>腐蚀膨胀问题？—一种对图像的处理方法，腐蚀是去掉，膨胀是把图放大<br>缩放倍率？</p></blockquote></li></ol><h1 id="GPIO控制使用"><a href="#GPIO控制使用" class="headerlink" title="GPIO控制使用"></a>GPIO控制使用</h1><ol><li>GPIO–通入输入/输出端口</li><li>wiringPi/RPI.GPIO是需要导入的库函数</li></ol><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ol><li>import RPI.GPIO as GPIO</li><li>设置编码规范： gpio.setmode(gpio.BOARD)<blockquote><p>编码规范：</p><blockquote><p>1）BOARD： 从左到右，从上到下：左边基数，右边偶数：1-40<br>2）BCM：编号侧重 CPU 寄存器，根据 BCM2835 的 GPIO 寄存器编号<br>3）wpi： 编号侧重实现逻辑，把扩展 GPIO 端口从 0 开始编号，这种编号方便编程。</p></blockquote></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录有关树莓派学习的笔记&lt;br&gt;
    
    </summary>
    
      <category term="硬件部分" scheme="http://linmushen.com/categories/MCU/"/>
    
    
  </entry>
  
  <entry>
    <title>Matlab相关</title>
    <link href="http://linmushen.com/2019/04/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1M/"/>
    <id>http://linmushen.com/2019/04/17/数学建模M/</id>
    <published>2019-04-17T13:59:01.000Z</published>
    <updated>2019-08-18T15:15:28.594Z</updated>
    
    <content type="html"><![CDATA[<p>有一些关于Matlab的知识<br><a id="more"></a></p><h1 id="Matlab知识笔记"><a href="#Matlab知识笔记" class="headerlink" title="Matlab知识笔记"></a>Matlab知识笔记</h1><ul><li>Matlab主要用来处理整个矩阵和数组。</li><li>所有matlab变量都是多维的。</li><li>matlab将数字存储为浮点值</li></ul><h2 id="命令与函数"><a href="#命令与函数" class="headerlink" title="命令与函数"></a>命令与函数</h2><h3 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h3><ol><li>help inv ：显示函数（inv）的帮助信息</li><li>[]  ：创建矩阵</li><li>[]; : 创建一个矩阵但不在命令行中显示出来</li><li>,   ：矩阵行元素分隔符号</li><li>;   ：矩阵列元素分隔符号</li><li>%   : 注释行</li><li>clear ：清理工作空间中的各种变量</li><li>== ：关系运算符：等于</li><li>~= ：关系运算符：不等于</li><li>| ：逻辑或运算</li></ol><h3 id="定义类型"><a href="#定义类型" class="headerlink" title="定义类型"></a>定义类型</h3><ol><li>format short : 定义输出格式为短，显示小数点后四位</li><li>format long : 定义输出格式为长，显示小数点后14（15）位</li><li>format rat：以有理数形式输出<blockquote><p>format只影响输出格式，不影响存储方式 </p></blockquote></li><li>syms x ：定义x为符号变量</li></ol><h3 id="控制流程语句"><a href="#控制流程语句" class="headerlink" title="控制流程语句"></a>控制流程语句</h3><ol><li>if..else if..end : 条件语句，作用与c中类似</li><li>for..end : for循环语句，与c类似</li></ol><h3 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h3><ol><li>n=input(‘…’):输入函数，其中’’之间的是提示字符</li><li>disp(‘….’):显示单引号中字符串</li></ol><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="创建矩阵的函数"><a href="#创建矩阵的函数" class="headerlink" title="创建矩阵的函数"></a>创建矩阵的函数</h3><ol><li>eye(n):创建n阶单位矩阵</li><li>zeros（m,n）：创建m*n阶零矩阵</li><li>zeros(n) :创建n阶方阵</li><li>ones（m,n):创建m*n阶元素全为1的矩阵</li><li>rand（m,n):创建m*n阶元素为从0到1均匀分布的随机数矩阵</li><li>randn(m,n):创建m*n阶均值为0，方差为1的标准正态分布随机矩阵</li><li>round（A）：对矩阵A所有元素进行四舍五入运算</li></ol><h3 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h3><ol><li>inv(A):求矩阵A的逆</li><li>A^-1:用幂运算求矩阵A的逆</li><li>a’ ：a的转置</li><li>inv(a):a的逆矩阵</li><li><ul><li>：执行标准矩阵乘法，计算行与列之间的内积</li></ul></li><li>\ :MATLAB特有的矩阵左除A/B=inv（A)*B</li><li>/ ：matlab特有的矩阵右除B/A=B*inv（A)</li><li>. ：在运算符号前加 . 含义为对应矩阵群运算（元素级运算，即每一个元素之间的运算）<blockquote><ul><li>只有乘除幂运算有相应的群运算。</li><li>C=A.*B：矩阵元素群运算（A,B矩阵中对应元素相乘）</li><li>D=A.^2:矩阵元素群运算（A中每一个元素平方）【a^2，相当于a乘a；a.^2，相当于a的每一个元素平方】</li></ul></blockquote></li><li>：  ：冒号运算符，start:step:end   不写step的值时，默认为1<blockquote><p>可以创建等距向量 ：B=0：50：100    </p><blockquote><p>B = 0，50，100</p></blockquote></blockquote></li></ol><h2 id="行列式与方程组求解"><a href="#行列式与方程组求解" class="headerlink" title="行列式与方程组求解"></a>行列式与方程组求解</h2><ol><li>U=rref(A)  :对矩阵A进行初等行变换，得到的U是A的最简行列式<blockquote><p>rref([A,b]) :就是将A，b的混合矩阵化为行最简</p></blockquote></li><li>[m,n]=size(A)：计算A的行，列，并返回一个二维向量</li><li>det(A):计算矩阵A的行列式</li><li>rank(A):计算矩阵A的秩</li><li>A(i,j) :引出A的第i行第j列的元素</li><li>B（：，i)=b : 把向量b的值赋给矩阵B的第i列（矩阵B的列向量和向量b同型）</li><li>B（：，1：5）：取矩阵的第一列至第五列</li><li>[A,eye(5)] : 创建一个5*10矩阵，前五列为A，后五列为单位矩阵i</li><li>T(1,:)=[] : 把一个空行赋给T的第1行（删除T的第一行）</li><li>factor(D):对符号变量多项式D进行因式分解</li><li>solve(D) :求符号变量多项式方程D=0的解</li></ol><h2 id="工作区变量"><a href="#工作区变量" class="headerlink" title="工作区变量"></a>工作区变量</h2><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>在Matlab中创建或从其他程序导入的变量</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><ol><li>使用： whos</li><li>直接在工作区窗格查看</li></ol><h3 id="保存和还原"><a href="#保存和还原" class="headerlink" title="保存和还原"></a>保存和还原</h3><ol><li>使用save name.mat保存到压缩文件中</li><li>使用load name.mat将mat中数据还原到工作区</li></ol><h2 id="文本和字符"><a href="#文本和字符" class="headerlink" title="文本和字符"></a>文本和字符</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>文本：与其他语言类似：字符串用单引号括起来，如果字符串中有单引号则单引号用两个单引号’’表示。</li><li>把文本赋值给变量，变量类型为数组（数据类型为char）</li><li>同样可以用[]来进行串联 a=’lin’ b=’mu’  A = [a,’-‘,b]<blockquote><p>A: ‘lin-mu’</p></blockquote><h3 id="数值与字符的转化"><a href="#数值与字符的转化" class="headerlink" title="数值与字符的转化"></a>数值与字符的转化</h3></li><li>由于数值不能与字符变量进行串联，所以需要将数值转化成char型</li></ul><ol><li>num2str(c)  c=3.33  <blockquote><p>转化为 ‘3.33’</p></blockquote></li><li>int2str(c) <blockquote><p>转化为 ‘3’</p></blockquote></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>clc: 清空命令窗口<br>clear: 清空工作区间的变量<br>mean()：获得一个序列的均值<br>std（）：获得一个序列的方差<br>magic():魔方矩阵<br>hilb():产生一个希尔伯特矩阵</p><blockquote><p>矩阵各个值为H（ij）= i+j-1分之一</p></blockquote><h1 id="入门学习"><a href="#入门学习" class="headerlink" title="入门学习"></a>入门学习</h1><h2 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h2><h3 id="常规方法"><a href="#常规方法" class="headerlink" title="常规方法"></a>常规方法</h3><p> 使用 ， 或 空格 来分隔各元素</p><blockquote><p>a = [1,2,3,4]<br>b = [1 2 3 4]<br> 使用 ； 来分隔各行</p></blockquote><h3 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h3><p> 使用ones zeros 或 rand函数（具体函数参照上文）</p><blockquote><p>z = zeros(5,1)   %创建一个五行一列的矩阵</p></blockquote><h2 id="矩阵与数组的运算"><a href="#矩阵与数组的运算" class="headerlink" title="矩阵与数组的运算"></a>矩阵与数组的运算</h2><h3 id="使用运算符"><a href="#使用运算符" class="headerlink" title="使用运算符"></a>使用运算符</h3><p> 使用单一的算术运算符或函数来处理矩阵中的所有值</p><blockquote><p>a+10     %对矩阵a中每一个元素加十<br>sin(a)   %对矩阵中每一个元素进行正弦处理<br>a’       %对矩阵a转置</p></blockquote><h3 id="串联"><a href="#串联" class="headerlink" title="串联"></a>串联</h3><ol><li>串联是连接数组以便形成更大数组的过程。（数组的创建也是如此，通过将各个元素串联而构成的）</li><li>[]即为串联符<br>规则：<blockquote><p>A = [a,b]   %将数组a与数组b水平串联，ab必须具有相同的行数<br>B = [a;b]   %将数组a与数组b竖直串联，ab必须具有相同的列数</p></blockquote></li></ol><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>复数包含 实部和虚部<br>虚数单位是-1的平方根</p><h2 id="数组的索引"><a href="#数组的索引" class="headerlink" title="数组的索引"></a>数组的索引</h2><p>前提 ：</p><blockquote><p>A = [1,2,3,4;4,3,2,1;5,6,7,8]</p></blockquote><h3 id="引用单个元素"><a href="#引用单个元素" class="headerlink" title="引用单个元素"></a>引用单个元素</h3><ol><li>A(4,2)     %引用数组中的特定元素，指定行标和列标</li><li>A(8)       %用单一下标，逐个遍历每一<strong>**</strong>列<strong>**</strong>  ；也叫线性索引<h3 id="添加单个元素"><a href="#添加单个元素" class="headerlink" title="添加单个元素"></a>添加单个元素</h3></li></ol><ul><li>A(4,3)=10  %在索引不存在的情况下，在右边进行赋值，数组大小就会扩大，其余部分填0<h3 id="引用多个元素"><a href="#引用多个元素" class="headerlink" title="引用多个元素"></a>引用多个元素</h3>用冒号 </li></ul><ol><li>A(1:3,2)   %指定一个start:end的范围（以原来形式列出前三行第二列的元素）</li><li>A(:,2)     %单独只有冒号，则列出该列所有元素 </li></ol><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>无接收值无参数： clc    （只写函数名）</p><h3 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h3><ol><li>使用单个参数：name(a)</li><li>使用多个参数：name(a,b)<h3 id="接收函数值"><a href="#接收函数值" class="headerlink" title="接收函数值"></a>接收函数值</h3></li><li>接收单个值：A = name(a)</li><li>接收多个值：[A,B] = name(a)</li></ol><h2 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h2><h3 id="线图"><a href="#线图" class="headerlink" title="线图"></a>线图</h3><ol><li>使用plot(x,y)函数绘制<blockquote><p>plot(x,y,‘r–’):第三个参数为线条设定（r–为红色虚线）<strong>注意：要用单引号引起来</strong></p><blockquote><p>线条设定包括线条颜色（r,g…)、样式、标记的字符(+、o、*标记各个数据点）</p></blockquote></blockquote></li><li>在plot(x,y)后使用 xlabel(‘x’)  ylabel(‘y’)  title(‘my title’)标记各个轴和写标题</li><li>默认情况下，matlab每调用一次绘图函数、重置坐标区及其他元素时，都会清除图窗<blockquote><p>若要保留，则使用 hold on。终止用hold off。</p></blockquote></li></ol><h3 id="三维图形"><a href="#三维图形" class="headerlink" title="三维图形"></a>三维图形</h3><ol><li>首先使用meshgrid创建一组点（x,y)<blockquote><p>meshgrid(X,Y): X，Y：为两个行向量，步数默认为1，范围给定（X=1：2   Y=1:3)<br>然后将X复制Y的元素个数次（3次），将Y复制X的元素个数次（2次）</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些关于Matlab的知识&lt;br&gt;
    
    </summary>
    
      <category term="数学建模" scheme="http://linmushen.com/categories/Mathematical-modeling/"/>
    
    
  </entry>
  
  <entry>
    <title>知识积累</title>
    <link href="http://linmushen.com/2019/04/12/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    <id>http://linmushen.com/2019/04/12/知识积累/</id>
    <published>2019-04-12T14:30:38.000Z</published>
    <updated>2019-08-18T16:13:04.312Z</updated>
    
    <content type="html"><![CDATA[<p>一个用于日常知识积累的笔记<br><a id="more"></a></p><h1 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h1><p>此电脑—&gt;属性—-&gt;高级系统设置—-&gt;path—-&gt;新建</p><h1 id="python-安装第三方库"><a href="#python-安装第三方库" class="headerlink" title="python 安装第三方库"></a>python 安装第三方库</h1><p>cmd (powershell)</p><blockquote><p>转到pip下的cache目录<br>pip install 库名</p></blockquote><h1 id="关于pip时的编码错误问题"><a href="#关于pip时的编码错误问题" class="headerlink" title="关于pip时的编码错误问题"></a>关于pip时的编码错误问题</h1><p>最近安装pip-19.1 执行python setup.py install一直提示编码错误<br>弄了一晚上找到解决办法<br>在python27–&gt;Lib–&gt;site-packages下添加一个名为sitecustomize.py的文件<br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&apos;gb2312&apos;)</span><br></pre></td></tr></table></figure></p><p>用utf-8不好使，可能是环境不一样的问题</p><h1 id="创建python虚拟环境"><a href="#创建python虚拟环境" class="headerlink" title="创建python虚拟环境"></a>创建python虚拟环境</h1><p>记得要cd到Python27下的Scripts下运行virtualven name（创建一个名为name的虚拟环境）<br>运行Scripts\active进入虚拟环境<br>运行deactive退出虚拟环境</p><h1 id="高深的爬虫基础"><a href="#高深的爬虫基础" class="headerlink" title="高深的爬虫基础"></a>高深的爬虫基础</h1><p>这个笔记拿来记录一点零星的爬虫知识，以备后用<br><!--more--></p><h2 id="urllib模块"><a href="#urllib模块" class="headerlink" title="urllib模块"></a>urllib模块</h2><h3 id="打开网址-url-的操作"><a href="#打开网址-url-的操作" class="headerlink" title="打开网址(url)的操作"></a>打开网址(url)的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import urllib</span><br><span class="line">f = urllib.urlopen(&apos;网址&apos;)</span><br></pre></td></tr></table></figure><h3 id="返回一个文件对象，有与对文件对象类似的操作"><a href="#返回一个文件对象，有与对文件对象类似的操作" class="headerlink" title="返回一个文件对象，有与对文件对象类似的操作"></a>返回一个文件对象，有与对文件对象类似的操作</h3><ul><li>read() , readline() ,readlines() , fileno() , close() ：这些方法的使用方式与文件对象完全一样</li><li>info()：返回一个httplib.HTTPMessage对象，表示远程服务器返回的头信息</li><li>getcode()：返回Http状态码。如果是http请求，200请求成功完成;404网址未找到</li><li>geturl()：返回请求的url</li></ul><p>后续过于高深，暂时不写<br>关于代码，可以查看py42.py</p><h1 id="HTML文本的笔记"><a href="#HTML文本的笔记" class="headerlink" title="HTML文本的笔记"></a>HTML文本的笔记</h1><p>最近学习了一点有关HTML的知识<br>在此记录一下<br><!--more--></p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>好像是用&lt;&gt;来表示的<br>标签就好像是python里的函数<br>如 </p><ol><li><figure class="highlight plain"><figcaption><span>``` 表示主题内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2. ```&lt;html&gt; &lt;/html&gt;``` 表示HTML文件</span><br><span class="line">3. ```&lt;form&gt; &lt;/form&gt;``` 表示表单文件</span><br><span class="line">4. ```&lt;input&gt;``` 标签</span><br><span class="line"></span><br><span class="line">## input标签</span><br></pre></td></tr></table></figure></li></ol><p><input type="(1)"><br><code>`</code><br>其中（1）内容为以下</p><blockquote><p>button<br>定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）。<br>如果在HTML表单中使用button元素，不同的浏览器会提交不同的值。Internet Explorer将提交<code>&lt;button&gt;与&lt;button/&gt;</code>之间的文本<br>checkbox<br>定义复选框。<br>file<br>定义输入字段和 “浏览”按钮，供文件上传。<br>hidden<br>定义隐藏的输入字段。<br>image<br>定义图像形式的提交按钮。<br>password<br>定义密码字段。该字段中的字符被掩码。<br>radio<br>定义单选按钮。<br>reset<br>定义重置按钮。重置按钮会清除表单中的所有数据。<br>submit<br>定义提交按钮。提交按钮会把表单数据发送到服务器。<br>text<br>定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。</p></blockquote><h2 id="设置字体风格"><a href="#设置字体风格" class="headerlink" title="设置字体风格"></a>设置字体风格</h2><p>font 简写属性。作用是把所有针对字体的属性设置在一个声明中。<br>font-family 设置字体系列。<br>font-size 设置字体的尺寸。<br>font-size-adjust 当首选字体不可用时，对替换字体进行智能缩放。（CSS2.1 已删除该属性。）<br>font-stretch 对字体进行水平拉伸。（CSS2.1 已删除该属性。）<br>font-style 设置字体风格。<br>font-variant 以小型大写字体或者正常字体显示文本。<br>font-weight 设置字体的粗细。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个用于日常知识积累的笔记&lt;br&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://linmushen.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>实战1</title>
    <link href="http://linmushen.com/2019/04/11/%E5%AE%9E%E6%88%981/"/>
    <id>http://linmushen.com/2019/04/11/实战1/</id>
    <published>2019-04-11T14:40:15.000Z</published>
    <updated>2019-08-18T16:13:04.309Z</updated>
    
    <content type="html"><![CDATA[<p>第一个实战小项目<br><a id="more"></a></p><h2 id="解决问题的起点：步骤"><a href="#解决问题的起点：步骤" class="headerlink" title="解决问题的起点：步骤"></a>解决问题的起点：步骤</h2><ol><li>根据要解决的问题画出流程图</li><li>摘录第一条的关键概念并研究</li><li>创建一个类和对象的层次结构图</li><li>用代码实现各个类，并测试</li><li>重复上述步骤</li></ol><p>**有抽象概念入手，逐渐细化</p><h2 id="各种名字"><a href="#各种名字" class="headerlink" title="各种名字"></a>各种名字</h2><p>根据思路写出一个名词列表作为变量名<br>根据思路写出一个动词列表作为函数名</p><h2 id="对各种操作进行研究"><a href="#对各种操作进行研究" class="headerlink" title="对各种操作进行研究"></a>对各种操作进行研究</h2><p>如：玩家引爆炸弹的工作<br>怎么把游戏状态存储金数据库<br>应该通过学习类似游戏的工作原理来研究</p><h2 id="创建层次图和对象关系图"><a href="#创建层次图和对象关系图" class="headerlink" title="创建层次图和对象关系图"></a>创建层次图和对象关系图</h2><p>类的结构图：</p><ul><li>和其他东西有哪些类似</li><li>那个东西是另一个东西的换个说法而已</li></ul><h2 id="字典真是好用"><a href="#字典真是好用" class="headerlink" title="字典真是好用"></a>字典真是好用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scenes = &#123;</span><br><span class="line">&apos;Death&apos;:Death(),</span><br><span class="line">&apos;Escapepod&apos;:Escapepod(),</span><br><span class="line">&apos;TheBridge&apos;:TheBridge(),</span><br><span class="line">&apos;LaserWeaponArmony&apos;:LaserWeaponArmony(),</span><br><span class="line">&apos;central_corridor&apos;:CentralCorridor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过返回值来简单的引用类</p><ul><li>父类中的函数，若与子类的重名，而且没有被调用，则会被覆盖<h2 id="类中变量的使用"><a href="#类中变量的使用" class="headerlink" title="类中变量的使用"></a>类中变量的使用</h2>类中的被多个类中函数调用的变量要加上self表明位置，否则出现全局变量错误。（而参数不用）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class English(object):   #游戏引擎，用来根据场景名生产变量并切换场景</span><br><span class="line">def __init__(self,scene_map):</span><br><span class="line">self.dizhi = scene_map</span><br><span class="line">def play(self):</span><br><span class="line">current_scene = self.dizhi.opening_scene()</span><br><span class="line">while True:</span><br><span class="line">print &quot;\n--------&quot;</span><br><span class="line"></span><br><span class="line">self.next_scene_name = current_scene.enter()</span><br><span class="line"></span><br><span class="line">current_scene = self.dizhi.next_scene(self.next_scene_name)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class CentralCorridor(Scene):</span><br><span class="line">def enter(self):</span><br><span class="line"></span><br><span class="line">xiao = raw_input(&apos;&gt;&apos;)</span><br><span class="line">if xiao == &apos;1&apos;:</span><br><span class="line">print u&quot;(卫兵倒下，你成功进入下个房间。)&quot;</span><br><span class="line">return &apos;LaserWeaponArmony&apos;</span><br><span class="line">else:</span><br><span class="line">print u&quot;你是个没有幽默感的蠢货，哥顿人怒火中烧，把你打成了马蜂窝。&quot;</span><br><span class="line">return&apos;Death&apos;</span><br></pre></td></tr></table></figure><p>而变量xiao则不用。</p><h2 id="init"><a href="#init" class="headerlink" title="init()"></a><strong>init</strong>()</h2><p>直接实例化类，相当于直接调用其中的init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Map(object):</span><br><span class="line">def __init__(self,start_scene):</span><br><span class="line">self.dizhi = start_scene</span><br><span class="line">def next_scene(self,scene_name):</span><br><span class="line">return Map.scenes.get(scene_name)   #对获取的类进行实例化</span><br><span class="line">def opening_scene(self):</span><br><span class="line">return self.next_scene(self.dizhi)</span><br><span class="line"></span><br><span class="line">a_map = Map(&apos;central_corridor&apos;)</span><br></pre></td></tr></table></figure><p>a_map = Map(‘str’)<br>等价于<br>a_map = Map.<strong>init</strong>(‘str’)<br>就相当于<br>a_map.dizhi = str</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一个实战小项目&lt;br&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://linmushen.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>有关面向对象编程</title>
    <link href="http://linmushen.com/2019/04/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://linmushen.com/2019/04/08/面向对象/</id>
    <published>2019-04-08T14:39:44.000Z</published>
    <updated>2019-08-18T16:13:04.308Z</updated>
    
    <content type="html"><![CDATA[<p>把所有有关面向对象编程的对象汇集到了一起<br><a id="more"></a></p><h1 id="习题四十"><a href="#习题四十" class="headerlink" title="习题四十"></a>习题四十</h1><p>主要是有关面向对象编程的介绍<br><strong>python中的类就好像是创造对象的模板一样</strong></p><h2 id="模块的概念："><a href="#模块的概念：" class="headerlink" title="模块的概念："></a>模块的概念：</h2><ol><li>模块是包含函数和变量的python文件</li><li>可以导入模块</li><li>可以用.操作调用模块中的函数和变量<br><strong> 与字典的类比：</strong></li></ol><ul><li>对于字典—键来获取值（[键]）</li><li>对于模块—键相当于函数或变量，用函数或变量获取操作（.函数)<br><strong> 模块就好像是用来储存代码的字典，通过.操作进行访问。</strong><h2 id="通过模块类比-类"><a href="#通过模块类比-类" class="headerlink" title="通过模块类比 类"></a>通过模块类比 类</h2><strong> 好像一个迷你模块 </strong><br>类与模块的不同，可以使用一个类重复创建多个类，而类与类之间互不干涉。（而模块不行，导入一次之后，只有一份内容）<br><strong> 对象与模块的导入类比 </strong><br>实例化—创建—得到一个将之前创建的self空对象赋值给这个变量。<br>实现方法：</li></ul><ol><li>调用一个类<blockquote><p>object = class()<br>对象好像就是模块被导入后产生的东西一样。</p></blockquote></li></ol><h1 id="习题四十一"><a href="#习题四十一" class="headerlink" title="习题四十一"></a>习题四十一</h1><h2 id="有关面向对象编程的概念"><a href="#有关面向对象编程的概念" class="headerlink" title="有关面向对象编程的概念"></a>有关面向对象编程的概念</h2><ul><li>类：告诉python要创建新类型的东西</li><li>对象：最基本的东西，或某个东西的实例</li><li>实例：python创建时得到的东西</li><li>self：在类的函数中，用来指代被访问的对象或实例中的变量</li><li>继承：一个类可以继承另一个类的特性</li><li>组合：一个类可以将另一类作为它的部件</li><li>属性：源自组合，通常是一个变量</li><li>是什么（is-a)：用来描述继承关系</li><li>有什么（has-a):用来描述组合关系，或者某个东西有某个特性。<h2 id="描述代码的句子"><a href="#描述代码的句子" class="headerlink" title="描述代码的句子"></a>描述代码的句子</h2></li><li>class X(Y):创建一个叫X的类，他是Y的一种</li><li>class X(object):def <strong>init</strong>(self,J):类中有init函数来接收self和J参数</li><li>class X(object):def M(self,J):类中有M函数来接收self和J参数</li><li>foo = X():将foo设为X的一个实例</li><li>foo.M(J):从实例foo中找到函数M并使用self和J参数调用他</li><li>foo.K=Q:从实例中获得K属性并设为Q。</li></ul><h1 id="习题四十二"><a href="#习题四十二" class="headerlink" title="习题四十二"></a>习题四十二</h1><!--more--><h2 id="区别对象与类的技巧："><a href="#区别对象与类的技巧：" class="headerlink" title="区别对象与类的技巧："></a>区别对象与类的技巧：</h2><p>is-a：是什么，用于两个类之间的关系<br>has-a:有什么，两者无共同点，仅是互为参照</p><h2 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h2><p><strong>object 类是所有类的父类。换言之，其它的任何一个类，都直接或间接地继承了 object 类（的属性和方法）。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class namefu(object):  # object几乎没有意义，于函数中的不同</span><br><span class="line">def __init__(self,name): </span><br><span class="line">self.bianliang=name</span><br><span class="line">#只是创建了一个名为bianliang的变量，并把参数name赋给他。（self.作用是指明其在类中）</span><br><span class="line"></span><br><span class="line">class nmaezi(namefu):</span><br><span class="line">def __init__(self,name,name2):</span><br><span class="line">#在完成基类中的任务后，创建新变量名bianliang2并将参数2的值赋值给新变量</span><br><span class="line">self.bianliang2=name2</span><br><span class="line">def zihanshu(self,j):</span><br><span class="line">#类中的函数参数第一个必须是self</span><br><span class="line">print j</span><br><span class="line"></span><br><span class="line">shili = namezi(&quot;vauleforname&quot;,&quot;vauleforname2&quot;)</span><br><span class="line">    #将子类实例化，并赋值</span><br><span class="line">    #相当于导入这个类</span><br><span class="line">shili.zihanshu(&quot;shuchu&quot;)</span><br><span class="line">    #相当于调用这个类里的子函数并为子函数赋值</span><br></pre></td></tr></table></figure></p><h2 id="子类中的函数与父类中的函数的区别"><a href="#子类中的函数与父类中的函数的区别" class="headerlink" title="子类中的函数与父类中的函数的区别"></a>子类中的函数与父类中的函数的区别</h2><ol><li>子类中函数只可用于该实例化子类的变量调用</li><li>父类中的函数可以被每一个实例化的子类调用<br>super.(子类,self).父类中的函数（）：</li></ol><ul><li>用来解决多重调用问题。（继承父类的顺序表）<h2 id="问题记录："><a href="#问题记录：" class="headerlink" title="问题记录："></a>问题记录：</h2></li><li>怎么使用列表和字典创建一些新的一对多的有多个关系？</li></ul><h1 id="习题四十四"><a href="#习题四十四" class="headerlink" title="习题四十四"></a>习题四十四</h1><p><strong>继承与合成的简单介绍</strong><br><!--more--></p><h2 id="作者的警告"><a href="#作者的警告" class="headerlink" title="作者的警告"></a>作者的警告</h2><p>大部分使用合成的场合都可以用合成取代，而多重继承则要不惜一切代价</p><h2 id="继承（据说是邪恶女巫）"><a href="#继承（据说是邪恶女巫）" class="headerlink" title="继承（据说是邪恶女巫）"></a>继承（据说是邪恶女巫）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>继承：用来知名一个类中大部分或全部分都是从一个父类中获得的</p><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>class Foo(bar) 创建一个叫Foo的类，并让他继承Bar。（Foo的实例所具有的功能都工作在Foo的实例上）</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>可以将Foo与Bar的通用功能都放在Bar里，并在Bar中添加一些特殊性质</p><h3 id="三种交互方式"><a href="#三种交互方式" class="headerlink" title="三种交互方式"></a>三种交互方式</h3><ol><li>子类动作完全等同于父类动作（隐式继承）</li><li>子类动作完全覆盖父类动作（？）</li><li>子类动作部分替换父类动作。</li></ol><h2 id="隐式继承"><a href="#隐式继承" class="headerlink" title="隐式继承"></a>隐式继承</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>在父类里定义了一个函数但没有在子类中定义，会发生隐式继承。</p><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Parent(object):</span><br><span class="line">def implicit(self):</span><br><span class="line">print &quot;Parent implicit()&quot;</span><br><span class="line"></span><br><span class="line">class Child(Parent):</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">dad = Parent()</span><br><span class="line">son = Child()</span><br><span class="line">dad.implicit()</span><br><span class="line">son.implicit()</span><br></pre></td></tr></table></figure><p>其中子类没有任何细节上的修改，所以他继承了父类所有的行为</p><h2 id="显式覆盖"><a href="#显式覆盖" class="headerlink" title="显式覆盖"></a>显式覆盖</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>需要让子类里的函数有一个不同的行为，需要覆盖父类的函数（只要在子类中定义一个相同名称的函数就可以）</p><h3 id="例如-1"><a href="#例如-1" class="headerlink" title="例如"></a>例如</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Parent(object):</span><br><span class="line">def override(self):</span><br><span class="line">print &quot;Parent override()&quot;</span><br><span class="line">class Child(Parents):</span><br><span class="line">def override(self):</span><br><span class="line">print&quot;Child override()&quot;</span><br><span class="line">dad = Parent()</span><br><span class="line">son = Child()</span><br><span class="line"></span><br><span class="line">dad.override()</span><br><span class="line">son.override()</span><br></pre></td></tr></table></figure><p>在子类中重新定义的函数在此取代父类中的函数</p><h2 id="在进行前后进行后替换"><a href="#在进行前后进行后替换" class="headerlink" title="在进行前后进行后替换"></a>在进行前后进行后替换</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>目的是在父类中定义的内容运行之前或之后在修改行为</p><h3 id="例如-2"><a href="#例如-2" class="headerlink" title="例如"></a>例如</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Parent(object):</span><br><span class="line">def override(self):</span><br><span class="line">print &quot;Parent override()\n&quot;</span><br><span class="line">class Child(Parent):</span><br><span class="line">def override(self):</span><br><span class="line">print&quot;Child override() before Parent&quot;</span><br><span class="line">super(Child,self).override()</span><br><span class="line">print&quot;Child override() after Parent&quot;</span><br><span class="line">dad = Parent()</span><br><span class="line">son = Child()</span><br><span class="line"></span><br><span class="line">dad.override()</span><br><span class="line">son.override()</span><br></pre></td></tr></table></figure><p>用super获取并访问parent类。<br>（super（）就是运行父类中的函数）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前提：父类中有一个dad（）函数</p><ol><li>在子类中只写dad（）而不写内容（pass），叫隐式继承，执行父类函数中的内容，</li><li>在子类中写dad（）其中又有内容（与父类中的不一样），只执行子类的内容，叫显示继承（覆盖）。</li><li>调用super（）函数，执行子类到super（）函数位置执行父类，然后继续执行子类（相当于将父类导入）。</li><li>值得注意的是，只要是继承，在子类中没有重名的函数，默认被先执行，而且发生隐式继承<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3>定义的子类继承了多个类<h3 id="例如-3"><a href="#例如-3" class="headerlink" title="例如"></a>例如</h3>class superfoo(dad,mom)<br>superfoo类同时继承了dad和mom类 <h3 id="发生情况"><a href="#发生情况" class="headerlink" title="发生情况"></a>发生情况</h3>如果出现隐式动作，则要使用固定顺序回到类的层次逐个检查类。<br>而这个固定顺序就是“方法解析顺序”（MRO)（C3算法）<br>运用super()这样把继承关系弄糟，python会找到正确的函数。<h3 id="常用情况"><a href="#常用情况" class="headerlink" title="常用情况"></a>常用情况</h3>常用情况是在基类的<strong>init</strong>()函数中使用<br>对子类做一些事情，然后再对父类进行初始化<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3>super（子类，self）.<strong>init</strong>()</li></ol><p>##合成</p><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>通过调用模块里的函数来实现继承</p><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Other(object):</span><br><span class="line">def override(self):</span><br><span class="line">print&quot;Other override()&quot;</span><br><span class="line"></span><br><span class="line">def implicit(self):</span><br><span class="line">print&quot;Other implicit()&quot;</span><br><span class="line"></span><br><span class="line">def altered(self):</span><br><span class="line">print&quot;Other altered()&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Child(object):</span><br><span class="line">def __init__(self):</span><br><span class="line">self.other = Other()</span><br><span class="line">#用Child里的变量实例化other类</span><br><span class="line">def implicit(self):</span><br><span class="line">print&quot;Child override()&quot;</span><br><span class="line"></span><br><span class="line">def override(self):</span><br><span class="line">print &quot;Child override()&quot;</span><br><span class="line">def altered(self):</span><br><span class="line">print&quot;Child Before other altered()&quot;</span><br><span class="line">self.other.altered()</span><br><span class="line">#通过实例化other类来调用other中的函数</span><br><span class="line">print&quot;Child after altered()&quot;</span><br><span class="line"></span><br><span class="line">son = Child()</span><br><span class="line">son.implicit()</span><br><span class="line">son.override()</span><br><span class="line">son.altered()</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>合成就是在类2中对一个类1进行实例化并且调用类1的函数的操作</p><h2 id="对继承与合成的总结"><a href="#对继承与合成的总结" class="headerlink" title="对继承与合成的总结"></a>对继承与合成的总结</h2><blockquote><p>继承与合成说到底只是解决代码复用的问题</p><blockquote><p>继承可以隐含基类中的功能<br>而合成则是用别的类和其中的函数达到相同的目的</p></blockquote></blockquote><h3 id="作者的建议"><a href="#作者的建议" class="headerlink" title="作者的建议"></a>作者的建议</h3><ol><li>不惜一切代价避免多重继承</li><li>如果一些代码会在不同位置和场合应用到，就应用合成把他们做成模块（类）</li><li>如果代码之间有清楚的联系，可以通过共性联系起来的时候使用继承</li></ol><p><strong> python的思想：</strong><br><strong> “一切都是对象！” </strong><br><!--more--><br>面向对象：python从设计之初就是一门面向对象的语言<br>面向对象编程就是对类与对象的使用<br>过程：将实际问题抽象化成’类’，然后对基类进行继承（构造函数），将类实例化成实例，通过调用实例中的函数进行使用。</p><blockquote><p>类：对函数进行归类，以防止命名冲突。</p><blockquote><p>不能实例化的类叫静态类，其本质相当于一个归纳函数的集合。</p></blockquote><blockquote><p>能够实例化的类，通过构造函数变化出行为不大一样的实例的类，一般直接称做类。</p></blockquote><p>定义子类，也叫做继承。</p><blockquote><p>对父类中的函数进行添加或覆盖。</p><blockquote><p>不同子类用不同内容覆盖一个相同函数，产生不同结果，叫多态性<br>调用子类叫实例化类。</p></blockquote></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Human(object):     #定义基类（类）</span><br><span class="line">    def __init__(self, name=&apos;泥人&apos;):</span><br><span class="line">        self.name = name </span><br><span class="line">self.hands = 2 </span><br><span class="line">self.legs = 2 </span><br><span class="line">def introduce_self(self):  </span><br><span class="line"> print(&apos;我是%s&apos; % self.name)</span><br><span class="line">class Female(Human):    #定义子类（继承基类）</span><br><span class="line">def __init__(self, name):  #对基类中的函数进行微调。</span><br><span class="line">super().__init__(name) </span><br><span class="line">self.hair = random.randint(3, 5) </span><br><span class="line">self.power = random.randint(1, 3) </span><br><span class="line">self.married = False </span><br><span class="line">def work():         #给基类添加函数</span><br><span class="line">print(&apos;%s采摘了一些果子&apos; % self.name) </span><br><span class="line">class Male(Human):      #定义第二个子类</span><br><span class="line">def __init__(self, name): </span><br><span class="line">super().__init__(name) </span><br><span class="line">self.hair = random.randint(0, 2)</span><br><span class="line">self.power = random.randint(2, 5) </span><br><span class="line">self.married = False </span><br><span class="line">def work():         #在不同子类中的同名函数，调用时候可以出现多态性。</span><br><span class="line">    print(&apos;%s出去打猎了一天&apos; % self.name) </span><br><span class="line">def marry(self, other): </span><br><span class="line">if self.married is True or other.married is True: </span><br><span class="line">raise ValueError(&apos;法律不支持多次结婚&apos;) </span><br><span class="line">if instance(other, Female): </span><br><span class="line">self.married = True </span><br><span class="line">other.married = True </span><br><span class="line">else:</span><br><span class="line">raise TypeError(&apos;法律不支持同性结婚&apos;)</span><br><span class="line">a = Male(&apos;name&apos;)#调用子类（实例化）</span><br><span class="line">a.introduce_self()                          #调用基类中的函数</span><br><span class="line">a.work()                                    #调用子类中的函数</span><br></pre></td></tr></table></figure><p>以上是目前为止对面向对象编程的初步理解。</p><h1 id="4-9补"><a href="#4-9补" class="headerlink" title="4.9补"></a><strong>4.9补</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyStuff(object):    </span><br><span class="line">def __init__(self):         #对创建的空对象进行初始化。(值得注意的是，init处左右的下划线都是两个)</span><br><span class="line">self.tangerine = &quot;And now a thousand years between&quot;  </span><br><span class="line">def apple(self):     </span><br><span class="line">print&quot;I AM CLASSY APPLES!&quot;</span><br><span class="line">thing = MyStuff()   </span><br><span class="line">thing.apple()</span><br><span class="line">print thing.tangerine</span><br></pre></td></tr></table></figure><blockquote><p>将类进行实例化(相当于调用函数），其中，self相当于一个空对象（其中包含了类中所有函数）<br>  如果有——init函数，则在创建空对象的同时，对空对象进行了初始化操作。<br>  这一步操作后，self空对象被赋给thing变量。<br>  值得注意的是，类stuff并没有直接被使用，而是被用来创建一个与这个类有相同属性的副本<br>  thing 相当于导入了的模块，用.操作调用其中的函数</p></blockquote><h1 id="4-10补"><a href="#4-10补" class="headerlink" title="4.10补"></a>4.10补</h1><p>类与对象没有真正的不同，只是不同时间下的名字不同<br>类是一个用来描述具有同类属性的实例的概括性词汇。（不是一个具体的东西）<br>对象属于某个类，某个类又可能属于某个类。</p><blockquote><p>来自习题四十二的例子<br>鱼—-类—-具有’有鳍，会游水’的属性<br>泥鳅–属于鱼，又不同于鱼—-也是一个类—-具有鱼的属性又具有泥鳅特有的属性’不仅有鳍会游水，还会钻洞’<br>小李被厨子炖了—其中一条泥鳅—–是一个实例化的泥鳅（泥鳅的实例）—是一个对象—-小李有上述属性还有特有的被顿了的属性，<strong> 并且被使用（被大厨）</strong></p><blockquote><p>对象（小李）属于某个类（泥鳅）属于另一个类（鱼）</p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把所有有关面向对象编程的对象汇集到了一起&lt;br&gt;
    
    </summary>
    
      <category term="python学习" scheme="http://linmushen.com/categories/python-study/"/>
    
    
  </entry>
  
  <entry>
    <title>语法内容</title>
    <link href="http://linmushen.com/2019/04/03/%E8%AF%AD%E6%B3%95%E5%86%85%E5%AE%B9/"/>
    <id>http://linmushen.com/2019/04/03/语法内容/</id>
    <published>2019-04-03T15:36:32.000Z</published>
    <updated>2019-08-18T15:15:28.598Z</updated>
    
    <content type="html"><![CDATA[<p>为了更方便的记笔记，我搭建了这个博客<br> <a id="more"></a></p><h1 id="习题三十七：复习各种符号"><a href="#习题三十七：复习各种符号" class="headerlink" title="习题三十七：复习各种符号"></a>习题三十七：复习各种符号</h1><ul><li>总注</li></ul><ol><li>True为任意非0或非空的值。0或空为False。</li><li>Traceback，回溯，一种错误信息</li><li>python用异常对象表示异常情况。异常对象未被捕捉或处理，则会用回溯的方式结束程序</li><li>python中对象包含三个基本元素：id（身份标识），type（数据类型），value（值）</li></ol><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h2><ul><li>and </li><li>not</li><li>or</li><li>from </li><li>import</li><li>del</li><li>while</li><li>as</li><li>global</li><li>with</li><li>if/elif/else</li><li>assert</li><li>pass</li><li>yield</li><li>break</li><li>expect</li><li>finally</li><li>print</li><li>class</li><li>exec</li><li>in</li><li>raise</li><li>continue</li><li>is</li><li>return</li><li>def</li><li>for</li><li>lambda</li><li>try</li></ul><hr><h2 id="逻辑关键词-and-or-not"><a href="#逻辑关键词-and-or-not" class="headerlink" title="逻辑关键词(and,or,not)"></a>逻辑关键词(and,or,not)</h2><h3 id="优先级："><a href="#优先级：" class="headerlink" title="优先级："></a>优先级：</h3><blockquote><p>优先级从大到小为：</p><blockquote><p>not&gt;and&gt;or</p></blockquote></blockquote><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值:"></a>返回值:</h3><blockquote><h4 id="and：（x为真返回y，x为假返回x）"><a href="#and：（x为真返回y，x为假返回x）" class="headerlink" title="and：（x为真返回y，x为假返回x）"></a>and：（x为真返回y，x为假返回x）</h4><blockquote><p>and的返回值是决定表达式结果的值。</p><blockquote><p>如x and y：若x为真，则y决定了表达式的结果，返回值为y（与表达式真假无关，只要x为真，就返回y）。若x为假，则返回值为x。</p></blockquote></blockquote></blockquote><blockquote><h4 id="or-not："><a href="#or-not：" class="headerlink" title="or/not："></a>or/not：</h4><blockquote><p>x or y有一个结果真，返回的结果就是真。</p><blockquote><p>print(x or y):x为真输出x，x为假输出y。</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>not 布尔表达式 ：返回与表达式结果相反的值。</p><blockquote><p>print(not 表达式）：只输出False/Ture </p></blockquote></blockquote></blockquote><p>##print语句</p><blockquote><p>print会自动在末尾加\n，如果不需要，直接在最末加‘，’。（如果有字符串，在引号外）</p><p>输出变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line">print num</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print 1</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;lin mu shen &quot;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出字符串加变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=&apos;lin&apos;</span><br><span class="line">print&quot;str=&quot;,str</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>格式化输出数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line">print&apos;num= %d&quot; %num</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>格式化输出字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str=&apos;lin&apos;</span><br><span class="line">print &apos;str= %s&apos; %str    #输出lin</span><br><span class="line">print &apos;str=.1%s&apos; %str   #输出l</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>格式化输出原样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str=&apos;lin&apos;</span><br><span class="line">num=1</span><br><span class="line">print &apos;str=%r,num=%r&apos; %(str,num)   # str=&apos;lin&apos;,num=1</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="模块的引入（import-from…import）"><a href="#模块的引入（import-from…import）" class="headerlink" title="模块的引入（import/from…import）"></a>模块的引入（import/from…import）</h2><h3 id="import语句的使用"><a href="#import语句的使用" class="headerlink" title="import语句的使用"></a>import语句的使用</h3><blockquote><p>导入模块：</p><blockquote><p>import 模块<br>这个声明将整个模块导入</p></blockquote></blockquote><blockquote><p>调用模块中的函数：</p><blockquote><p>模块名.函数名</p></blockquote></blockquote><blockquote><p>无论执行多少次import，模块只会被导入一次。</p></blockquote><h3 id="from…import语句的使用"><a href="#from…import语句的使用" class="headerlink" title="from…import语句的使用"></a>from…import语句的使用</h3><blockquote><p>导入模块中的指定部分：</p><blockquote><p>from 模块名 import 函数名<br>这个声明将模块中的特定函数导入</p></blockquote></blockquote><blockquote><p>调用函数:</p><blockquote><p>函数名()</p></blockquote></blockquote><h3 id="from…import-的使用"><a href="#from…import-的使用" class="headerlink" title="from…import * 的使用"></a>from…import * 的使用</h3><blockquote><p>导入模块中所有内容:</p><blockquote><p>from 模块名 import *</p></blockquote></blockquote><blockquote><p>调用模块中的任意函数：</p><blockquote><p>函数名（）</p></blockquote></blockquote><h3 id="improt…as…"><a href="#improt…as…" class="headerlink" title="improt…as…"></a>improt…as…</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import game_functions as gf</span><br></pre></td></tr></table></figure><p>为导入的模块起一个代号</p><h2 id="del语句"><a href="#del语句" class="headerlink" title="del语句"></a>del语句</h2><ul><li><p>del语句作用在变量上，而不是数据对象上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line">b=a</span><br><span class="line">del a</span><br><span class="line">print b</span><br><span class="line">del a,b     #也可以使用del一次删除多个变量的引用</span><br></pre></td></tr></table></figure></li><li><p>输出结果为1。</p></li><li>del只解除了a对1的引用，并没有删除数据a。</li></ul><h2 id="定义函数（def）"><a href="#定义函数（def）" class="headerlink" title="定义函数（def）"></a>定义函数（def）</h2><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def name(形式参数):</span><br><span class="line">   执行语句</span><br><span class="line">name(实际参数）</span><br></pre></td></tr></table></figure></p><p>值得一提，形式参数是一个局部变量，而实际参数是一个全局变量，调用函数的过程中，实际参数被赋值给形式参数。</p><h2 id="定义一个匿名函数（lambda表达式）"><a href="#定义一个匿名函数（lambda表达式）" class="headerlink" title="定义一个匿名函数（lambda表达式）"></a>定义一个匿名函数（lambda表达式）</h2><p>起到一个函数速写的作用</p><blockquote><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def name(n)</span><br><span class="line">return lambda x: x*n#定义了一个匿名函数</span><br><span class="line">double=name(2)              #把函数值赋给变量</span><br><span class="line">print double(8)#double还需要一个变量</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出：<br>16</p></blockquote><h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p>return将结果与程序控制权一起返回到调用位置。<br>程序运行到第一个return位置即返回（退出函数）（但在try/finally情况下不是，在try遇到return，也会继续执行finally）（也就是说，函数可以有多个return语句）<br>如：返回两个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return x,y</span><br></pre></td></tr></table></figure></p><h2 id="成员运算符（in，not-in）"><a href="#成员运算符（in，not-in）" class="headerlink" title="成员运算符（in，not in）"></a>成员运算符（in，not in）</h2><ol><li>配合if用来查找元素是否在可迭代对象中<blockquote><p>if x in list   如果在，返回真<br>if x  not in list   如果不在，返回真</p></blockquote></li><li>配合for逐个取可迭代对象的元素<blockquote><p>for i in list   i取遍list中每一个元素</p></blockquote></li></ol><h2 id="身份运算符（is-，is-not）"><a href="#身份运算符（is-，is-not）" class="headerlink" title="身份运算符（is ，is not）"></a>身份运算符（is ，is not）</h2><p>is与==一样，都是对对象进行比较判断作用的运算符<br>但对对象比较判断的内容不同<br>is用来比较对象id是否相同。<br>可以用print id（x）来查看x的id</p><h2 id="global语句"><a href="#global语句" class="headerlink" title="global语句"></a>global语句</h2><blockquote><p>用于定义全局变量<br>global用于给定义在函数外的变量赋值，用global表明，这是个全局变量而非局部变量。</p></blockquote><blockquote><p>global语句可以在函数内对定义在函数外的变量赋值<br>赋值产生的变化也同时反映在主块中的变量</p><p>使用：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i=20</span><br><span class="line">def somefau()</span><br><span class="line">  global i</span><br><span class="line">  print i</span><br><span class="line">  i=10</span><br><span class="line">  print&quot;2nd=&quot;,i</span><br></pre></td></tr></table></figure><blockquote><p>输出结果</p><blockquote><p>20</p></blockquote></blockquote><blockquote><blockquote><p>2nd=10<br>通过global实现了在函数内对主块变量的赋值</p></blockquote></blockquote><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while型"><a href="#while型" class="headerlink" title="while型"></a>while型</h3><blockquote><h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句:"></a>while循环语句:</h4><blockquote><p>基本形式：（注：执行语句前要有缩进）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 判断条件：</span><br><span class="line">  执行语句...</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>当判断条件为Ture时，则会无限循环。</p></blockquote></blockquote><blockquote><h4 id="while…else语句："><a href="#while…else语句：" class="headerlink" title="while…else语句："></a>while…else语句：</h4><blockquote><p>基本形式：（注：同样要缩进)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while 判断条件：</span><br><span class="line">  执行语句1...</span><br><span class="line">else：</span><br><span class="line">  执行语句2...</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><ul><li>当判断条件为Ture时，执行1。</li><li>当判断条件为False时，执行2。</li></ul></blockquote></blockquote><blockquote><h4 id="while的简单语句组："><a href="#while的简单语句组：" class="headerlink" title="while的简单语句组："></a>while的简单语句组：</h4><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(判断语句）：执行语句</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>当执行语句只有一行时，可以将执行语句与while写在同一行。</p></blockquote></blockquote><blockquote><h4 id="while的附加命令"><a href="#while的附加命令" class="headerlink" title="while的附加命令:"></a>while的附加命令:</h4><blockquote><h5 id="continue："><a href="#continue：" class="headerlink" title="continue："></a>continue：</h5><blockquote><p>continue用于跳过当次循环</p></blockquote></blockquote><blockquote><blockquote><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = 1</span><br><span class="line">while i&lt;10:</span><br><span class="line">    i += 1</span><br><span class="line">    if i%2 == 0:</span><br><span class="line">        continue</span><br><span class="line">    print i</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><blockquote><blockquote><h5 id="break"><a href="#break" class="headerlink" title="break:"></a>break:</h5><blockquote><p>break用于退出循环</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>使用：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line">while 1:</span><br><span class="line">    i+=1</span><br><span class="line">    if i&gt;10:</span><br><span class="line">         break</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="for型"><a href="#for型" class="headerlink" title="for型"></a>for型</h3><blockquote><h4 id="for…in…"><a href="#for…in…" class="headerlink" title="for…in…"></a>for…in…</h4><p>主要用于遍历列表，字符串。</p><blockquote><h5 id="使用-遍历列表）："><a href="#使用-遍历列表）：" class="headerlink" title="使用(遍历列表）："></a>使用(遍历列表）：</h5></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4,5]</span><br><span class="line">for num in list</span><br><span class="line">    print num</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>输出结果：</p><blockquote><p>1</p></blockquote></blockquote><blockquote><blockquote><p>2</p></blockquote></blockquote><blockquote><blockquote><p>3</p></blockquote></blockquote><blockquote><blockquote><p>4</p></blockquote></blockquote><blockquote><blockquote><p>5</p></blockquote></blockquote></blockquote><blockquote><blockquote><h5 id="使用（遍历字符串）："><a href="#使用（遍历字符串）：" class="headerlink" title="使用（遍历字符串）："></a>使用（遍历字符串）：</h5></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for var in &apos;lin&apos;</span><br><span class="line">    print var</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>输出结果：</p><blockquote><p>l</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>i</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>n</p></blockquote></blockquote></blockquote><blockquote><blockquote><h5 id="通过指针变量来进行遍历："><a href="#通过指针变量来进行遍历：" class="headerlink" title="通过指针变量来进行遍历："></a>通过指针变量来进行遍历：</h5></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4,5]</span><br><span class="line">for i in range(5):</span><br><span class="line">    num = list[i]</span><br><span class="line">    print num,</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>输出结果：</p><blockquote><p>1 2 3 4 5</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><h6 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数:"></a>range()函数:</h6><p>range（start，stop,step）可创建一个整数列表：<br>三个参数</p><blockquote><p>start:计数开始位置，默认是0。如range(3)等价于range（0，3）</p></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>stop:计数结束位置，但不包括stop。如range（0，5）中没有5。</p></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>step:步长（每次加的数），默认是1。如range(0,6,2)为[0,1,3,5]</p></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><h4 id="for…in-else"><a href="#for…in-else" class="headerlink" title="for…in:/else:"></a>for…in:/else:</h4></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(10):</span><br><span class="line">    print i</span><br><span class="line">else:</span><br><span class="line">    print i+100</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>for中语句与之前的没有区别，但else只在for正常循环结束后（不是通过break结束）的情况下被执行。</p></blockquote></blockquote><h2 id="占位语句（pass）"><a href="#占位语句（pass）" class="headerlink" title="占位语句（pass）"></a>占位语句（pass）</h2><ul><li>pass不做任何事情，只用作占位。</li><li>没想好函数内容是，在函数内写入一条pass可以避免报错<blockquote><p>像这样：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def unthink()</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></li></ul><h2 id="条件语句（if…elif…else…"><a href="#条件语句（if…elif…else…" class="headerlink" title="条件语句（if…elif…else…)"></a>条件语句（if…elif…else…)</h2><blockquote><blockquote><p>通过一条或多条语句的执行结果（Ture或False)来决定执行的代码块。</p></blockquote></blockquote><blockquote><blockquote><p>要格外注意缩进的问题，没进入一个新代码块，打两个空格</p></blockquote><blockquote><p>使用：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件1：</span><br><span class="line">    执行语句1</span><br><span class="line">elif 判断条件2：</span><br><span class="line">    执行语句2</span><br><span class="line">···</span><br><span class="line">else:</span><br><span class="line">    执行语句n</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>也有类似于while的简单语句组：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if 判断语句：执行语句</span><br></pre></td></tr></table></figure></blockquote><h2 id="捕捉异常并处理（try-except-else-finally）"><a href="#捕捉异常并处理（try-except-else-finally）" class="headerlink" title="捕捉异常并处理（try/except/else/finally）"></a>捕捉异常并处理（try/except/else/finally）</h2><blockquote><p>检测try中的错误，用except捕获异常并处理。<strong> 然后程序返回到try位置 </strong><br>可以做到异常发生时不结束程序。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法:"></a>语法:</h3><p>三者顺序不能乱，且有else就必须有except</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  语句1    #先执行语句1</span><br><span class="line">  ...</span><br><span class="line">except name:</span><br><span class="line">  语句2    #发生name异常，执行语句2，而后通过整个try</span><br><span class="line">  ...</span><br><span class="line">except name1，数据：</span><br><span class="line">  语句3    #发生name1异常，执行语句3，获得数据。数据可以是（as reason 输出程序检测到的错误类型）</span><br><span class="line">except：</span><br><span class="line">  语句3_1  #没有匹配到的异常，执行语句3_1</span><br><span class="line">else:</span><br><span class="line">  语句4    #语句1没有异常，执行此代码</span><br><span class="line">finally:</span><br><span class="line">  语句5    #无论有无异常发生，都会执行语句5</span><br></pre></td></tr></table></figure><blockquote><p>执行语句1，根据语句1发生的异常类型来选择执行的except下的代码块，没有发生异常则执行else下的代码块。</p></blockquote><h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    num1 = raw_input(&apos;输入一个数字&apos;)</span><br><span class="line">    num1 = int(num1)</span><br><span class="line">except ValueError , as reason:</span><br><span class="line">    print &quot;请输入一个数字&quot;, reason</span><br><span class="line">else:</span><br><span class="line">    print num1</span><br><span class="line">finally:</span><br><span class="line">    print &quot;无论如何都执行我&quot;</span><br></pre></td></tr></table></figure><blockquote><p>输入：5<br>输出：</p><blockquote><p>5</p></blockquote><blockquote><p>无论如何都输出我</p></blockquote></blockquote><blockquote><p>输入：a<br>输出：</p></blockquote><blockquote><blockquote><p>请输入一个数字</p></blockquote></blockquote><blockquote><blockquote><p>无论如何都输出我</p></blockquote></blockquote><blockquote><blockquote><p>_(光标，回到try位置）</p></blockquote></blockquote><h2 id="捕捉异常语句并处理（with-as"><a href="#捕捉异常语句并处理（with-as" class="headerlink" title="捕捉异常语句并处理（with as)"></a>捕捉异常语句并处理（with as)</h2><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with expresion as val:</span><br><span class="line">    语句1</span><br></pre></td></tr></table></figure><blockquote><p>执行过程：先执行expresion中的<em>enter</em>（）方法，这个方法的返回值被赋值给val（若没有as val，则返回值被忽略）。接着执行语句1，语句1若出现异常，执行expresion中的<em>exit</em>()方法，若果没有异常，则在执行完毕后执行<em>exit</em>（）方法。</p></blockquote><h3 id="例如"><a href="#例如" class="headerlink" title="例如:"></a>例如:</h3><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(lin.txt) as obj:</span><br><span class="line">    data=obj.read()</span><br></pre></td></tr></table></figure><p>等价于</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    obj=open(lin.txt)</span><br><span class="line">    data=obj.read()</span><br><span class="line">finally:</span><br><span class="line">    obj.close</span><br></pre></td></tr></table></figure><p>也就是说，无论读取文件是否出现异常，都会执行关闭文件句柄这一个操作</p><h2 id="exec-函数"><a href="#exec-函数" class="headerlink" title="exec()函数"></a>exec()函数</h2><blockquote><p>exec函数能够执行复杂的python代码。</p></blockquote><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k=10</span><br><span class="line">exec(&apos;i=10 j=100 anw=i*j*k print anw&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br>10000<br>exec（’str’,’参数’）<br>也可以在参数位置改变k值<br>也就是说，exec（）函数可以执行字符串形式的python代码）<br>如果上面的字符串在一个.txt文本中，也可以用exec（）函数来执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(name.txt) as obj:</span><br><span class="line">    data=obj.read()</span><br><span class="line">exec(data)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出：<br>1000</p></blockquote><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>yield类似中断，一旦执行到yield就会返回变量当前的值，记住这个位置，然后下一次再继续执行yield后的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yield 变量</span><br></pre></td></tr></table></figure></p><h2 id="raise"><a href="#raise" class="headerlink" title="raise()"></a>raise()</h2><p>可以用来引发异常，可以用来传递异常,但是异常对象必须是error或exception的子类。<br>引发异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise Exception(&quot;抛出一个异常&quot;)</span><br></pre></td></tr></table></figure></p><h2 id="assert断言"><a href="#assert断言" class="headerlink" title="assert断言"></a>assert断言</h2><p>相当于一个 raise-if-not<br>即：assert后的布尔表达式为假时，抛出一个异常。</p><h2 id="assert-布尔表达式"><a href="#assert-布尔表达式" class="headerlink" title="assert 布尔表达式"></a>assert 布尔表达式</h2><p>表达式为假时，抛出异常<br>添加异常参数的语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 布尔表达式，&apos;一个字符串&apos;</span><br></pre></td></tr></table></figure></p><p>表达式为假时，抛出异常，并返回字符串。</p><h1 id="变量的容器们"><a href="#变量的容器们" class="headerlink" title="变量的容器们"></a>变量的容器们</h1><p>本笔记主要用来记录关于，列表，字典，文件等的特性<br><!--more--></p><h2 id="总注"><a href="#总注" class="headerlink" title="总注"></a>总注</h2><ol><li>列表只可以通过数字作为索引。（只能通过数来来获取列表中的元素）</li><li>字典可以通过任何东西找到其中的元素。（字典可以将一个事物和另一个事物关联）<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><strong> 专供有序排列的数据使用 </strong><h3 id="列表的创建"><a href="#列表的创建" class="headerlink" title="列表的创建"></a>列表的创建</h3>list=[‘python’,’lin’,1,2,3]<blockquote><p>也就是说，列表中的元素不需要一定同类型</p></blockquote></li></ol><h3 id="列表的操作包括：索引，切片，加，乘，检查成员"><a href="#列表的操作包括：索引，切片，加，乘，检查成员" class="headerlink" title="列表的操作包括：索引，切片，加，乘，检查成员"></a>列表的操作包括：索引，切片，加，乘，检查成员</h3><blockquote><p>索引（正向读取）—var=list[0]—–var=’python’。<br>索引（逆向读取）—var=list[-1]—-var=3—–(-1就是倒数第一个<br>索引(替换）—var=2。list[2]=var—-list2=[‘python’,’lin’,2,2,3]</p><p>切片—lis=list[0:3]—lis=[‘python’,’lin’,1]（包括头不包括尾）</p><p>加(也可以用list.extend（lis））—–lit=lis+list—-lit=<br>[‘python’,’lin’,1,’python’,’lin’,1,2,3]</p></blockquote><blockquote><p>乘—–lis2=list[2:5] lis3=lis2*2—-lis3=[1,2,3,1,2,3]</p></blockquote><h3 id="通过内置函数和方法，可以实现"><a href="#通过内置函数和方法，可以实现" class="headerlink" title="通过内置函数和方法，可以实现:"></a>通过内置函数和方法，可以实现:</h3><ul><li>比较（cmp(a,b)，</li><li>添加成员(list.append(obj)(obj可以是列表，也可以是成员)，</li><li>计算长度（len（a))，</li><li>返回最值(max(a);min(a)),</li><li>统计某成员出现次数（list.count(obj)),</li><li>反向排序（list.reverse())，</li><li>移除特定成员（list.remove（obj）），</li><li>移除特定位置成员（list.pop(-1)(-1为最后一项，0为第一个，1为第二个…)</li><li>找出特定对象的索引位置（list.index(obj))(找出obj的索引位置）</li><li>将对象插入特定位置（list.insert（index，obj））</li><li>对原列表进行排序（list.sort())</li></ul><h3 id="列表与字符串的转化"><a href="#列表与字符串的转化" class="headerlink" title="列表与字符串的转化"></a>列表与字符串的转化</h3><h4 id="列表-gt-字符串"><a href="#列表-gt-字符串" class="headerlink" title="列表 =&gt; 字符串"></a>列表 =&gt; 字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list=[&apos;lin&apos;,&apos;mu&apos;,&apos;shen&apos;]</span><br><span class="line">print &apos; &apos;.join(list)</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote></blockquote><p>lin mu shen</p><p>用字符串的形式显示并用空格分隔列表中的成员。</p><h4 id="字符串-gt-列表"><a href="#字符串-gt-列表" class="headerlink" title="字符串 =&gt; 列表"></a>字符串 =&gt; 列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var=&apos;lin mu shen&apos;</span><br><span class="line">list=var.split(&apos; &apos;)</span><br><span class="line">print list</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote></blockquote><p>[‘lin’,’mu’,’shen’]</p><p>以空格为每一个成员分隔点创建列表。</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>可以存储任意型变量（值可以是任意型数据，但键只可以是字符串，数字或元组。）<br><strong> 就像一个查询表 </strong></p><h3 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h3><p>键与值用冒号分割。每对键值之间用逗号分割。整个字典用花括号括起来。</p><blockquote><p>dic={‘abd’:1234,’lin’:’mushen’}</p></blockquote><h3 id="访问字典里的值："><a href="#访问字典里的值：" class="headerlink" title="访问字典里的值："></a>访问字典里的值：</h3><p>把相应的键放入[]中</p><blockquote><p>dic[‘abc’]</p></blockquote><h3 id="修改字典："><a href="#修改字典：" class="headerlink" title="修改字典："></a>修改字典：</h3><h4 id="增加："><a href="#增加：" class="headerlink" title="增加："></a>增加：</h4><p>dic[‘python’]=’func’</p><h4 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h4><p>dic[‘python’]=’very fun’</p><h4 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h4><ol><li>删除单一成员：<blockquote><p>del dic[‘python’]</p></blockquote></li><li>清空字典：<blockquote><p>dic.clear()</p></blockquote></li><li>删除字典：<blockquote><p>del dic</p></blockquote><h3 id="字典的特性："><a href="#字典的特性：" class="headerlink" title="字典的特性："></a>字典的特性：</h3></li><li>键不可以重复，一旦重复，后一个覆盖前一个</li><li>键不可以更改。（列表不可以当键）</li><li>字典内容是无序的。<h3 id="有关字典的函数和方法："><a href="#有关字典的函数和方法：" class="headerlink" title="有关字典的函数和方法："></a>有关字典的函数和方法：</h3><h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4></li><li>cmp(dic1,dic2)—–比较两个字典中的元素</li><li>len（dic）—–计算键（元素）的总数</li><li>str(dic)—–用字符串的形式输出字典</li><li>type(value)—-返回变量类型（value=dic时，返回字典）<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4></li><li>dec.clear()—-清空字典中内容</li><li>dic.copy()—–返回一个字典的浅复制（浅复制：只复制一级目录，二级的不复制（例如值是一个列表，则只复制列表名，列表中内容不复制）<blockquote><p>与直接赋值（dic1=dic的区别：dic1只是对dic中的对象进行了引用，如果dic对象发生改变，则dic1也改变，而复制不会）</p></blockquote></li><li>dic.get(key,default=value)—-返回指定键的值，如果键不存在，则返回default的值</li><li>dic.setdefault(key,default=value)—-返回指定键值，若键不存在则将value添加为该键的值</li><li>dic.has_key(key)—–判断键是否在字典中，若在，返回Ture，不在返回False</li><li>dic.items()—–返回列表形式的可遍历的元组数组（将一组键与值当作一个元组，所有元组当作一个列表）</li><li>dic.keys()—–以列表返回一个字典中所有的键。</li><li>dic.values()—以列表返回一个字典中所有的值</li><li>dic.update(dic2)—将dic2的键值更新到dic中</li><li>dic.popitem()—-随机返回并删除字典中的一对键值</li><li>dic.pop(‘key’，value)—-返回并删除指定键对应的值，若键值不存在，返回value。</li><li>dic.fromkeys(seq,value)—-以序列（列表等）中的元素做键，value为所有键的值。</li></ol><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>总注：</p><ol><li>数据类型是不允许改变的</li></ol><h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>True</li><li>False</li><li>None</li><li>strings</li><li>numbers</li><li>floats</li><li>lists</li></ul><h2 id="True-False和None"><a href="#True-False和None" class="headerlink" title="True,False和None"></a>True,False和None</h2><p>都是布尔值</p><h2 id="strings（字符串）"><a href="#strings（字符串）" class="headerlink" title="strings（字符串）"></a>strings（字符串）</h2><ol><li><p>创建字符串,使用单引号或双引号创建字符串,python中单个字符也作为字符串</p><blockquote><p>如：value=’strings’</p></blockquote></li><li><p>访问字符串中断值</p><blockquote><p>如：let=value[1]—-t<br>   lets=value[1:5]—–trin（包括头但不包括尾）</p></blockquote></li><li><p>字符串的更新</p><blockquote><p>如：valuess=value[:4]+lins——strlins(从冒号后面的是更新启始位，相当于添加字符串的0位）</p></blockquote></li></ol><h2 id="numbers（数字）"><a href="#numbers（数字）" class="headerlink" title="numbers（数字）"></a>numbers（数字）</h2><p>该数据类型用于存储数字<br>python支持四种不同的数据类型</p><ol><li>整型（int)—-正数或负数，不带有小数点<blockquote><p>如： var=10  var=-100</p></blockquote></li><li>长整型（long int）—-无限大小的整数，末尾带有大写或小写的L<blockquote><p>如： var=11112222L</p></blockquote></li><li>浮点型（floating point real values）—-由整数部分和小数部分组成，也可以使用科学记数法<blockquote><p>如：flo=15.20 flo=32.3+e18</p></blockquote></li><li>复数：由实部和虚部组成<blockquote><p>如： fus=a+bj fus=complex(a,b)</p></blockquote></li></ol><h2 id="lists-列表）"><a href="#lists-列表）" class="headerlink" title="lists(列表）"></a>lists(列表）</h2><p>列表是较为常见的数据结构<br>列表中每一个元素都有一个特定的索引（每一个元素分配一个数字）</p><h3 id="列表的创建-1"><a href="#列表的创建-1" class="headerlink" title="列表的创建"></a>列表的创建</h3><p>list=[‘python’,’lin’,1,2,3]</p><blockquote><p>也就是说，列表中的元素不需要一定同类型</p></blockquote><h3 id="列表的操作包括：索引，切片，加，乘，检查成员-1"><a href="#列表的操作包括：索引，切片，加，乘，检查成员-1" class="headerlink" title="列表的操作包括：索引，切片，加，乘，检查成员"></a>列表的操作包括：索引，切片，加，乘，检查成员</h3><blockquote><p>索引（正向读取）—var=list[0]—–var=’python’。<br>索引（逆向读取）—var=list[-1]—-var=3—–(-1就是倒数第一个<br>索引(替换）—var=2。list[2]=var—-list2=[‘python’,’lin’,2,2,3]</p><p>切片—lis=list[0:3]—lis=[‘python’,’lin’,1]（包括头不包括尾）</p><p>加(也可以用list.extend（lis））—–lit=lis+list—-lit=<br>[‘python’,’lin’,1,’python’,’lin’,1,2,3]</p></blockquote><blockquote><p>乘—–lis2=list[2:5] lis3=lis2*2—-lis3=[1,2,3,1,2,3]</p></blockquote><h3 id="通过内置函数和方法，可以实现-1"><a href="#通过内置函数和方法，可以实现-1" class="headerlink" title="通过内置函数和方法，可以实现:"></a>通过内置函数和方法，可以实现:</h3><ul><li>比较（cmp(a,b)，</li><li>添加成员(list.append(obj)(obj可以是列表，也可以是成员)，</li><li>计算长度（len（a))，</li><li>返回最值(max(a);min(a)),</li><li>统计某成员出现次数（list.count(obj)),</li><li>反向排序（list.reverse())，</li><li>移除特定成员（list.remove（obj）），</li><li>移除特定位置成员（list.pop(-1)(-1为最后一项，0为第一个，1为第二个…)</li><li>找出特定对象的索引位置（list.index(obj))(找出obj的索引位置）</li><li>将对象插入特定位置（list.insert（index，obj））</li><li>对原列表进行排序（list.sort())</li></ul><h3 id="列表与字符串的转化-1"><a href="#列表与字符串的转化-1" class="headerlink" title="列表与字符串的转化"></a>列表与字符串的转化</h3><h4 id="列表-gt-字符串-1"><a href="#列表-gt-字符串-1" class="headerlink" title="列表 =&gt; 字符串"></a>列表 =&gt; 字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list=[&apos;lin&apos;,&apos;mu&apos;,&apos;shen&apos;]</span><br><span class="line">print &apos; &apos;.join(list)</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote></blockquote><p>lin mu shen</p><p>用字符串的形式显示并用空格分隔列表中的成员。</p><h4 id="字符串-gt-列表-1"><a href="#字符串-gt-列表-1" class="headerlink" title="字符串 =&gt; 列表"></a>字符串 =&gt; 列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var=&apos;lin mu shen&apos;</span><br><span class="line">list=var.split(&apos; &apos;)</span><br><span class="line">print list</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote></blockquote><p>[‘lin’,’mu’,’shen’]</p><p>以空格为每一个成员分隔点创建列表。</p><h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>只需要复制\征服蟒蛇\projects\skeleton中所有内容然后将其粘贴到projecs中的项目文件中。</li><li>将其中所有NAME的文件都改为新项目的名字。</li><li>删除所有.pyc文件</li><li>在原NAME文件下创建新的项目py文件</li><li>根据需要，更改原NAME_tests.py（测试脚本）文件</li></ol><h2 id="作者的建议"><a href="#作者的建议" class="headerlink" title="作者的建议"></a>作者的建议</h2><ol><li>测试脚本要放在tests/目录下，且命名必须符合NAME_tests.py的规则。</li><li>为每一个模块写一个测试。</li><li>测试用例尽可能易懂又易写，但要尽量保持整洁。</li><li>别太把测试当回事。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了更方便的记笔记，我搭建了这个博客&lt;br&gt;
    
    </summary>
    
      <category term="python学习" scheme="http://linmushen.com/categories/python-study/"/>
    
    
  </entry>
  
</feed>
